
<pre class="metadata">
Title: Background Fetch
Shortname: background-fetch
Level: 1
Status: ED
Group: wicg
URL: https://wicg.github.io/background-fetch/
Editor: Jake Archibald, Google, jakearchibald@google.com
Editor: Peter Beverloo, Google, beverloo@google.com
Abstract: An API to handle large uploads/downloads in the background with user visibility.
Markup Shorthands: css no, markdown yes
Indent: 2
</pre>

<pre class="link-defaults">
spec:infra; type:dfn; text:list
spec:fetch; type:interface; text:ReadableStream
spec:promises-guide-1; type:dfn; text:resolve
</pre>

# Introduction # {#intro}

A [=service worker=] is capable of fetching and caching assets, the size of which is restricted only by [origin storage](https://storage.spec.whatwg.org/#usage-and-quota). However, if the user navigates away from the site or closes the browser, the service worker is [[service-workers#service-worker-lifetime|likely to be killed]]. This can happen even if there's a pending promise passed to {{ExtendableEvent/waitUntil()}}; if it hasn't resolved within a few minutes the browser may consider it an abuse of [=service worker=] and kill the process.

This makes it difficult to download and cache large assets such as podcasts and movies, and upload video and images. Even if the [=service worker=] isn't killed, having to keep the [=service worker=] in memory during this potentially long operation is wasteful.

This specification aims to:

* Allow [=/fetches=] to continue even if the user closes all windows & worker to the origin.
* Allow a single job to involve many requests, as defined by the app.
* Allow the browser/OS to show UI to indicate the progress of the [=/fetch=], and allow the user to pause/abort.
* Allow the browser/OS to deal with poor connectivity by pausing/resuming the download/upload (may be tricky with uploads, as ranged uploads aren't standardized).
* Allow the app to react to success/failure of the background fetch group, perhaps by caching the results.
* Allow access to background-fetched resources as they [=/fetch=].
* Allow the app to display progress information about a background fetch.
* Allow the app to suggest which connection types the [=/fetch=] should be restricted to.

# Infrastructure # {#infrastructure}

The <dfn>background fetch task source</dfn> is a [=task source=]. All queued tasks in this specification use the [=background fetch task source=] unless otherwise noted.

## Extensions to service worker registration ## {#service-worker-registration-concept-extensions}

A [=/service worker registration=] additionally has:

<div dfn-for="service worker registration">
  * An associated <dfn>active background fetches</dfn> (a [=map=]), where each key is a DOMString, and each item is a [=/background fetch=]. It is initially an empty [=map=].
  * An associated <dfn>active background fetches edit queue</dfn> (a [=parallel queue=]), initially the result of [=starting a new parallel queue=].
</div>

<div algorithm>
  To determine whether an [=active background fetches=] <dfn for="active background fetches">contains</dfn> |bgFetch| (a [=/background fetch=]), run these steps:

  1. Let |id| be |bgFetch|'s [=background fetch/id=].
  1. If |activeBgFetches|[|id|] does not [=map/exist=], then return false.
  1. If |activeBgFetches|[|id|] does not equal |bgFetch|, then return false.
  1. Return true.
</div>

## Background fetch ## {#background-fetch-concept}

A <dfn>background fetch</dfn> consists of:

<div dfn-for="background fetch">
  * An <dfn>id</dfn> (a DOMString).
  * <dfn>Records</dfn> (a [=list=] of [=/background fetch records=]).
  * A <dfn>title</dfn> (a DOMString).
  * A <dfn>download total</dfn> (a number).
  * An <dfn>upload total</dfn> (a number).
  * A <dfn>last reported download</dfn> (a number), initially 0.
  * <dfn>Icons</dfn> (a [=list=] of {{IconDefinition}}s).
  * A <dfn>service worker registration</dfn> (a [=/service worker registration=]).
  * A <dfn>progress handling queue</dfn> (a [=parallel queue=]), initially the result of [=starting a new parallel queue=].
  * A <dfn>paused flag</dfn>, initially unset.


  <div algorithm>
    To <dfn>display</dfn> a [=/background fetch=] (|bgFetch|), the user agent must present a user interface that follows these rules:

    * The |bgFetch|'s [=background fetch/service worker registration=]'s [=service worker registration/scope url=]'s [=url/origin=] must be displayed.
    * The UI may display |bgFetch|'s [=background fetch/title=].
    * The UI may display one of |bgFetch|'s [=background fetch/icons=].
    * The UI may use |bgFetch|'s [=background fetch/download total=], [=background fetch/upload total=], [=background fetch/last reported download=], and [=background fetch/paused flag=] to present the progress of the fetch. TODO what about bytes uploaded? TODO how can I tell when the operation is complete?
    * The UI must provide a way for the user to abort |bgFetch|. TODO link up to algo.
    * The UI may provide a way to toggle |bgFetch|'s [=background fetch/paused flag=].
    * The UI may be activated (for example, by clicking), in which case it must TODO hook this up to the event.
    * The UI may remain once the operation is complete, in which case it can still be activated.

    The user agent may initially set |bgFetch|'s [=background fetch/paused flag=], and allow the user to either accept the background fetch (unsetting |bgFetch|'s [=background fetch/paused flag=]), or refuse the background fetch (aborting TODO hook this up).

    Note: The user agent may consider this if the user is on a metered connection, or the background fetch was started in the background.
  </div>
</div>

## Background fetch record ## {#background-fetch-record-concept}

A <dfn>background fetch record</dfn> consists of:

<div dfn-for="background fetch record">
  * A <dfn>request</dfn> (a [=/request=]).
  * A <dfn>response</dfn> (a [=/response=]), initially null.
  * A <dfn>response body</dfn> (a [=byte sequence=]), initially empty.
</div>

# Algorithms # {#algorithms}

## [=Attempt a background fetch=] ## {#attempt-a-background-fetch-algorithm}

<div algorithm>
  To <dfn>attempt a background fetch</dfn> for |bgFetch| (a [=/background fetch=]), run these steps:

  1. [=background fetch/Display=] |bgFetch|.
  1. Let |swRegistration| be |bgFetch|'s [=background fetch/service worker registration=].
  1. Let |completeFetches| be 0.
  1. Let |storedBytes| be 0. TODO: track and react to this, to prevent too much being downloaded.
  1. Let |downloadTotal| be |bgFetch|'s [=background fetch/download total=] if it is not 0, otherwise infinity.
  1. Let |abandoned| be false.
  1. Let |aborted| be false.
  1. [=list/For each=] |record| in |bgFetch|'s [=background fetch/records=], run these steps [=in parallel=]:
    1. While true:
      1. Wait for |bgFetch|'s [=background fetch/paused flag=] to be unset.
      1. Let |request| be a copy of |record|'s [=background fetch record/request=].
      1. Set |request|'s [=request/keepalive flag=].
      1. Set |request|'s [=request/synchronous flag=].
      1. Let |currentBodyLength| be the [=byte sequence/length=] of |record|'s [=background fetch record/response body=].
      1. If |currentBodyLength| is not 0, then [=request/add a range header=] to |request| with |currentLength|.

        Note: This allows the initially request to make use of content encoding, since `Accept-Encoding: identity` is added to requests with a range header.

      1. Let |response| be the result of [=/fetching=] |request|.

        Issue: Fetch waits for the body before returning |response|. Let's pretend it *doesn't* do that ([issue](https://github.com/whatwg/fetch/issues/536#issuecomment-330184276)).

      1. If |response| is a [=network error=], then:
        1. If the user agent is offline and |request|'s [=request/method=] is \``GET`\`, wait until the user agent is not offline and [=continue=].

          Issue: Is "user agent is offline" hand-waving too much? Also discussed in [fetch/526](https://github.com/whatwg/fetch/issues/526#issuecomment-380686368).

          Note: If |request|'s [=request/method=] is not \``GET`\`, reissuing the request may have unwanted side effects. If a standard method to resume requests becomes available, we'll adopt it here.

        1. If |response| is an [=aborted network error=], then set |aborted| to true.
        1. Set |abandoned| to true and abort these steps.
      1. If |response|'s [=response/status=] is not an [=ok status=], then set |abandoned| to true and abort these steps.
      1. If |response|'s [=response/status=] is `206`, then:
        1. If [=validate a partial response=] for |request|, |response|, and |record|'s [=background fetch record/response=] returns invalid, then set |abandoned| to true and abort these steps.
      1. Otherwise:
        1. Decrement |storedBytes| by the [=byte sequence/length=] of |record|'s [=background fetch record/response body=].
        1. Set |record|'s [=background fetch record/response body=] to an empty [=byte sequence=].
      1. Set |record|'s [=background fetch record/response=] to a copy of |response| except for its [=response/body=].

        Note: This may be replacing an existing value. It's acceptable for earlier responses to be missing things like \``ETag`\` headers, and complete lengths from \``Content-Range`\` headers, but once a later response has them, we want to compare them against subsequent responses.

      1. Let |stream| be |response|'s [=response/body=]'s [=body/stream=].
      1. Whenever one or more bytes are transmitted from |stream|, let |bytes| be the transmitted bytes and run these steps:
        1. Append |bytes| to |record|'s [=background fetch record/response body=].
        1. Increment |downloadTotal| by |bytes| size.
        1. TODO check downloadTotal limit
        1. [=Report progress for background fetch=] |bgFetch|.
      1. If at any point the bytes transmission for |stream| is done normally, then increment |completeFetches|.
      1. If at any point |stream| becomes [=stream/errored=], then:
        1. If |response|'s [=response/aborted flag=] is set, then set |aborted| to true.
        1. Set |abandoned| to true. TODO: if |aborted| isn't true, this could be another resume point.
  1. Wait for either |abandoned| to be true, or |completeFetches| to be |bgFetch|'s [=background fetch/records=]'s [=list/size=].
  1. Let |operationAborted| be |aborted|.
  1. If |abandoned| is true:
      1. TODO: terminate all related fetches.
  1. [=Enqueue the following steps=] to |swRegistration|'s [=active background fetches edit queue=]:
    1. Let |activeBgFetches| be |swRegistration|'s [=active background fetches=].
    1. Let |id| be |bgFetch|'s [=background fetch/id=].
    1. If |activeBgFetches| [=active background fetches/contains=] |bgFetch|, then remove |activeBgFetches|[|id|].
    1. Otherwise, set |operationAborted| to true.

      Note: This handles a race condition where {{BackgroundFetchRegistration/abort()}} was successfully called but one of the fetches failed at the same time. If we've returned true from {{BackgroundFetchRegistration/abort()}}, this ensures we fire the related abort event.
    1. If |operationAborted| is true, then [=fire a functional event=] named "`backgroundfetchabort`" using {{BackgroundFetchSettledEvent}} on |swRegistration| with the following properties:
      : {{BackgroundFetchSettledEvent/fetches}}
      :: A new {{BackgroundFetchSettledFetches}}. TODO: associate this with |bgFetch|'s [=background fetch/records=].

      Issue: The above prose is based on [ServiceWorker/#1199](https://github.com/w3c/ServiceWorker/pull/1199).
    1. Otherwise, if |abandoned| is true, then [=fire a functional event=] named "`backgroundfetchfail`" using {{BackgroundFetchUpdateEvent}} on |swRegistration| with the following properties:
      : {{BackgroundFetchSettledEvent/fetches}}
      :: A new {{BackgroundFetchSettledFetches}}. TODO: associate this with |bgFetch|'s [=background fetch/records=].
    1. Otherwise, [=fire a functional event=] named "`backgroundfetched`" using {{BackgroundFetchUpdateEvent}} on |swRegistration| with the following properties:
      : {{BackgroundFetchSettledEvent/fetches}}
      :: A new {{BackgroundFetchSettledFetches}}. TODO: associate this with |bgFetch|'s [=background fetch/records=].
</div>

## [=Report progress for background fetch=] ## {#report-progress-for-background-fetch-algorithm}

<div algorithm>
  To <dfn>report progress for background fetch</dfn> |bgFetch| (a [=/background fetch=]), [=enqueue the following steps=] to |bgFetch|'s [=background fetch/progress handling queue=]:

  1. Let |downloaded| be 0.
  1. [=list/For each=] |record| in |bgFetch|'s [=background fetch/records=], increment |downloaded| by the number of bytes in [=background fetch record/response body=].
  1. If |downloaded| is equal to |bgFetch|'s [=background fetch/last reported download=], then abort these steps.
  1. Set |bgFetch|'s [=background fetch/last reported download=] to |downloaded|.
  1. For each [=environment settings object=] |env| whose [=environment settings object/origin=] is equal to |bgFetch|'s [=background fetch/service worker registration=]'s [=service worker registration/scope URL=]'s [=url/origin=], [=queue a task=] on |env|'s [=environment settings object/responsible event loop=] to run these steps:
    1. Let |bgFetchRegistration| be the instance of {{BackgroundFetchRegistration}} within this environment whose [=BackgroundFetchRegistration/background fetch=] is equal to |bgFetch|, or null if none exists.

      Note: There will be at most one per environment, because of the [=get a BackgroundFetchRegistration instance=] algorithm.
    1. If |bgFetchRegistration| is not null, then:
      1. Set [=BackgroundFetchRegistration/downloaded=] to |downloaded|.
      1. [=fire an event=] named "`progress`" at |bgFetchRegistration|.
</div>

## [=Get a BackgroundFetchRegistration instance=] ## {#get-a-backgroundfetchregistration-instance-algorithm}

<div algorithm>
  To <dfn data-lt="get a BackgroundFetchRegistration instance|getting a BackgroundFetchRegistration instance">get a BackgroundFetchRegistration instance</dfn> for an |instancesMap| (a [=BackgroundFetchRegistration instances=]) and a |bgFetch| (a [=/background fetch=]), run these steps:

  1. If |instancesMap|[|bgFetch|] [=map/exists=], then return |instancesMap|[|bgFetch|].
  1. Let |instance| be a new {{BackgroundFetchRegistration}} in the parent {{BackgroundFetchManager}}'s [=relevant Realm=], and set it's [=BackgroundFetchRegistration/background fetch=] to |bgFetch|.
  1. Set |instancesMap|[|bgFetch|] to |instance|.
  1. Return |instance|.

  Note: This is to ensure the same instance is returned for a given [=/background fetch=] throughout the life of a {{BackgroundFetchManager}}. It's okay for browsers to optimise this, as long as there's no way to tell that more than one instance has been created for a given [=/background fetch=] (e.g through equality, expandos, or weakly-associated data).
</div>

## [=Validate a partial response=] ## {#validate-partial-response-algorithm}

<div algorithm>
  To <dfn>validate a partial response</dfn> for a |request| (a [=/request=]), a |partialResponse| (a [=/response=]), and an optional |previousPartialResponse| (a [=/response=] or null, null unless otherwise specified), run these steps:

  1. Assert: |request|'s [=request/header list=] [=header list/contains=] \``Range`\`.
  1. Assert: |partialResponse|'s [=response/status=] is `206`.
  1. Let |rangeValue| be the [=header/value=] of the first [=header=] whose [=header/name=] is a [=byte-case-insensitive=] match for \``Range`\` in |request|'s [=request/header list=].
  1. If parsing |rangeValue| per [=single byte range=] fails, then return invalid.
  1. Let |responseFirstBytePos|, |responseLastBytePos|, and |responseCompleteLength| be the result of [=extracting content-range values=] from |partialResponse|. If this fails, then return invalid.
  1. If |requestFirstBytePos| does not equal |responseFirstBytePos|, then return invalid.
  1. If |previousPartialResponse| is given, then:
    1. If |previousPartialResponse|'s [=response/header list=] [=header list/contains=] \``ETag`\`, and [=header equality=] for \``ETag`\`, |previousPartialResponse|, and |partialResponse| is false, then return invalid.
    1. If |previousPartialResponse|'s [=response/header list=] [=header list/contains=] \``Last-Modified`\`, and [=header equality=] for \``Last-Modified`\`, |previousPartialResponse|, and |partialResponse| is false, then return invalid.
    1. If |responseCompleteLength| is not null, then:
      1. Let |previousResponseFirstBytePos|, |previousResponseLastBytePos|, and |previousResponseCompleteLength| be the result of [=extracting content-range values=] from |previousPartialResponse|. If this fails, then return invalid.
      1. If |responseCompleteLength| does not equal |previousResponseCompleteLength|, then return invalid.
  1. Return valid.
</div>

## [=Extract content-range values=] ## {#extract-content-range-values-algorithm}

<div algorithm>
  To <dfn lt="extract content-range values|extracting content-range values">extract content-range values</dfn> from a |response| (a [=/response=]), run these steps:

  1. If |response|'s [=response/header list=] does not [=header list/contain=] \``Content-Range`\`, then return failure.
  1. Let |contentRangeValue| be the [=header/value=] of the first [=header=] whose [=header/name=] is a [=byte-case-insensitive=] match for \``Content-Range`\` in |response|'s [=response/header list=].
  1. If parsing |contentRangeValue| per [=single byte content-range=] fails, then return failure.
  1. Let |firstBytePos| be the portion of |contentRangeValue| named `first-byte-pos` when parsed as [=single byte content-range=], parsed as an integer.
  1. Let |lastBytePos| be the portion of |contentRangeValue| named `last-byte-pos` when parsed as [=single byte content-range=], parsed as an integer.
  1. Let |completeLength| be the portion of |contentRangeValue| named `complete-length` when parsed as [=single byte content-range=].
  1. If |completeLength| is `"*"`, then set |completeLength| to null, otherwise set |completeLength| to |completeLength| parsed as an integer.
  1. Return |firstBytePos|, |lastBytePos|, and |completeLength|.

  Issue: Parsing as an integer [infra/189](https://github.com/whatwg/infra/issues/189).
</div>

## [=Header equality=] ## {#header-equality-algorithm}

<div algorithm>
  To determine <dfn>header equality</dfn> for a |headerName| (a [=byte sequence=]), in |response1| (a [=/response=]), and |response2| (a [=/response=]), run these steps:

  1. If |response1|'s [=response/header list=] does not [=header list/contain=] |headerName|, and |response2|'s [=response/header list=] does not [=header list/contain=] |headerName|, then return true.
  1. If |response1|'s [=response/header list=] [=header list/contains=] |headerName|, and |response2|'s [=response/header list=] [=header list/contains=] |headerName|, then:
    1. Let |response1Value| be the [=header/value=] of the first [=header=] whose [=header/name=] is a [=byte-case-insensitive=] match for |headerName| in |response1|'s [=response/header list=].
    1. Let |response2Value| be the [=header/value=] of the first [=header=] whose [=header/name=] is a [=byte-case-insensitive=] match for |headerName| in |response2|'s [=response/header list=].
    1. If |response1Value| is identical to |response2Value|, then return true, otherwise return false.
  1. Return false.
</div>

# Range header syntax # {#range-header-syntax}

The following is [=ABNF=] for a <dfn>single byte range</dfn>:

<pre>
"bytes=" first-byte-pos "-" [ last-byte-pos ]
first-byte-pos = 1*DIGIT
last-byte-pos  = 1*DIGIT</pre>

The following is [=ABNF=] for a <dfn>single byte content-range</dfn>:

<pre>
"bytes=" first-byte-pos "-" last-byte-pos "/" complete-length
complete-length = ( 1*DIGIT / "*" )</pre>

# API # {#api}

## Extensions to {{ServiceWorkerGlobalScope}} ## {#extensions-to-service-worker-global}

<script type="idl">
partial interface ServiceWorkerGlobalScope {
  attribute EventHandler onbackgroundfetched;
  attribute EventHandler onbackgroundfetchfail;
  attribute EventHandler onbackgroundfetchabort;
  attribute EventHandler onbackgroundfetchclick;
};
</script>

### Events ### {#service-worker-global-events}

The following is the <a>event handler</a> (and its corresponding <a>event handler event type</a>) that must be supported, as <a>event handler IDL attributes</a>, by all objects implementing {{ServiceWorker}} interface:

<table class="data">
  <thead>
    <tr>
      <th>[=event handler event type=]</th>
      <th>[=event handler=]</th>
      <th>Interface</th>
    </tr>
  </thead>
  <tbody dfn-for="ServiceWorkerGlobalScope" dfn-type="event">
    <tr>
      <td><dfn>backgroundfetched</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetched}}</td>
      <td>{{BackgroundFetchUpdateEvent}}</td>
    </tr>
    <tr>
      <td><dfn>backgroundfetchfail</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetchfail}}</td>
      <td>{{BackgroundFetchUpdateEvent}}</td>
    </tr>
    <tr>
      <td><dfn>backgroundfetchabort</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetchabort}}</td>
      <td>{{BackgroundFetchSettledEvent}}</td>
    </tr>
    <tr>
      <td><dfn>backgroundfetchclick</dfn></td>
      <td>{{ServiceWorkerGlobalScope/onbackgroundfetchclick}}</td>
      <td>{{BackgroundFetchClickEvent}}</td>
    </tr>
  </tbody>
</table>

## Extensions to {{ServiceWorkerRegistration}} ## {#extensions-to-service-worker-registration}

<script type="idl">
partial interface ServiceWorkerRegistration {
  readonly attribute BackgroundFetchManager backgroundFetch;
};
</script>

Each {{ServiceWorkerRegistration}} instance has a unique instance of {{BackgroundFetchManager}}, allocated when the {{ServiceWorkerRegistration}} object is created. It's [=BackgroundFetchManager/service worker registration=] is set to {{ServiceWorkerRegistration}}'s [=/service worker registration=].

The <dfn attribute for="ServiceWorkerRegistration">backgroundFetch</dfn> attribute must return the {{BackgroundFetchManager}} object that is associated with the [=context object=].

## {{BackgroundFetchManager}} ## {#background-fetch-manager}

<script type="idl">
[Exposed=(Window,Worker)]
interface BackgroundFetchManager {
  Promise<BackgroundFetchRegistration> fetch(DOMString id, (RequestInfo or sequence<RequestInfo>) requests, optional BackgroundFetchOptions options);
  Promise<BackgroundFetchRegistration?> get(DOMString id);
  Promise<FrozenArray<DOMString>> getIds();
  // TODO: in future this should become an async iterator for BackgroundFetchRegistration objects
};

dictionary BackgroundFetchOptions {
  sequence<IconDefinition> icons = [];
  DOMString title = "";
  unsigned long long downloadTotal = 0;
};

// This is taken from https://w3c.github.io/manifest/#icons-member.
// This definition should probably be moved somewhere more general.
dictionary IconDefinition {
  DOMString src;
  DOMString sizes = "";
  DOMString type = "";
};
</script>

<div dfn-for="BackgroundFetchManager">

  A {{BackgroundFetchManager}} has:

  <div dfn-for="BackgroundFetchManager">
    * A <dfn>BackgroundFetchRegistration instances</dfn> (a [=map=]), where the keys are [=/background fetch|background fetches=] and the values are {{BackgroundFetchRegistration}} objects. It is initially empty.
    * A <dfn>service worker registration</dfn> (a [=/service worker registration=]).
  </div>

  ### {{BackgroundFetchManager/fetch()}} ### {#background-fetch-manager-fetch}

  <div algorithm>
    The <dfn method>fetch(|id|, |requests|, |options|)</dfn> method, when invoked, run these steps:

    1. Let |registration| be the [=context object=]'s [=BackgroundFetchManager/service worker registration=].
    1. Let |bgFetchInstances| be [=context object=]'s [=BackgroundFetchRegistration instances=].
    1. Let |records| be a new [=list=].
    1. Let |uploadTotal| be 0.
    1. If |requests| is a {{RequestInfo}}, set |requests| to « |requests| ».
    1. If |requests| is [=list/empty=], then return [=a promise rejected with=] a {{TypeError}}.
    1. [=list/For each=] |request| of |requests|:
      1. Let |internalRequest| be the [=Request/request=] of the result of invoking the {{Request}} constructor with |request|.
      1. If |internalRequest|'s [=request/mode=] is "`no-cors`", then return [=a promise rejected with=] a {{TypeError}}.
      1. Set |internalRequest|'s [=request/client=] to null.
      1. Let |record| be a new [=background fetch record=].
      1. Set |record|'s [=background fetch record/request=] to |internalReqeust|.
      1. [=list/Append=] |record| to |records|.
    1. Let |promise| be [=a new promise=].
    1. [=Enqueue the following steps=] to |registration|'s [=active background fetches edit queue=]:
      1. Let |bgFetchMap| be |registration|'s [=active background fetches=].
      1. If |registration|'s [=service worker registration/active worker=] is null, then reject |promise| with a {{TypeError}} and abort these steps.
      1. If |bgFetchMap|[|id|] [=map/exists=], [=reject=] |promise| with a {{TypeError}} and abort these steps.
      1. Let |requestBodiesRemaining| be the [=list/size=] of |requests|.
      1. Let |requestReadAborted| be false.
      1. [=list/For each=] |request| of |requests|:
        1. If |request|'s [=request/body=] is null, then [=continue=].
        1. Let |stream| be |request|'s [=request/body=]'s [=body/stream=].
        1. Run these steps [=in parallel=]:
          1. Run these steps but [=abort when=] |requestReadAborted| is true:
            1. [=body/Wait=] for |request|'s [=request/body=].
            1. If |stream| has [=stream/errored=], then set |requestReadAborted| to true.

            Note: This ensures we have a copy of the request bytes before resolving.
          1. [=If aborted=] and |stream| is [=stream/readable=], then [=stream/error=] |stream| with an {{AbortError}} {{DOMException}} and abort these steps.
          1. Increment |uploadTotal| by |request|'s [=request/body=]'s [=body/total bytes=].
          1. Decrement |requestBodiesRemaining| by 1.
      1. Wait for |requestBodiesRemaining| to be 0, or |requestReadAborted| to be true.
      1. If storing |requests| fails due to exceeding a quota limit, [=reject=] |promise| with a {{QuotaExceededError}} {{DOMException}} and abort these steps.
      1. If |requestReadAborted| is true, then [=reject=] |promise| with a {{TypeError}} and abort these steps.
      1. Let |bgFetch| be a new [=/background fetch=] with:
        : [=background fetch/id=]
        :: |id|.
        : [=background fetch/records=]
        :: |records|.
        : [=background fetch/download total=]
        :: |options|' `downloadTotal` member.
        : [=background fetch/upload total=]
        :: |uploadTotal|.
        : [=background fetch/icons=]
        :: |options|' `icons` member.
        : [=background fetch/title=]
        :: |options|' `title` member.
        : [=background fetch/service worker registration=]
        :: |registration|.
      1. Set |bgFetchMap|[|id|] to |bgFetch|.
      1. [=Queue a task=] to run these steps:
        1. [=Resolve=] |promise| with the result of [=getting a BackgroundFetchRegistration instance=] passing |bgFetchInstances| and |bgFetch|.
      1. [=In parallel=], [=attempt a background fetch=] with |bgFetch|.
    1. Return |promise|.
  </div>

  ### {{BackgroundFetchManager/get()}} ### {#background-fetch-manager-get}

  <div algorithm>
    The <dfn method>get(|id|)</dfn> method, when invoked, must return [=a new promise=] |promise| and run these steps [=in parallel=]:

    1. Let |registration| be the [=context object=]'s associated [=BackgroundFetchManager/service worker registration=].
    1. Let |bgFetch| be |registration|'s [=active background fetches=][|id|].
    1. If |bgFetch| is nothing, then [=resolve=] |promise| with undefined and abort these steps.
    1. Let |downloaded| be |bgFetch|'s [=background fetch/last reported downloaded=].
    1. [=Enqueue the following steps=] to |bgFetch|'s [=background fetch/progress handling queue=]:
      1. [=Queue a task=] |task| to run these steps:
        1. Let |bgFetchRegistration| be the result of [=getting a BackgroundFetchRegistration instance=] passing the [=context object=]'s [=BackgroundFetchRegistration instances=] and |bgFetch|.
        1. Set |bgFetchRegistration|'s [=BackgroundFetchRegistration/downloaded=] to |downloaded|.
        1. [=Resolve=] |promise| with |bgFetchRegistration|.
      1. Wait for |task| to complete.

        Note: This ensures the potential new instance of {{BackgroundFetchRegistration}} doesn't miss any {{BackgroundFetchRegistration/progress!!event}} events.
  </div>

  ### {{BackgroundFetchManager/getIds()}} ### {#background-fetch-manager-get-ids}

  <div algorithm>
    The <dfn method>getIds()</dfn> method, when invoked, must return [=a new promise=] |promise| and run these steps [=in parallel=]:

    1. Let |registration| be the [=context object=]'s associated [=BackgroundFetchManager/service worker registration=].
    1. Let |ids| be the result of [=map/getting the keys=] of |registration|'s [=active background fetches=].
    1. [=Resolve=] |promise| with |ids|.
  </div>
</div>

## {{BackgroundFetchRegistration}} ## {#background-fetch-registration}

<script type="idl">
[Exposed=(Window,Worker)]
interface BackgroundFetchRegistration : EventTarget {
  readonly attribute DOMString id;
  readonly attribute unsigned long long uploadTotal;
  readonly attribute unsigned long long uploaded;
  readonly attribute unsigned long long downloadTotal;
  readonly attribute unsigned long long downloaded;
  readonly attribute BackgroundFetchActiveFetches activeFetches;

  attribute EventHandler onprogress;

  Promise<boolean> abort();
};

[Exposed=(Window,Worker)]
interface BackgroundFetchFetch {
  readonly attribute Request request;
};

[Exposed=(Window,Worker)]
interface BackgroundFetchActiveFetches {
  Promise<BackgroundFetchActiveFetch> match(RequestInfo request);
  Promise<FrozenArray<BackgroundFetchActiveFetch>> values();
};

[Exposed=(Window,Worker)]
interface BackgroundFetchActiveFetch : BackgroundFetchFetch {
  readonly attribute Promise<Response> responseReady;
  // In future this will include a fetch observer
};
</script>

<div dfn-for="BackgroundFetchRegistration">
  A {{BackgroundFetchRegistration}} instance has an associated <dfn>background fetch</dfn> (a [=/background fetch=]).

  A {{BackgroundFetchRegistration}} instance has an associated <dfn>downloaded</dfn> (a number), initially 0.

  A {{BackgroundFetchRegistration}} instance has an associated <dfn>id</dfn>, <dfn>uploadTotal</dfn>, and <dfn>downloadTotal</dfn>, which are copied from the [=BackgroundFetchRegistration/background fetch=] upon instantiation.

  The <dfn attribute>id</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/id=].

  The <dfn attribute>uploadTotal</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/uploadTotal=].

  The <dfn attribute>downloadTotal</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/downloadTotal=].

  The <dfn attribute>uploaded</dfn> attribute's getter must return TODO.

  The <dfn attribute>downloaded</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/downloaded=].

  The <dfn attribute>activeFetches</dfn> attribute's getter must return the [=context object=]'s [=BackgroundFetchRegistration/background fetch=]'s TODO. Need to make sure the response objects have the correct content-length and no content-range.

  ### Events ### {#background-fetch-registration-events}

  The <dfn attribute>onprogress</dfn> [=event handler=] has the [=event handler event type=] of {{progress!!event}}.

  The <dfn event>progress</dfn> event uses the {{Event}} interface.

  ### {{BackgroundFetchRegistration/abort()}} ### {#background-fetch-registration-abort}

  <div algorithm>
    The <dfn method>abort()</dfn> method, when invoked, must return [=a new promise=] |promise| and run these steps [=in parallel=]:

    1. Let |bgFetch| be the [=context object=]'s associated [=BackgroundFetchRegistration/background fetch=].
    1. Let |swRegistration| be |bgFetch|'s [=background fetch/service worker registration=].
    1. [=Enqueue the following steps=] to |swRegistration|'s [=active background fetches edit queue=]:
      1. Let |activeBgFetches| be |swRegistration|'s [=active background fetches=].
      1. Let |id| be |bgFetch|'s [=background fetch/id=].
      1. If |activeBgFetches| does not [=active background fetches/contain=] |bgFetch|, then [=resolve=] |promise| with false and abort these steps.
      1. Remove |activeBgFetches|[|id|].
      1. [=Resolve=] |promise| with true.
      1. TODO: [=fetch/Terminate=] related fetches with the *aborted* flag set.
  </div>
</div>

### {{BackgroundFetchEvent}} ### {#background-fetch-event}

<script type="idl">
[Constructor(DOMString type, BackgroundFetchEventInit init), Exposed=ServiceWorker]
interface BackgroundFetchEvent : ExtendableEvent {
  readonly attribute DOMString id;
};

dictionary BackgroundFetchEventInit : ExtendableEventInit {
  required DOMString id;
};
</script>

<div dfn-for="BackgroundFetchEvent">
  A {{BackgroundFetchEvent}} has an associated <dfn>id</dfn>, a DOMString.

  The <dfn attribute>id</dfn> attribute must return the [=BackgroundFetchEvent/id=].

  TODO
</div>

<div algorithm>
  The <dfn constructor for="BackgroundFetchEvent">BackgroundFetchEvent(|type|, |init|)</dfn> constructor, when invoked, must run these steps:

  1. TODO
</div>

### {{BackgroundFetchSettledEvent}} ### {#background-fetch-settled-event}

<script type="idl">
[Constructor(DOMString type, BackgroundFetchSettledEventInit init), Exposed=ServiceWorker]
interface BackgroundFetchSettledEvent : BackgroundFetchEvent {
  readonly attribute BackgroundFetchSettledFetches fetches;
};

dictionary BackgroundFetchSettledEventInit : BackgroundFetchEventInit {
  required BackgroundFetchSettledFetches fetches;
};

[Exposed=ServiceWorker]
interface BackgroundFetchSettledFetches {
  Promise<BackgroundFetchSettledFetch> match(RequestInfo request);
  Promise<FrozenArray<BackgroundFetchSettledFetch>> values();
};

[Exposed=ServiceWorker]
interface BackgroundFetchSettledFetch : BackgroundFetchFetch {
  readonly attribute Response? response;
};
</script>

<div dfn-for="BackgroundFetchSettledEvent">
  The <dfn attribute>fetches</dfn> attribute must return TODO.
</div>

<div algorithm>
  The <dfn constructor for="BackgroundFetchSettledEvent">BackgroundFetchSettledEvent(|type|, |init|)</dfn> constructor, when invoked, must run these steps:

  1. TODO
</div>

### {{BackgroundFetchUpdateEvent}} ### {#background-fetch-update-event}

<script type="idl">
[Constructor(DOMString type, BackgroundFetchSettledEventInit init), Exposed=ServiceWorker]
interface BackgroundFetchUpdateEvent : BackgroundFetchSettledEvent {
  Promise<void> updateUI(DOMString title);
};
</script>

<div dfn-for="BackgroundFetchUpdateEvent">
  <div algorithm>
    The <dfn constructor>BackgroundFetchUpdateEvent(|type|, |init|)</dfn> constructor, when invoked, must run these steps:

    1. TODO
  </div>

  <div algorithm>
    The <dfn method>updateUI(|title|)</dfn> method, when invoked, must return [=a new promise=] |promise| and run these steps [=in parallel=]:

    1. TODO
  </div>
</div>

### {{BackgroundFetchClickEvent}} ### {#background-fetch-click-event}

<script type="idl">
[Constructor(DOMString type, BackgroundFetchClickEventInit init), Exposed=ServiceWorker]
interface BackgroundFetchClickEvent : BackgroundFetchEvent {
  readonly attribute BackgroundFetchState state;
};

dictionary BackgroundFetchClickEventInit : BackgroundFetchEventInit {
  required BackgroundFetchState state;
};

enum BackgroundFetchState { "pending", "succeeded", "failed" };
</script>

# Privacy and bandwidth usage # {#privacy-and-bandwidth-use}

It's the recommendation of this standard that user agents make background fetch operations highly visible and easily abortable rather than asking permission up front. However, given that background fetches can be paused and retried, a user agent that immediately paused a background fetch and user interaction to resume would be compliant.

The [=/origin=] of a background fetch should have equal or great visibility to the developer-provided information, such as a the [=background fetch/icons=] and [=background fetch/title=].

A user agent may pause background downloads depending on network conditions or battery state. For example, a user agent may download automatically when connected to WiFi, but require user confirmation to download using mobile data. If an implementation has this restriction, the user should be able to persist granting mobile data use for the [=/origin=].

If the user agent provides a way for a user to abort a background fetch operation, it should [=fetch/terminate=] all fetches associated with the [=/background fetch=]'s [=background fetch/records=], with the *abort* flag set.

A background fetch exposes the user's external IPs to the server throughout the duration of the background fetch. An attacker could use an extremely slow background fetch as a way to persistently track the user once they've left the site. Good visibility into the progress of the background fetch will help the user identify unwanted use.
