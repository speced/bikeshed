<pre class="metadata">
Title: Navigation API
Shortname: navigation-api
Repository: WICG/navigation-api
Inline Github Issues: true
Group: WICG
Status: CG-DRAFT
Level: 1
URL: https://wicg.github.io/navigation-api/
Boilerplate: omit conformance, omit feedback-header
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: The navigation API provides a web application-focused way of managing same-origin same-frame history entries and navigations.
!Participate: <a href="https://github.com/WICG/navigation-api">GitHub WICG/navigation-api</a> (<a href="https://github.com/WICG/navigation-api/issues/new">new issue</a>, <a href="https://github.com/WICG/navigation-api/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/navigation-api/commits/main/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
Markup Shorthands: markdown yes
Assume Explicit For: yes
</pre>

<pre class="link-defaults">
spec: html; type: element; text: a
spec: html; type: element-attr; for: a; text: download
</pre>
<pre class="anchors">
spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
  type: dfn
    text: append the following session history traversal steps; url: browsing-the-web.html#tn-append-session-history-traversal-steps
    text: apply the history step; url: browsing-the-web.html#apply-the-history-step
    text: check if unloading is user-canceled; url: browsing-the-web.html#checking-if-unloading-is-user-canceled
    text: finalize a cross-document navigation; url: browsing-the-web.html#finalize-a-cross-document-navigation
    text: get all navigables whose current session history entry will change or reload; url: browsing-the-web.html#get-all-navigables-whose-current-session-history-entry-will-change-or-reload
    text: get the target history entry; url: browsing-the-web.html#getting-the-target-history-entry
    text: navigate to a fragment; url: browsing-the-web.html#navigate-fragid
    text: navigation and traversal task source; url: webappapis.html#navigation-and-traversal-task-source
    text: navigation ID; url: browsing-the-web.html#navigation-id
    text: node navigable; url: document-sequences.html#node-navigable
    text: restore the history state object; url: browsing-the-web.html#restore-the-history-object-state
    text: scroll to the fragment; url: browsing-the-web.html#scroll-to-the-fragment-identifier
    text: serialized state; url: browsing-the-web.html#serialized-state
    text: session history entry; url: browsing-the-web.html#session-history-entry
    text: shared history push/replace state steps; url: nav-history-apis.html#shared-history-push/replace-state-steps
    text: snapshot source snapshot params; url: browsing-the-web.html#snapshotting-source-snapshot-params
    text: top-level traversable; url: document-sequences.html#top-level-traversable
    text: traverse the history by a delta; url: browsing-the-web.html#traverse-the-history-by-a-delta
    text: update document for history step application; url: browsing-the-web.html#update-document-for-history-step-application
    text: update-only; url: browsing-the-web.html#changing-nav-continuation-update-only
    text: URL and history update steps; url: browsing-the-web.html#url-and-history-update-steps
    for: apply the history step
      text: checkForUserCancellation; url: browsing-the-web.html#apply-history-step-check
      text: initiatorToCheck; url: browsing-the-web.html#apply-history-step-initiator
      text: sourceSnapshotParams; url: browsing-the-web.html#apply-history-step-source-snapshot
    for: Document
      text: indicated part; url: browsing-the-web.html#the-indicated-part-of-the-document
      text: reactivate; url: browsing-the-web.html#reactivate-a-document
      text: unload; url: document-lifecycle.html#unload-a-document
    for: document state
      text: origin; url: browsing-the-web.html#document-state-origin
      text: request referrer policy; url: browsing-the-web.html#document-state-request-referrer-policy
    for: history handling behavior
      text: push; url: browsing-the-web.html#hh-push
      text: replace; url: browsing-the-web.html#hh-replace
    for: navigable
      text: active document; url: document-sequences.html#nav-document
      text: active session history entry; url: document-sequences.html#nav-active-history-entry
      text: active window; url: document-sequences.html#nav-window
      text: current session history entry; url: document-sequences.html#nav-current-history-entry
      text: get session history entries; url: browsing-the-web.html#getting-session-history-entries
      text: ongoing navigation; url: browsing-the-web.html#ongoing-navigation
      text: top-level traversable; url: document-sequences.html#nav-top
      text: traversable; url: document-sequences.html#nav-traversable
    for: navigate
      text: exceptionsEnabled; url: browsing-the-web.html#exceptions-enabled
      text: historyHandling; url: browsing-the-web.html#navigation-hh
    for: session history entry
      text: document state; url: browsing-the-web.html#she-document-state
      text: document; url: browsing-the-web.html#she-document
      text: scroll position data; url: browsing-the-web.html#she-scroll-position
      text: scroll restoration mode; url: browsing-the-web.html#she-scroll-restoration-mode
      text: step; url: browsing-the-web.html#she-step
      text: URL; url: browsing-the-web.html#she-url
    for: traversable navigable
      text: session history entries; url: document-sequences.html#tn-session-history-entries
      text: session history traversal queue; url: document-sequences.html#tn-session-history-traversal-queue
    for: URL and history update steps
      text: historyHandling; url: browsing-the-web.html#uhus-historyhandling
      text: serializedData; url: browsing-the-web.html#uhus-serializeddata
    for: Window
      text: navigable; url: nav-history-apis.html#window-navigable
</pre>

<style>
.selected-text-file-an-issue {
  position: fixed;
  bottom: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.8);
  font-size: smaller;
  padding: 4px 10px;
  z-index: 4;
}

dfn var {
  font-style: italic;
}

table {
  margin: 1em 0;
}

/* WHATWG-style <hr>s, instead of WICG-style. Specific selector is necessary to override WICG styles. */
:not(.head) > :not(.head) + hr {
  display: block;
  background: none;
  border: none;
  padding: 0;
  margin: 3em 0;
  height: auto;
}
:not(.head) > :not(.head) + hr::before {
  content: none;
}

/* domintro from https://resources.whatwg.org/standard.css */
.domintro {
  position: relative;
  color: green;
  background: #DDFFDD;
  margin: 2.5em 0 2em 0;
  padding: 1.5em 1em 0.5em 2em;
}

.domintro dt, .domintro dt * {
  color: black;
  font-size: inherit;
}
.domintro dd {
  margin: 0.5em 0 1em 2em; padding: 0;
}
.domintro dd p {
  margin: 0.5em 0;
}
.domintro::before {
  content: 'For web developers (non-normative)';
  background: green;
  color: white;
  padding: 0.15em 0.25em;
  font-style: normal;
  position: absolute;
  top: -0.8em;
  left: -0.8em;
}

/* .XXX from https://resources.whatwg.org/standard.css */
.XXX {
  color: #D50606;
  background: white;
  border: solid #D50606;
}
</style>

<script src="https://resources.whatwg.org/file-issue.js" async></script>

<h2 id="global">The {{Navigation}} class</h2>

<xmp class="idl">
partial interface Window {
  [Replaceable] readonly attribute Navigation navigation;
};
</xmp>

Each {{Window}} object has an associated <dfn for="Window">navigation API</dfn>, which is a new {{Navigation}} instance created alongside the {{Window}}.

The <dfn attribute for="Window">navigation</dfn> getter steps are to return [=this=]'s [=Window/navigation API=].

<xmp class="idl">
[Exposed=Window]
interface Navigation : EventTarget {
  sequence<NavigationHistoryEntry> entries();
  readonly attribute NavigationHistoryEntry? currentEntry;
  undefined updateCurrentEntry(NavigationUpdateCurrentEntryOptions options);
  readonly attribute NavigationTransition? transition;

  readonly attribute boolean canGoBack;
  readonly attribute boolean canGoForward;

  NavigationResult navigate(USVString url, optional NavigationNavigateOptions options = {});
  NavigationResult reload(optional NavigationReloadOptions options = {});

  NavigationResult traverseTo(DOMString key, optional NavigationOptions options = {});
  NavigationResult back(optional NavigationOptions options = {});
  NavigationResult forward(optional NavigationOptions options = {});

  attribute EventHandler onnavigate;
  attribute EventHandler onnavigatesuccess;
  attribute EventHandler onnavigateerror;
  attribute EventHandler oncurrententrychange;
};

dictionary NavigationUpdateCurrentEntryOptions {
  required any state;
};

dictionary NavigationOptions {
  any info;
};

dictionary NavigationNavigateOptions : NavigationOptions {
  any state;
  NavigationHistoryBehavior history = "auto";
};

dictionary NavigationReloadOptions : NavigationOptions {
  any state;
};

dictionary NavigationResult {
  Promise<NavigationHistoryEntry> committed;
  Promise<NavigationHistoryEntry> finished;
};

enum NavigationHistoryBehavior {
  "auto",
  "push",
  "replace"
};
</xmp>

Each {{Navigation}} object has an associated <dfn for="Navigation">entry list</dfn>, a [=list=] of {{NavigationHistoryEntry}} objects, initially empty.

Each {{Navigation}} object has an associated <dfn for="Navigation">current entry index</dfn>, an integer, initially &minus;1.

<div algorithm>
  A {{Navigation}} |navigation| <dfn for="Navigation">has entries and events disabled</dfn> if the following steps return true:

  1. If |navigation|'s [=relevant global object=]'s [=Window/browsing context=] is null, then return true.

  1. Let |document| be |navigation|'s [=relevant global object=]'s [=associated Document=].

  1. If |document|'s <a spec="HTML">is initial about:blank</a> is true, then return true.

  1. If |document|'s [=Document/origin=] is [=opaque origin|opaque=], then return true.

  1. Return false.
</div>

<div algorithm>
  To <dfn for="Navigation">update the entries for a same-document navigation</dfn> given a {{Navigation}} instance |navigation|, a [=session history entry=] |destinationSHE|, and a {{NavigationType}} |navigationType|:

  1. If |navigation| [=Navigation/has entries and events disabled=], then:

    1. [=Assert=]: |navigation|'s [=Navigation/entry list=] [=list/is empty=].

    1. Return.

  1. Let |oldCurrentNHE| be the [=Navigation/current entry=] of |navigation|.

  1. Let |disposedNHEs| be a new empty [=list=].

  1. If |navigationType| is "{{NavigationType/traverse}}":

    1. Set |navigation|'s [=Navigation/current entry index=] to the index of the {{NavigationHistoryEntry}} within |navigation|'s [=Navigation/entry list=] whose [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=] equals |destinationSHE|'s [=session history entry/navigation API key=].

    1. [=Assert=]: such a {{NavigationHistoryEntry}} must exist, because this algorithm is only called for same-document traversals. (Cross-document traversals will instead call either [=Navigation/update the entries for reactivation=] or [=Navigation/initialize the entries for a new Navigation=].)

  1. Otherwise, if |navigationType| is "{{NavigationType/push}}":

    1. Set |navigation|'s [=Navigation/current entry index=] to |navigation|'s [=Navigation/current entry index=] + 1.

    1. Let |i| be |navigation|'s [=Navigation/current entry index=].

    1. [=iteration/While=] |i| < |navigation|'s [=Navigation/entry list=]'s [=list/size=]:

      1. [=list/Append=] |navigation|'s [=Navigation/entry list=][|i|] to |disposedNHEs|.

      1. Set |i| to |i| + 1.

    1. [=list/Remove=] all [=list/items=] in |disposedNHEs| from |navigation|'s [=Navigation/entry list=].

  1. Otherwise, if |navigationType| is "{{NavigationType/replace}}":

    1. [=list/Append=] |oldCurrentNHE| to |disposedNHEs|.

  1. If |navigationType| is "{{NavigationType/push}}" or "{{NavigationType/replace}}":

    1. Let |newNHE| be a [=new=] {{NavigationHistoryEntry}} created in the [=relevant realm=] of |navigation|.

    1. Set |newNHE|'s [=NavigationHistoryEntry/session history entry=] to |destinationSHE|.

    1. Set |navigation|'s [=Navigation/entry list=][|navigation|'s [=Navigation/current entry index=]] to |newNHE|.

  1. [=Assert=]: by this point, the [=Navigation/current entry=] of |navigation| is different from |oldCurrentNHE|.

  1. If |navigation|'s [=Navigation/ongoing navigation=] is non-null, then [=navigation API method navigation/notify about the committed-to entry=] given |navigation|'s [=Navigation/ongoing navigation=] and the [=Navigation/current entry=] of |navigation|.

     <p class="note">It is important to do this before firing the {{NavigationHistoryEntry/dispose}} or {{Navigation/currententrychange}} events, since event handlers could start another navigation, or otherwise change the value of |navigation|'s [=Navigation/ongoing navigation=].

  1. [=Prepare to run script=] given |navigation|'s [=relevant settings object=].

      <p class="note">See <a href="#note-suppress-microtasks-during-navigation-events">a similar note elsewhere for other navigation API events</a> to understand why we do this.

  1. [=Fire an event=] named {{Navigation/currententrychange}} at |navigation| using {{NavigationCurrentEntryChangeEvent}}, with its {{NavigationCurrentEntryChangeEvent/navigationType}} attribute initialized to |navigationType| and its {{NavigationCurrentEntryChangeEvent/from}} initialized to |oldCurrentNHE|.

  1. [=list/For each=] |disposedNHE| of |disposedNHEs|:

    1. [=Fire an event=] named {{NavigationHistoryEntry/dispose}} at |disposedNHE|.

  1. [=Clean up after running script=] given |navigation|'s [=relevant settings object=].
</div>

<div algorithm>
  To <dfn for="Navigation">update the entries for reactivation</dfn> given a {{Navigation}} instance |navigation|, a [=list=] of [=session history entries=] |newSHEs|, and a [=session history entry=] |reactivatedSHE|:

  1. Let |newNHEs| be an empty list.

  1. Let |oldNHEs| be a [=list/clone=] of |navigation|'s [=Navigation/entry list=].

  1. [=list/For each=] |newSHE| of |newSHEs|:

    1. Let |newNHE| be null.

    1. If |oldNHEs| [=list/contains=] a {{NavigationHistoryEntry}} |matchingOldNHE| whose [=NavigationHistoryEntry/session history entry=] is |newSHE|, then:

      1. Set |newNHE| to |matchingOldNHE|.

      1. [=list/Remove=] |matchingOldNHE| from |oldNHEs|.

    1. Otherwise:

      1. Set |newNHE| to a [=new=] {{NavigationHistoryEntry}} created in the [=relevant realm=] of |navigation|.

      1. Set |newNHE|'s [=NavigationHistoryEntry/session history entry=] to |newSHE|.

    1. [=list/Append=] |newNHE| to |newNHEs|.

  1. [=list/For each=] |disposedNHE| of |oldNHEs|:

    1. Set |disposedNHE|'s [=NavigationHistoryEntry/index=] to &minus;1.

  1. Set |navigation|'s [=Navigation/entry list=] to |newNHEs|.

  1. Set |navigation|'s [=Navigation/current entry index=] to the result of [=getting the navigation API history index=] of |reactivatedSHE| within |navigation|.

  1. [=Queue a global task=] on the [=navigation and traversal task source=] given |navigation|'s [=relevant global object=] to run the following steps:

    1. [=list/For each=] |disposedNHE| of |oldNHEs|:

      1. [=Fire an event=] named {{NavigationHistoryEntry/dispose}} at |disposedNHE|.

    <p class="note">We delay these events by a task to ensure that {{NavigationHistoryEntry/dispose}} events will fire after the {{Window/pageshow}} event. (However, the rest of this algorithm runs before the {{Window/pageshow}} event fires, to ensure that {{Navigation/entries()|navigation.entries()}} and {{Navigation/currentEntry|navigation.currentEntry}} will have correctly-updated values during any {{Window/pageshow}} event handlers.) This is motivated by a desire to have {{Window/pageshow}} be the first event a page receives upon reactivation.
</div>

<div algorithm>
  To <dfn for="Navigation">initialize the entries for a new {{Navigation}}</dfn> given a {{Navigation}} instance |navigation|, a [=list=] of [=session history entries=] |newSHEs|, and a [=session history entry=] |initialSHE|:

  1. [=Assert=]: |navigation|'s [=Navigation/entry list=] [=list/is empty=].

  1. [=Assert=]: |navigation|'s [=Navigation/current entry index=] is &minus;1.

  1. If |navigation| [=Navigation/has entries and events disabled=], then return.

  1. [=list/For each=] |newSHE| of |newSHEs|:

      1. Let |newNHE| be a [=new=] {{NavigationHistoryEntry}} created in the [=relevant realm=] of |navigation|.

      1. Set |newNHE|'s [=NavigationHistoryEntry/session history entry=] to |newSHE|.

      1. [=list/Append=] |newNHE| to |navigation|'s [=Navigation/entry list=].

  1. Set |navigation|'s [=Navigation/current entry index=] to the result of [=getting the navigation API history index=] of |initialSHE| within |navigation|.
</div>

<div algorithm>
  To <dfn>get the navigation API history index</dfn> of a [=session history entry=] |she| within a {{Navigation}} |navigation|:

  1. Let |index| be 0.

  1. [=list/For each=] |ahe| of |navigation|'s [=Navigation/entry list=]:

    1. If |ahe|'s [=NavigationHistoryEntry/session history entry=] is equal to |she|, then return |index|.

    1. Increment |index| by 1.

  1. [=Assert=]: this step is never reached.
</div>

<h3 id="entries-api">Introspecting the navigation API history entry list</h3>

<dl class="domintro non-normative">
  <dt><code><var ignore>entries</var> = {{Window/navigation}}.{{Navigation/entries()|entries}}()</code>
  <dd>
    <p>Returns an array of {{NavigationHistoryEntry}} instances representing the current navigation history entry list, i.e. all session history entries for this {{Window}} that are [=same origin=] and contiguous to the current session history entry.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/canGoBack}}</code>
  <dd>
    <p>Returns true if the current {{NavigationHistoryEntry}} is not the first one in the navigation history entry list.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/canGoForward}}</code>
  <dd>
    <p>Returns true if the current {{NavigationHistoryEntry}} is not the last one in the navigation history entry list.
  </dd>
</dl>

<div algorithm>
  The <dfn method for="Navigation">entries()</dfn> method steps are:

  1. If [=this=] [=Navigation/has entries and events disabled=], then return the empty list.

  1. Return [=this=]'s [=Navigation/entries list=].
</div>

<div algorithm>
  The <dfn attribute for="Navigation">canGoBack</dfn> getter steps are:

  1. If [=this=] [=Navigation/has entries and events disabled=], then return false.

  1. [=Assert=]: [=this=]'s [=Navigation/current entry index=] is not &minus;1.

  1. If [=this=]'s [=Navigation/current entry index=] is 0, then return false.

  1. Return true.
</div>

<div algorithm>
  The <dfn attribute for="Navigation">canGoForward</dfn> getter steps are:

  1. If [=this=] [=Navigation/has entries and events disabled=], then return false.

  1. [=Assert=]: [=this=]'s [=Navigation/current entry index=] is not &minus;1.

  1. If [=this=]'s [=Navigation/current entry index=] is equal to [=this=]'s [=Navigation/entry list=]'s [=list/size=] &minus; 1, then return false.

  1. Return true.
</div>

<h3 id="current-entry">The current entry</h3>

<xmp class="idl">
[Exposed=Window]
interface NavigationCurrentEntryChangeEvent : Event {
  constructor(DOMString type, NavigationCurrentEntryChangeEventInit eventInit);

  readonly attribute NavigationType? navigationType;
  readonly attribute NavigationHistoryEntry from;
};

dictionary NavigationCurrentEntryChangeEventInit : EventInit {
  NavigationType? navigationType = null;
  required NavigationHistoryEntry destination;
};
</xmp>

<dl class="domintro non-normative">
  <dt><code>{{Window/navigation}}.{{Navigation/currentEntry}}</code>
  <dd>
    <p>The current {{NavigationHistoryEntry}}.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/updateCurrentEntry()|updateCurrentEntry}}({ {{NavigationUpdateCurrentEntryOptions/state}} })</code>
  <dd>
    <p>Update the [=session history entry/navigation API state=] of the current {{NavigationHistoryEntry}}, without performing a navigation like {{Navigation/reload()|navigation.reload()}} would do.

    <p>This method is best used to capture updates to the page that have already happened, and need to be reflected into the navigation API state. For cases where the state update is meant to drive a page update, instead use {{Navigation/navigate()|navigation.navigate()}} or {{Navigation/reload()|navigation.reload()}}.
  </dd>
</dl>

<div algorithm>
  The <dfn for="Navigation">current entry</dfn> for a {{Navigation}} |navigation| is the result running of the following algorithm:

  1. If |navigation| [=Navigation/has entries and events disabled=], then return null.

  1. [=Assert=]: |navigation|'s [=Navigation/current entry index=] is not &minus;1.

  1. Return |navigation|'s [=Navigation/entry list=][|navigation|'s [=Navigation/current entry index=]].
</div>

<p algorithm>
  The <dfn attribute for="Navigation">currentEntry</dfn> getter steps are to return the [=Navigation/current entry=] for [=this=].
</p>

<div algorithm>
  The <dfn method for="Navigation">updateCurrentEntry(|options|)</dfn> method steps are:

  1. Let |current| be the [=Navigation/current entry=] for [=this=].

  1. If |current| is null, then throw an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |serializedState| be [$StructuredSerializeForStorage$](|options|["{{NavigationUpdateCurrentEntryOptions/state}}"]), rethrowing any exceptions.

  1. Set |current|'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API state=] to |serializedState|.

  1. [=Fire an event=] named {{Navigation/currententrychange}} at [=this=] using {{NavigationCurrentEntryChangeEvent}}, with its {{NavigationCurrentEntryChangeEvent/navigationType}} attribute initialized to null and its {{NavigationCurrentEntryChangeEvent/from}} initialized to |current|.
</div>

<h3 id="ongoing-state">Ongoing navigation tracking</h3>

<xmp class="idl">
[Exposed=Window]
interface NavigationTransition {
  readonly attribute NavigationType navigationType;
  readonly attribute NavigationHistoryEntry from;
  readonly attribute Promise<undefined> finished;
};
</xmp>

<dl class="domintro">
  <dt><code>{{Window/navigation}}.{{Navigation/transition}}</code>
  <dd>
    <p>A {{NavigationTransition}} object representing any ongoing navigation that hasn't yet reached the {{Navigation/navigatesuccess}} or {{Navigation/navigateerror}} stage, if one exists, or null if there is no such transition ongoing.

    <p>Since {{Navigation/currentEntry|navigation.currentEntry}} (and other properties like {{Location/href|location.href}}) are updated immediately upon navigation, this {{Navigation/transition|navigation.transition}} property is useful for determining when such navigations are not yet fully settled, according to any handlers passed to {{NavigateEvent/intercept()|event.intercept()}}.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/navigationType}}</code></dt>
  <dd>
    <p>One of "{{NavigationType/reload}}", "{{NavigationType/push}}", "{{NavigationType/replace}}", or "{{NavigationType/traverse}}", indicating what type of navigation this transition is for.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/from}}</code></dt>
  <dd>
    <p>The {{NavigationHistoryEntry}} from which the transition is coming. This can be useful to compare against {{Navigation/currentEntry|navigation.currentEntry}}.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/finished}}</code></dt>
  <dd>
    <p>A promise which fulfills at the same time the {{Navigation/navigatesuccess}} event fires, or rejects at the same time the {{Navigation/navigateerror}} fires.
  </dd>

<!--
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/rollback(options)|rollback}}()</code></dt>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/rollback(options)|rollback}}({ {{NavigationOptions/info}} })</code></dt>
  <dd>
    <p>Aborts the ongoing navigation, and immediately performs another navigation which is the logical opposite of the one represented by this transition:

    * If {{NavigationTransition/navigationType}} is "{{NavigationType/reload}}", it will perform a replace navigation that resets the navigation API state to that found in the {{NavigationHistoryEntry}} stored in {{NavigationTransition/from}}.

    * If {{NavigationTransition/navigationType}} is "{{NavigationType/push}}", it will traverse to the {{NavigationHistoryEntry}} stored in {{NavigationTransition/from}}, and then delete the previously-current {{NavigationHistoryEntry}} from the navigation history entry list, so that it cannot be reached with {{Navigation/forward()|navigation.forward()}} or the forward button.

    * If {{NavigationTransition/navigationType}} is "{{NavigationType/replace}}", it will perform another replace navigation that resets the URL and navigation API state to those found in the {{NavigationHistoryEntry}} stored in {{NavigationTransition/from}}.

    * If {{NavigationTransition/navigationType}} is "{{NavigationType/traverse}}", it will traverse to the {{NavigationHistoryEntry}} stored in {{NavigationTransition/from}}. (This could involve going either forward or backward in the navigation history entry list.)

    <p>Aborting the ongoing navigation will cause {{Navigation/navigateerror}} to fire, any {{NavigateEvent/signal|navigateEvent.signal}} instances to fire {{AbortSignal/abort}}, and any relevant promises to reject. This includes {{NavigationTransition/finished|navigation.transition.finished}}.

    <p>Then, the rollback navigation described above starts. This will fire a {{Navigation/navigate}} event, and reset {{Navigation/transition|navigation.transition}} to a new {{NavigationTransition}} instance. The {{NavigationOptions/info}} option, if provided, will populate the {{NavigateEvent/info}} property of the fired event.

    <p>This method can only be called while the transition is still ongoing, i.e. while {{Navigation/transition|navigation.transition}} equals this {{NavigationTransition}} object. Calling it afterward will cause both returned promises rejected with an "{{InvalidStateError}}" {{DOMException}}.
  </dd>
-->
</dl>

A {{Navigation}} has a <dfn for="Navigation">transition</dfn>, which is a {{NavigationTransition}} or null.

The <dfn attribute for="Navigation">transition</dfn> getter steps are to return [=this=]'s [=Navigation/transition=].

<hr>

A {{NavigationTransition}} has an associated <dfn for="NavigationTransition">navigation type</dfn>, which is a {{NavigationType}}.

A {{NavigationTransition}} has an associated <dfn for="NavigationTransition">from entry</dfn>, which is a {{NavigationHistoryEntry}}.

A {{NavigationTransition}} has an associated <dfn for="NavigationTransition">finished promise</dfn>, which is an {{Promise}}.

The <dfn attribute for="NavigationTransition">navigationType</dfn> getter steps are to return [=this=]'s [=NavigationTransition/navigation type=].

The <dfn attribute for="NavigationTransition">from</dfn> getter steps are to return [=this=]'s [=NavigationTransition/from entry=].

The <dfn attribute for="NavigationTransition">finished</dfn> getter steps are to return [=this=]'s [=NavigationTransition/finished promise=].

<hr>

During any given navigation, the {{Navigation}} object needs to keep track of the following:

<table class="data">
  <caption>For all navigations
  <thead>
    <tr>
      <th>State
      <th>Duration
      <th>Explanation
  <tbody>
    <tr>
      <td>The {{NavigateEvent}}
      <td>For the duration of event firing
      <td>So that if the navigation is canceled while the event is firing, we can [=Event/canceled flag|cancel=] the event.
    <tr>
      <td>The event's {{NavigateEvent/signal}}
      <td>Until all promises returned from handlers passed to {{NavigateEvent/intercept()}} have settled
      <td>So that if the navigation is canceled, we can [=AbortSignal/signal abort=].
    <tr>
      <td>Whether a new element was <a spec="HTML" lt="focusing steps">focused</a>
      <td>Until all promises returned from handlers passed to {{NavigateEvent/intercept()}} have settled
      <td>So that if one was, focus is not [=potentially reset the focus|reset=]
    <tr>
      <td>The {{NavigationHistoryEntry}} being navigated to
      <td>From when it is determined, until all promises returned from handlers passed to {{NavigateEvent/intercept()}} have settled
      <td>So that we know what to [=resolve=] any {{NavigationResult/committed}} and {{NavigationResult/finished}} promises with.
    <tr>
      <td>Any {{NavigationResult/finished}} {{Promise}} that was returned
      <td>Until all promises returned from handlers passed to {{NavigateEvent/intercept()}} have settled
      <td>So that we can [=resolve=] or [=reject=] it appropriately.
</table>

<table class="data">
  <caption>For non-"{{NavigationType/traverse}}" navigations
  <thead>
    <tr>
      <th>State
      <th>Duration
      <th>Explanation
  <tbody>
    <tr>
      <td>Any {{NavigationNavigateOptions/state}}
      <td>For the duration of event firing
      <td>So that we can update the current entry's state after the event successfully finishes firing without being canceled.
</table>

<table class="data">
  <caption>For "{{NavigationType/traverse}}" navigations
  <thead>
    <tr>
      <th>State
      <th>Duration
      <th>Explanation
  <tbody>
    <tr>
      <td>Any {{NavigationOptions/info}}
      <td>Until the task is queued to fire the {{Navigation/navigate}} event
      <td>So that we can use it to fire the {{Navigation/navigate}} event after the the trip through the [=traversable navigable/session history traversal queue=].
    <tr>
      <td>Any {{NavigationResult/committed}} {{Promise}} that was returned
      <td>Until the session history is updated (inside that same task)
      <td>So that we can [=resolve=] or [=reject=] it appropriately.
    <tr>
      <td>Whether {{NavigateEvent/intercept()}} was called
      <td>Until the session history is updated (inside that same task)
      <td>So that we can suppress the normal scroll restoration logic in favor of the chosen {{NavigationInterceptOptions/scroll}} option value.
</table>

Furthermore, we need to account for the fact that there might be multiple traversals queued up, e.g. via

<xmp highlight="js">
const key1 = navigation.entries()[navigation.currentEntry.index - 1].key;
const key2 = navigation.entries()[navigation.currentEntry.index + 1].key;

navigation.traverseTo(key1); // intentionally no await
navigation.traverseTo(key2);
</xmp>

And, while non-traversal navigations cannot be queued in the same way since a new non-traversal navigation cancels an old one, we need to keep some state around so that we can properly cancel the old one. That is, given

<xmp highlight="js">
const p1 = navigation.navigate(url1).finished;
const p2 = navigation.navigate(url2).finished;
</xmp>

we need to ensure that when navigating to `url2`, we still have the {{Promise}} `p1` around so that we can reject it. We can't just get rid of any ongoing navigation promises the moment the second call to {{Navigation/navigate()}} happens.

We also need to ensure that, if we start a new navigation, navigations which have gotten as far as firing {{Navigation/navigate}} events, but not yet as far as firing {{Navigation/navigatesuccess}} or {{Navigation/navigateerror}}, get [=finalized with an aborted navigation error=].

We end up accomplishing all this using the following setup:

Each {{Navigation}} object has an associated <dfn for="Navigation">ongoing navigate event</dfn>, a {{NavigateEvent}} or null, initially null.

Each {{Navigation}} object has an associated <dfn for="Navigation">ongoing navigation signal</dfn>, which is an {{AbortSignal}} or null, initially null.

Each {{Navigation}} object has an associated <dfn for="Navigation">focus changed during ongoing navigation</dfn>, which is a boolean, initially false.

Each {{Navigation}} object has an associated <dfn for="Navigation">suppress normal scroll restoration during ongoing navigation</dfn>, which is a boolean, initially false.

Each {{Navigation}} object has an associated <dfn for="Navigation">ongoing navigation</dfn>, which is a [=navigation API method navigation=] or null, initially null.

Each {{Navigation}} object has an associated <dfn for="Navigation">upcoming non-traverse navigation</dfn>, which is a [=navigation API method navigation=] or null, initially null.

Each {{Navigation}} object has an associated <dfn for="Navigation">upcoming traverse navigations</dfn>, which is a [=map=] from strings to [=navigation API method navigations=], initially empty.

An <dfn>navigation API method navigation</dfn> is a [=struct=] with the following [=struct/items=]:

* An <dfn for="navigation API method navigation">navigation object</dfn>, a {{Navigation}}
* A <dfn for="navigation API method navigation">key</dfn>, a string or null
* An <dfn for="navigation API method navigation">info</dfn>, a JavaScript value
* A <dfn for="navigation API method navigation">serialized state</dfn>, a [=serialized state=] or null
* A <dfn for="navigation API method navigation">committed-to entry</dfn>, a {{NavigationHistoryEntry}} or null
* A <dfn for="navigation API method navigation">committed promise</dfn>, a {{Promise}}
* A <dfn for="navigation API method navigation">finished promise</dfn>, a {{Promise}}

<p class="note">We need to store the [=Navigation/ongoing navigation signal=], [=Navigation/focus changed during ongoing navigation=], and [=Navigation/suppress normal scroll restoration during ongoing navigation=] separately from the [=navigation API method navigation=] struct, since it needs to be tracked even for navigations that are not via the navigation API.

<div algorithm>
  To <dfn for="Navigation">set the upcoming non-traverse navigation</dfn> given a {{Navigation}} |navigation|, a JavaScript value |info|, and a [=serialized state=]-or-null |serializedState|:

  1. Let |committedPromise| and |finishedPromise| be [=a new promise|new promises=] created in |navigation|'s [=relevant realm=].

  1. [=Mark as handled=] |finishedPromise|.

     <div class="note" id="note-finished-promise-mark-as-handled">
      The web developer doesn't necessarily care about |finishedPromise| being rejected:

      * They might only care about |committedPromise|.

      * They could be doing multiple synchronous navigations within the same task, in which case all but the last will be aborted (causing their |finishedPromise| to reject). This could be an application bug, but also could just be an emergent feature of disparate parts of the application overriding each others' actions.

      * They might prefer to listen to other transition-failure signals instead of |finishedPromise|, e.g., the {{Navigation/navigateerror}} event, or the {{NavigationTransition/finished|navigation.transition.finished}} promise.

      As such, we mark it as handled to ensure that it never triggers {{Window/unhandledrejection}} events.
     </div>

  1. Let |ongoingNavigation| be a [=navigation API method navigation=] whose [=navigation API method navigation/navigation object=] is |navigation|, [=navigation API method navigation/key=] is null, [=navigation API method navigation/info=] is |info|, [=navigation API method navigation/serialized state=] is |serializedState|, [=navigation API method navigation/committed-to entry=] is null, [=navigation API method navigation/committed promise=] is |committedPromise|, and [=navigation API method navigation/finished promise=] is |finishedPromise|.

  1. [=Assert=]: |navigation|'s [=Navigation/upcoming non-traverse navigation=] is null.

  1. Set |navigation|'s [=Navigation/upcoming non-traverse navigation=] to |ongoingNavigation|.

  1. Return |ongoingNavigation|.
</div>

<div algorithm>
  To <dfn for="Navigation">set an upcoming traverse navigation</dfn> given a {{Navigation}} |navigation|, a string |key|, and a JavaScript value |info|:

  1. Let |committedPromise| and |finishedPromise| be [=a new promise|new promises=] created in |navigation|'s [=relevant realm=].

  1. [=Mark as handled=] |finishedPromise|.

     <p class="note">See <a href="#note-finished-promise-mark-as-handled">the previous discussion</a> as to why this is done.</p>

  1. Let |traversal| be a [=navigation API method navigation=] whose whose [=navigation API method navigation/navigation object=] is |navigation|, [=navigation API method navigation/key=] is |key|, [=navigation API method navigation/info=] is |info|, [=navigation API method navigation/serialized state=] is null, [=navigation API method navigation/committed-to entry=] is null, [=navigation API method navigation/committed promise=] is |committedPromise|, and [=navigation API method navigation/finished promise=] is |finishedPromise|.

  1. Set |navigation|'s [=Navigation/upcoming traverse navigations=][|key|]  to |traversal|.

  1. Return |traversal|.
</div>

<div algorithm>
  To <dfn for="Navigation">promote the upcoming navigation to ongoing</dfn> given a {{Navigation}} |navigation| and a string-or-null |destinationKey|:

  1. [=Assert=]: |navigation|'s [=Navigation/ongoing navigation=] is null.

  1. If |destinationKey| is not null, then:

    1. [=Assert=]: |navigation|'s [=Navigation/upcoming non-traverse navigation=] is null.

    1. If |navigation|'s [=Navigation/upcoming traverse navigations=][|destinationKey|] [=map/exists=], then:

      1. Set |navigation|'s [=Navigation/ongoing navigation=] to |navigation|'s [=Navigation/upcoming traverse navigations=][|destinationKey|].

      1. [=map/Remove=] |navigation|'s [=Navigation/upcoming traverse navigations=][|destinationKey|].

  1. Otherwise,

    1. Set |navigation|'s [=Navigation/ongoing navigation=] to |navigation|'s [=Navigation/upcoming non-traverse navigation=].

    1. Set |navigation|'s [=Navigation/upcoming non-traverse navigation=] to null.
</div>

<div algorithm>
  To <dfn for="navigation API method navigation">clean up</dfn> a [=navigation API method navigation=] |navigation|:

  1. Let |navigation| be |navigation|'s [=navigation API method navigation/navigation object=].

  1. If |navigation|'s [=Navigation/ongoing navigation=] is |navigation|, then set |navigation|'s [=Navigation/ongoing navigation=] to null.

  1. Otherwise,

    1. [=Assert=]: |navigation|'s [=navigation API method navigation/key=] is not null.

    1. [=Assert=]: |navigation|'s [=Navigation/upcoming traverse navigations=][|navigation|'s [=navigation API method navigation/key=]] [=map/exists=].

    1. [=map/Remove=] |navigation|'s [=Navigation/upcoming traverse navigations=][|navigation|'s [=navigation API method navigation/key=]].
</div>

<div algorithm>
  To <dfn for="navigation API method navigation">notify about the committed-to entry</dfn> given a [=navigation API method navigation=] |navigation| and a {{NavigationHistoryEntry}} |entry|:

  1. Set |navigation|'s [=navigation API method navigation/committed-to entry=] to |entry|.

  1. If |navigation|'s [=navigation API method navigation/serialized state=] is not null, then set |entry|'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API state=] to |navigation|'s [=navigation API method navigation/serialized state=].

     <p class="note">If it's null, then we're traversing to |entry| via {{Navigation/traverseTo()}}, which does not allow changing the state.

     <p class="note">After this point, |navigation|'s [=navigation API method navigation/serialized state=] is no longer needed. Implementations might want to clear it out to avoid keeping it alive for the lifetime of the [=navigation API method navigation=].

  1. [=Resolve=] |navigation|'s [=navigation API method navigation/committed promise=] with |entry|.

     <p class="note">After this point, |navigation|'s [=navigation API method navigation/committed promise=] is only needed in cases where it has not yet been returned to author code. Implementations might want to clear it out to avoid keeping it alive for the lifetime of the [=navigation API method navigation=].
</div>

<div algorithm>
  To <dfn for="navigation API method navigation">resolve the finished promise</dfn> for a [=navigation API method navigation=] |navigation|:

  1. If |navigation|'s [=navigation API method navigation/finished promise=] is null, then return.

  1. [=Resolve=] |navigation|'s [=navigation API method navigation/finished promise=] with its [=navigation API method navigation/committed-to entry=].

  1. [=navigation API method navigation/Clean up=] |navigation|.
</div>

<div algorithm>
  To <dfn for="navigation API method navigation">reject the finished promise</dfn> for a [=navigation API method navigation=] |navigation| with a JavaScript value |exception|:

  1. If |navigation|'s [=navigation API method navigation/finished promise=] is null, then return.

  1. If |navigation|'s [=navigation API method navigation/committed promise=] is not null, then [=reject=] |navigation|'s [=navigation API method navigation/committed promise=] with |exception|.

  1. [=Reject=] |navigation|'s [=navigation API method navigation/finished promise=] with |exception|.

  1. [=navigation API method navigation/Clean up=] |navigation|.
</div>

<h3 id="global-navigate">Navigating</h3>

<dl class="domintro non-normative">
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/navigate(url, options)|navigate}}(<var ignore>url</var>)</code>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/navigate(url, options)|navigate}}(<var ignore>url</var>, <var ignore>options</var>)</code>
  <dd>
    <p>Navigates the current page to the given <var ignore>url</var>. <var ignore>options</var> can contain the following values:

    * {{NavigationNavigateOptions/history}} can be set to "{{NavigationHistoryBehavior/replace}}" to replace the current session history entry, instead of pushing a new one.
    * {{NavigationOptions/info}} can be set to any value; it will populate the {{NavigateEvent/info}} property of the corresponding {{Navigation/navigate}} event.
    * {{NavigationNavigateOptions/state}} can be set to any <a spec="HTML" lt="serializable object">serializable</a> value; it will populate the state retrieved by {{NavigationHistoryEntry/getState()|navigation.currentEntry.getState()}} once the navigation completes, for same-document navigations. (It will be ignored for navigations that end up cross-document.)

    <p>By default this will perform a full navigation (i.e., a cross-document navigation, unless the given URL differs only in a fragment from the current one). The {{Navigation/navigate}} event's {{NavigateEvent/intercept()}} method can be used to convert it into a same-document navigation.

    <p>The returned promises will behave as follows:

    * For navigations that get aborted, both promises will reject with an "{{AbortError}}" {{DOMException}}.
    * For same-document navigations created by using the {{Navigation/navigate}} event's {{NavigateEvent/intercept()}} method, {{NavigationResult/committed}} will fulfill immediately, and {{NavigationResult/finished}} will fulfill or reject according to any promises returned by handlers passed to {{NavigateEvent/intercept()}}.
    * For other same-document navigations (e.g., non-intercepted [=navigate to a fragment|fragment navigations=], both promises will fulfill immediately.
    * For cross-document navigations, or navigations that result in 204/205 [=response/statuses=] or `Content-Disposition: attachment` header fields from the server (and thus do not actually navigate), both promises will never settle.

    <p>In all cases, when the returned promises fulfill, it will be with the {{NavigationHistoryEntry}} that was navigated to.
  </dd>

  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/reload(options)|reload}}(<var ignore>options</var>)</code>
  <dd>
    <p>Reloads the current page. The {{NavigationOptions/info}} and {{NavigationReloadOptions/state}} options behave as described above.

    <p>The default behavior of performing a from-network-or-cache reload of the current page can be overriden by using the {{Navigation/navigate}} event's {{NavigateEvent/intercept()}} method. Doing so will mean this call only updates state or passes along the appropriate {{NavigationOptions/info}}, plus performing whatever actions the {{Navigation/navigate}} event handler sees fit to carry out.

    <p>The returned promises will behave as follows:

    * If the reload is aborted, both promises will reject with an "{{AbortError}}" {{DOMException}}.
    * If the reload is intercepted by using the {{Navigation/navigate}} event's {{NavigateEvent/intercept()}} method, {{NavigationResult/committed}} will fulfill immediately, and {{NavigationResult/finished}} will fulfill or reject according to the promises passed to {{NavigateEvent/intercept()}}.
    * Otherwise, both promises will never settle.
  </dd>
</dl>

<!-- The following algorithms have several steps that would benefit from https://github.com/heycam/webidl/issues/983. -->

<div algorithm>
  The <dfn method for="Navigation">navigate(|url|, |options|)</dfn> method steps are:

  1. Let |document| be [=this=]'s [=relevant global object=]'s [=associated document=].

  1. Let |navigable| be |navigation|'s [=relevant global object=]'s [=Window/navigable=].

  1. [=Assert=]: |navigable| is not null.

  1. <a spec="HTML" lt="parse a URL">Parse</a> |url| relative to [=this=]'s [=relevant settings object=]. If that returns failure, then return [=an early error result=] for a "{{SyntaxError}}" {{DOMException}}. Otherwise, let |urlRecord| be the <a spec="HTML">resulting URL record</a>.

  1. If |options|["{{NavigationNavigateOptions/history}}"] is "{{NavigationHistoryBehavior/push}}", and any of the following are true:

     * |document|'s <a spec="HTML">is initial about:blank</a> is true;
     * |document| is not <a spec="HTML">completely loaded</a>;
     * |url| equals |document|'s [=Document/URL=]; or
     * |url|'s [=url/scheme=] is "`javascript`"

     then return [=an early error result=] for a "{{NotSupportedError}}" {{DOMException}}.

     <div class="note">
      <p>These are the conditions under which a push navigation will be converted into a replace navigation by the <a spec="HTML">navigate</a> algorithm or by the below step. If the developer explicitly requested a push, we fail to let them know it won't happen.

      <p>In the future, we could consider loosening some of these conditions, e.g., allowing explicitly-requested push navigations to the current URL or before the document is completely loaded.
     </div>

  1. Let |state| be |options|["{{NavigationNavigateOptions/state}}"] if it exists; otherwise, undefined.

  1. Let |serializedState| be [$StructuredSerializeForStorage$](|state|). If this throws an exception, then return [=an early error result=] for that exception.

     <p class="note">It is important to perform this step early, since serialization can invoke web developer code, which in turn might change the state checked in later steps.</p>

  1. Let |info| be |options|["{{NavigationOptions/info}}"] if it exists; otherwise, undefined.

  1. Let |historyHandling| be "<a for="history handling behavior">`replace`</a>" if |options|["{{NavigationNavigateOptions/history}}"] is "{{NavigationHistoryBehavior/replace}}" or if |document| is not <a spec="HTML">completely loaded</a>; otherwise, "<a for="history handling behavior">`push`</a>".

  1. If |document| is not [=Document/fully active=], then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If |document|'s <a spec="HTML">unload counter</a> is greater than 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |ongoingNavigation| be the result of [=Navigation/setting the upcoming non-traverse navigation=] for |navigation| given |info|.

  1. <a spec="HTML">Navigate</a> |navigable| to |urlRecord| using |document|, with <i>[=navigate/historyHandling=]</i> set to |historyHandling| and <i>[=navigate/navigationAPIState=]</i> set to |serializedState|.

     <p class="note">Unlike {{Location/assign()|location.assign()}} and friends, which are exposed across [=same origin-domain|origin-domain=] boundaries, {{Navigation/navigate()|navigation.navigate()}} can only be accessed by code with direct synchronous access to the {{Window/navigation}} property. Thus, we avoid the complications around tracking the source document, and we don't need to deal with the <a spec="HTML">allowed by sandboxing to navigate</a> check and its accompanying <i>[=navigate/exceptionsEnabled=]</i> flag. We just treat all navigations as being initiated by the {{Navigation}} object itself.

  1. If |navigation|'s [=Navigation/upcoming non-traverse navigation=] is |ongoingNavigation|, then:

    <p class="note">This means the <a spec="HTML">navigate</a> algorithm bailed out before ever getting to the [=inner navigate event firing algorithm=] which would [=Navigation/promote the upcoming navigation to ongoing=].

    1. Set |navigation|'s [=Navigation/upcoming non-traverse navigation=] to null.

    1. Return [=an early error result=] for an "{{AbortError}}" {{DOMException}}.

  1. Return [ "{{NavigationResult/committed}}"  |ongoingNavigation|'s [=navigation API method navigation/committed promise=], "{{NavigationResult/finished}}"  |ongoingNavigation|'s [=navigation API method navigation/finished promise=] ].
</div>

<div algorithm>
  The <dfn method for="Navigation">reload(|options|)</dfn> method steps are:

  1. Let |document| be [=this=]'s [=relevant global object=]'s [=associated document=].

  1. Let |navigable| be |navigation|'s [=relevant global object=]'s [=Window/navigable=].

  1. [=Assert=]: |navigable| is not null.

  1. Let |serializedState| be null.

  1. If |options|["{{NavigationReloadOptions/state}}"] [=map/exists=], then set |serializedState| to [$StructuredSerializeForStorage$](|options|["{{NavigationReloadOptions/state}}"]). If this throws an exception, then return [=an early error result=] for that exception.

     <p class="note">It is important to perform this step early, since serialization can invoke web developer code, which in turn might change the state checked in later steps.</p>

  1. Otherwise,

    1. Let |current| be the [=Navigation/current entry=] of [=this=].

    1. If |current| is not null, then set |serializedState| to |current|'s [=session history entry/navigation API state=].

    1. Otherwise, set |serializedState| to [$StructuredSerializeForStorage$](undefined).

  1. Let |info| be |options|["{{NavigationOptions/info}}"] if it exists; otherwise, undefined.

  1. If |document| is not [=Document/fully active=], then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If |document|'s <a spec="HTML">unload counter</a> is greater than 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |ongoingNavigation| be the result of [=Navigation/setting the upcoming non-traverse navigation=] for |navigation| given |info|.

  1. <a spec="HTML">Reload</a> |navigable| with <i>[=reload/navigationAPIState=]</i> set to |serializedState|.

  1. If |navigation|'s [=Navigation/upcoming non-traverse navigation=] is |ongoingNavigation|, then:

    <p class="note">This means the <a spec="HTML">reload</a> algorithm bailed out before ever getting to the [=inner navigate event firing algorithm=] which would [=Navigation/promote the upcoming navigation to ongoing=].

    1. Set |navigation|'s [=Navigation/upcoming non-traverse navigation=] to null.

    1. Return [=an early error result=] for an "{{AbortError}}" {{DOMException}}.

  1. Return [ "{{NavigationResult/committed}}"  |ongoingNavigation|'s [=navigation API method navigation/committed promise=], "{{NavigationResult/finished}}"  |ongoingNavigation|'s [=navigation API method navigation/finished promise=] ].
</div>

<p algorithm>
  An <dfn>an early error result</dfn> for an exception |e| is a dictionary instance given by  [ "{{NavigationResult/committed}}"  [=a promise rejected with=] |e|, "{{NavigationResult/finished}}"  [=a promise rejected with=] |e| ].
</p>

<h3 id="global-traversing">Traversing</h3>

<dl class="domintro non-normative">
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/traverseTo(key)|traverseTo}}(<var ignore>key</var>)</code>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/traverseTo(key, options)|traverseTo}}(<var ignore>key</var>, { {{NavigationOptions/info}} })</code>
  <dd>
    <p>Traverses the session history to the closest [=session history entry=] that matches the {{NavigationHistoryEntry}} with the given key. {{NavigationOptions/info}} can be set to any value; it will populate the {{NavigateEvent/info}} property of the corresponding {{Navigation/navigate}} event.

    <p>If a traversal to that [=session history entry=] is already in progress, then this will return the promises for that original traversal, and {{NavigationOptions/info}} will be ignored.

    <p>The returned promises will behave as follows:

    * If there is no {{NavigationHistoryEntry}} in {{Navigation/entries|navigation.entries}} with the given key, both will reject with an "{{InvalidStateError}}" {{DOMException}}.
    * For same-document traversals intercepted by the {{Navigation/navigate}} event's {{NavigateEvent/intercept()}} method, {{NavigationResult/committed}} will fulfill as soon as the traversal is processed and {{Navigation/currentEntry|navigation.currentEntry}} is updated, and {{NavigationResult/finished}} will fulfill or reject according to any promises returned by handlers passed to {{NavigateEvent/intercept()}}.
    * For non-intercepted same-document traversals, both promises will fulfill as soon as the traversal is processed and {{Navigation/currentEntry|navigation.currentEntry}} is updated
    * For cross-document traversals, or traversals that result in 204/205 [=response/statuses=] or `Content-Disposition: attachment` header fields from the server (and thus do not actually traverse), both promises will never settle.
  </dd>

  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/back()|back}}()</code>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/back(options)|back}}({ {{NavigationOptions/info}} })</code>
  <dd>
    <p>Traverse the session history to the closest previous [=session history entry=] which results in this [=navigable=] navigating, i.e. results in {{Navigation/currentEntry|navigation.currentEntry}} updating. {{NavigationOptions/info}} can be set to any value; it will populate the {{NavigateEvent/info}} property of the corresponding {{Navigation/navigate}} event.

    <p>If a traversal to that [=session history entry=] is already in progress, then this will return the promises for that original traversal, and {{NavigationOptions/info}} will be ignored.

    <p>The returned promises behave equivalently to those returned by {{Navigation/traverseTo()}}.
  </dd>

  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/forward()|forward}}()</code>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/forward(options)|forward}}({ {{NavigationOptions/info}} })</code>
  <dd>
    <p>Traverse the session history to the closest forward [=session history entry=] which results in this frame navigating, i.e. results in {{Navigation/currentEntry|navigation.currentEntry}} updating. {{NavigationOptions/info}} can be set to any value; it will populate the {{NavigateEvent/info}} property of the corresponding {{Navigation/navigate}} event.

    <p>If a traversal to that [=session history entry=] is already in progress, then this will return the promises for that original traversal, and {{NavigationOptions/info}} will be ignored.

    <p>The returned promises behave equivalently to those returned by {{Navigation/traverseTo()}}.
  </dd>
</dl>

<div algorithm>
  The <dfn method for="Navigation">traverseTo(|key|, |options|)</dfn> method steps are:

  1. If [=this=]'s [=Navigation/current entry index=] is &minus;1, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If [=this=]'s [=Navigation/entry list=] does not contain any {{NavigationHistoryEntry}} whose [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=] equals |key|, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Return the result of [=performing a navigation API traversal=] given [=this=], |key|, and |options|.
</div>

<div algorithm>
  The <dfn method for="Navigation">back(|options|)</dfn> method steps are:

  1. If [=this=]'s [=Navigation/current entry index=] is &minus;1 or 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |key| be [=this=]'s [=Navigation/entry list=][[=this=]'s [=Navigation/current entry index=] &minus; 1]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=].

  1. Return the result of [=performing a navigation API traversal=] given [=this=], |key|, and |options|.
</div>

<div algorithm>
  The <dfn method for="Navigation">forward(|options|)</dfn> method steps are:

  1. If [=this=]'s [=Navigation/current entry index=] is &minus;1 or is equal to [=this=]'s [=Navigation/entry list=]'s [=list/size=] &minus; 1, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |key| be [=this=]'s [=Navigation/entry list=][[=this=]'s [=Navigation/current entry index=] + 1]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=].

  1. Return the result of [=performing a navigation API traversal=] given [=this=], |key|, and |options|.
</div>

<div algorithm>
  To <dfn>perform a navigation API traversal</dfn> given a {{Navigation}} object |navigation|, a string |key|, and a {{NavigationOptions}} |options|:

  1. Let |sourceDocument| be |navigation|'s [=relevant global object=]'s [=associated Document=].

  1. If |sourceDocument| is not [=Document/fully active=], then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If |sourceDocument|'s <a spec="HTML">unload counter</a> is greater than 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If |navigation|'s [=Navigation/current entry=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=] equals |key|, then return [ "{{NavigationResult/committed}}"  [=a promise resolved with=] |navigation|'s [=Navigation/current entry=], "{{NavigationResult/finished}}"  [=a promise resolved with=] |navigation|'s [=Navigation/current entry=] ]

  1. If |navigation|'s [=Navigation/upcoming traverse navigations=][|key|] [=map/exists=], then:

    1. Let |navigation| be |navigation|'s [=Navigation/upcoming traverse navigations=][|key|].

    1. Return [ "{{NavigationResult/committed}}"  |navigation|'s [=navigation API method navigation/committed promise=], "{{NavigationResult/finished}}"  |navigation|'s [=navigation API method navigation/finished promise=] ].

  1. Let |info| be |options|["{{NavigationOptions/info}}"] if it [=map/exists=], or undefined otherwise.

  1. Let |ongoingNavigation| be the result of [=Navigation/setting an upcoming traverse navigation=] for |navigation| given |key| and |info|.

  1. Let |navigable| be |sourceDocument|'s [=node navigable=].

  1. Let |traversable| be |navigable|'s [=navigable/traversable navigable=].

  1. Let |sourceSnapshotParams| be the result of [=snapshotting source snapshot params=] given |sourceDocument|.

  1. [=Append the following session history traversal steps=] to |traversable|:

    1. Let |navigableEntries| be the result of [=navigable/getting session history entries=] given |navigable|.

    1. Let |targetEntry| be the [=session history entry=] in |navigableEntries| whose [=session history entry/navigation API key=] equals |key|. If no such entry exists, then:

      1. [=Queue a global task=] on the [=navigation and traversal task source=] given |sourceDocument|'s [=relevant global object=] to [=navigation API method navigation/reject the finished promise=] for |ongoingNavigation| with an "{{InvalidStateError}}" {{DOMException}}.

      1. Abort these steps.

      <p class="note">This can occur if the |navigation| object's view of session history is outdated, which can happen for brief periods while all the relevant threads and processes are being synchronized in reaction to a history change (such as the user clearing their history).

    1. If |targetEntry| is |navigable|'s [=navigable/active session history entry=], then abort these steps.

       <p class="note">This can occur if a previously-queued-up traversal already took us to this session history entry. In that case that previous traversal will have dealt with |ongoingNavigation| already.

    1. [=Apply the history step=] given by |targetEntry|'s [=session history entry/step=] to |traversable|, with <i>[=apply the history step/checkForUserCancellation=]</i> set to true, <i>[=apply the history step/sourceSnapshotParams=]</i> set to |sourceSnapshotParams|, and <i>[=apply the history step/initiatorToCheck=]</i> set to |navigable|.

      - If this aborts due to user-canceled unloading or due to the {{Navigation/navigate}} event being canceled, then [=queue a global task=] on the [=navigation and traversal task source=] given |sourceDocument|'s [=relevant global object=] to [=finalize with an aborted navigation error=] given |navigation| and |ongoingNavigation|.

      - If this aborts due to the initiator allowed-to-navigate check, then [=queue a global task=] on the [=navigation and traversal task source=] given |sourceDocument|'s [=relevant global object=] to [=finalize with an aborted navigation error=] given |navigation|, |ongoingNavigation|, and a [=new=] "{{SecurityError}}" {{DOMException}} created in |navigation|'s [=relevant realm=].

      <p class="advisement">As part of merging this spec into HTML, we would modify [=apply the history step=] to have well-specified hooks for communicating these conditions back to its caller.</p>

  1. Return [ "{{NavigationResult/committed}}"  |ongoingNavigation|'s [=navigation API method navigation/committed promise=], "{{NavigationResult/finished}}"  |ongoingNavigation|'s [=navigation API method navigation/finished promise=] ].
</div>

<h3 id="global-events">Event handlers</h3>

The following are the [=event handlers=] (and their corresponding [=event handler event types=]) that must be supported, as [=event handler IDL attributes=], by objects implementing the {{Navigation}} interface:

<table>
  <thead>
    <th>[=Event handler=]
    <th>[=Event handler event type=]
  <tbody>
    <tr>
      <td><dfn attribute for="Navigation">onnavigate</dfn>
      <td><dfn event for="Navigation">navigate</dfn>
    <tr>
      <td><dfn attribute for="Navigation">onnavigatesuccess</dfn>
      <td><dfn event for="Navigation">navigatesuccess</dfn>
    <tr>
      <td><dfn attribute for="Navigation">onnavigateerror</dfn>
      <td><dfn event for="Navigation">navigateerror</dfn>
    <tr>
      <td><dfn attribute for="Navigation">oncurrententrychange</dfn>
      <td><dfn event for="Navigation">currententrychange</dfn>
</table>

<h2 id="navigate-event">The {{Navigation/navigate}} event</h2>

<h3 id="navigate-event-class">The {{NavigateEvent}} class</h3>

<xmp class="idl">
[Exposed=Window]
interface NavigateEvent : Event {
  constructor(DOMString type, NavigateEventInit eventInit);

  readonly attribute NavigationType navigationType;
  readonly attribute NavigationDestination destination;
  readonly attribute boolean canIntercept;
  readonly attribute boolean userInitiated;
  readonly attribute boolean hashChange;
  readonly attribute AbortSignal signal;
  readonly attribute FormData? formData;
  readonly attribute DOMString? downloadRequest;
  readonly attribute any info;

  undefined intercept(optional NavigationInterceptOptions options = {});
  undefined scroll();
};

dictionary NavigateEventInit : EventInit {
  NavigationType navigationType = "push";
  required NavigationDestination destination;
  boolean canIntercept = false;
  boolean userInitiated = false;
  boolean hashChange = false;
  required AbortSignal signal;
  FormData? formData = null;
  DOMString? downloadRequest = null;
  any info;
};

dictionary NavigationInterceptOptions {
  NavigationInterceptHandler handler;
  NavigationFocusReset focusReset;
  NavigationScrollBehavior scroll;
};

enum NavigationFocusReset {
  "after-transition",
  "manual"
};

enum NavigationScrollBehavior {
  "after-transition",
  "manual"
};

callback NavigationInterceptHandler = Promise<undefined> ();

enum NavigationType {
  "reload",
  "push",
  "replace",
  "traverse"
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>event</var>.{{NavigateEvent/navigationType}}</code>
  <dd>
    <p>One of "{{NavigationType/reload}}", "{{NavigationType/push}}", "{{NavigationType/replace}}", or "{{NavigationType/traverse}}", indicating what type of navigation this is.
  </dd>
  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}</code>
  <dd>
    <p>A {{NavigationDestination}} representing the destination of the navigation.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/canIntercept}}</code>
  <dd>
    <p>True if {{NavigateEvent/intercept()}} can be called to intercept this navigation and convert it into a single-page navigation; false otherwise.

    <p>Generally speaking, this will be true whenever the current {{Document}} <a spec="HTML">can have its URL rewritten</a> to the destination URL, except for cross-document back/forward navigations, where it will always be false.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/userInitiated}}</code>
  <dd>
    <p>True if this navigation was due to a user clicking on an <{a}> element, submitting a <{form}> element, or using the browser UI to navigate; false otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/hashChange}}</code>
  <dd>
    <p>True if this navigation is a [=navigate to a fragment|fragment navigation=]; false otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/signal}}</code>
  <dd>
    <p>An {{AbortSignal}} which will become aborted if the navigation gets canceled, e.g. by the user pressing their browser's "Stop" button, or another higher-priority navigation interrupting this one.

    <p>The expected pattern is for developers to pass this along to any async operations, such as {{WindowOrWorkerGlobalScope/fetch()}}, which they perform as part of handling this navigation.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/formData}}</code>
  <dd>
    <p>The {{FormData}} representing the submitted form entries for this navigation, if this navigation is a "{{NavigationType/push}}" or "{{NavigationType/replace}}" navigation representing a POST <a spec="HTML" lt="submit">form submission</a>; null otherwise.

    <p>(Notably, this will be null even for "{{NavigationType/reload}}" and "{{NavigationType/traverse}}" navigations that are revisiting a session history entry that was originally created from a form submission.)
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/downloadRequest}}</code>
  <dd>
    <p>Represents whether or not this navigation was requested to be a download, by using an <{a}> or <{area}> element's <{a/download}> attribute:

    * If a download was not requested, then this property is null.
    * If a download was requested, returns the filename that was supplied, via `<a download="filename" href="...">`. (This could be the empty string, as in the case of `<a download href="...">`.)

    <p>Note that a download being requested does not always mean that a download will happen: for example, the download might be blocked by browser security policies, or end up being treated as a push navigation for <a href="https://github.com/whatwg/html/issues/7718" class="XXX">unspecified reasons</a>.

    <p>Similarly, a navigation might end up being a download even if it was not requested to be one, due to the destination server responding with a `Content-Disposition: attachment` header.

    <p>Finally, note that the {{Navigation/navigate}} event will not fire at all for downloads initiated using browser UI affordances, e.g., those created by right-clicking and choosing to save the target of the link.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/info}}</code>
  <dd>
    <p>An arbitrary JavaScript value passed via {{Window/navigation}} APIs that initiated this navigation, or null if the navigation was initiated by the user or via a non-{{Window/navigation}} API.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/intercept()|intercept}}({ {{NavigationInterceptOptions/handler}}, {{NavigationInterceptOptions/focusReset}}, {{NavigationInterceptOptions/scroll}} })</code>
  <dd>
    <p>Intercepts this navigation, preventing its normally handling and instead converting it into a same-document navigation to the destination URL.

    <p>The {{NavigationInterceptOptions/handler}} option can be a function that returns a promise. The handler function will run after the {{Navigation/navigate}} event has finished firing, and the {{Navigation/currentEntry|navigation.currentEntry}} property has been synchronously updated. This promise is used to signal the duration, and success or failure, of the navigation. After it settles, the browser signals to the user (e.g. via a loading spinner UI, or assistive technology) that the navigation is finished. Additionally, it fires {{Navigation/navigatesuccess}} or {{Navigation/navigateerror}} events as appropriate, which other parts of the web application can respond to.

    <p>By default, using this method will cause focus to reset when any handlers' returned promises settle. Focus will be reset to the first element with the <{html-global/autofocus}> attribute set, or the <{body}> element if the attribute isn't present. The {{NavigationInterceptOptions/focusReset}} option can be set to "{{NavigationFocusReset/manual}}" to avoid this behavior.

    <p>By default, using this method will delay the browser's scroll restoration logic for "{{NavigationType/traverse}}" or "{{NavigationType/reload}}" navigations, or its scroll-reset/scroll-to-a-fragment logic for "{{NavigationType/push}}" and "{{NavigationType/replace}}" navigations, until any handlers' returned promises settle. The {{NavigationInterceptOptions/scroll}} option can be set to "{{NavigationScrollBehavior/manual}}" to turn off any browser-driven scroll behavior entirely for this navigation, or {{NavigateEvent/scroll()|event.scroll()}} can be called before the promise settles to trigger this behavior early.

    <p>This method will throw a "{{SecurityError}}" {{DOMException}} if {{NavigateEvent/canIntercept}} is false, or if {{Event/isTrusted}} is false. It will throw an "{{InvalidStateError}}" {{DOMException}} if not called synchronously, during event dispatch.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/scroll()|scroll}}()</code>
  <dd>
    <p>For "{{NavigationType/traverse}}" or "{{NavigationType/reload}}" navigations, restores the scroll position using the browser's usual scroll restoration logic.

    <p>For "{{NavigationType/push}}" or "{{NavigationType/replace}}" navigations, either resets the scroll position to the top of the document or scrolls to the fragment specified by {{NavigationDestination/url|event.destination.url}} if there is one.

    <p>If called more than once, or called after automatic post-transition scroll processing has happened due to the {{NavigationInterceptOptions/scroll}} option being left as "{{NavigationScrollBehavior/after-transition}}", this method will throw an "{{InvalidStateError}}" {{DOMException}}.
  </dd>
</dl>

The <dfn attribute for="NavigateEvent">navigationType</dfn>, <dfn attribute for="NavigateEvent">destination</dfn>, <dfn attribute for="NavigateEvent">canIntercept</dfn>, <dfn attribute for="NavigateEvent">userInitiated</dfn>, <dfn attribute for="NavigateEvent">hashChange</dfn>, <dfn attribute for="NavigateEvent">signal</dfn>, <dfn attribute for="NavigateEvent">formData</dfn>, <dfn attribute for="NavigateEvent">downloadRequest</dfn>, and <dfn attribute for="NavigateEvent">info</dfn> getter steps are to return the value that the corresponding attribute was initialized to.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">classic history API serialized data</dfn>, a [=serialized state=]-or-null. It is only used in some cases where the event's {{NavigateEvent/navigationType}} is "{{NavigationType/push}}" or "{{NavigationType/replace}}", and is set appropriately when the event is [[#navigate-event-firing|fired]].

A {{NavigateEvent}} has a <dfn for="NavigateEvent">focus reset behavior</dfn>, a {{NavigationFocusReset}}-or-null, initially null.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">scroll behavior</dfn>, a {{NavigationScrollBehavior}}-or-null, initially null.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">did process scroll behavior</dfn>, a boolean, initially false.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">was intercepted</dfn>, a boolean, initially false.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">needs continue</dfn>, a boolean, initially false.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">navigation handler list</dfn>, which is a [=list=] of {{NavigationInterceptHandler}} callbacks, initially empty.

<div algorithm>
  The <dfn method for="NavigateEvent">intercept(|options|)</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s {{Event/isTrusted}} attribute was initialized to false, then throw a "{{SecurityError}}" {{DOMException}}.
  1. If [=this=]'s {{NavigateEvent/canIntercept}} attribute was initialized to false, then throw a "{{SecurityError}}" {{DOMException}}.
  1. If [=this=]'s [=Event/dispatch flag=] is unset, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s [=Event/canceled flag=] is set, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If |options|["{{NavigationInterceptOptions/handler}}"] [=map/exists=], then [=list/append=] it to [=this=]'s [=NavigateEvent/navigation handler list=].
  1. Set [=this=]'s [=NavigateEvent/was intercepted=] to true.
  1. If |options|["{{NavigationInterceptOptions/focusReset}}"] [=map/exists=], then:
    1. If [=this=]'s [=NavigateEvent/focus reset behavior=] is not null, and it is not equal to |options|["{{NavigationInterceptOptions/focusReset}}"], then the user agent may [=report a warning to the console=] indicating that the {{NavigationInterceptOptions/focusReset}} option for a previous call to {{NavigateEvent/intercept()}} was overridden by this new value, and the previous value will be ignored.
    1. Set [=this=]'s [=NavigateEvent/focus reset behavior=] to |options|["{{NavigationInterceptOptions/focusReset}}"].
  1. If |options|["{{NavigationInterceptOptions/scroll}}"] [=map/exists=], then:
    1. If [=this=]'s [=NavigateEvent/scroll behavior=] is not null, and it is not equal to |options|["{{NavigationInterceptOptions/scroll}}"], then the user agent may [=report a warning to the console=] indicating that the {{NavigationInterceptOptions/scroll}} option for a previous call to {{NavigateEvent/intercept()}} was overridden by this new value, and the previous value will be ignored.
    1. Set [=this=]'s [=NavigateEvent/scroll behavior=] to |options|["{{NavigationInterceptOptions/scroll}}"].
</div>

<div algorithm>
  The <dfn method for="NavigateEvent">scroll()</dfn> method steps are:

  1. If [=this=]'s [=NavigateEvent/did process scroll behavior=] is true, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s [=NavigateEvent/was intercepted=] is false, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. [=Definitely process scroll behavior=] given [=this=].
</div>

<h3 id="navigate-event-destination">The {{NavigationDestination}} class</h3>

<xmp class="idl">
[Exposed=Window]
interface NavigationDestination {
  readonly attribute USVString url;
  readonly attribute DOMString? key;
  readonly attribute DOMString? id;
  readonly attribute long long index;
  readonly attribute boolean sameDocument;

  any getState();
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/url}}</code>
  <dd>
    <p>The URL being navigated to.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/key}}</code>
  <dd>
    <p>The value of the {{NavigationHistoryEntry/key}} property of the destination {{NavigationHistoryEntry}}, if this is a "{{NavigationType/traverse}}" navigation, or null otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/id}}</code>
  <dd>
    <p>The value of the {{NavigationHistoryEntry/id}} property of the destination {{NavigationHistoryEntry}}, if this is a "{{NavigationType/traverse}}" navigation, or null otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/index}}</code>
  <dd>
    <p>The value of the {{NavigationHistoryEntry/index}} property of the destination {{NavigationHistoryEntry}}, if this is a "{{NavigationType/traverse}}" navigation, or &minus;1 otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/sameDocument}}</code>
  <dd>
    <p>Indicates whether or not this navigation is to the same {{Document}} as the current {{Window/document}} value, or not. This will be true, for example, in cases of fragment navigations or {{History/pushState()|history.pushState()}} navigations.

    <p>Note that this property indicates the original nature of the navigation. If a cross-document navigation is converted into a same-document navigation using {{NavigateEvent/intercept()|event.intercept()}}, that will not change the value of this property.
  </dd>

  <dt><code><var ignore>state</var> = <var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/getState()}}</code>
  <dd>
    <p>For "{{NavigationType/traverse}}" navigations, returns the deserialization of the state stored in the destination session history entry.

    <p>For "{{NavigationType/push}}" and "{{NavigationType/replace}}" navigations, returns the deserialization of the state passed to {{Navigation/navigate()|navigation.navigate()}}, if the navigation was initiated in that way, or undefined if it wasn't.

    <p>For "{{NavigationType/reload}}" navigations, returns the deserialization of the state passed to {{Navigation/reload()|navigation.reload()}}, if the reload was initiated in that way, or undefined if it wasn't.
  </dd>
</dl>

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">URL</dfn>, which is a [=URL=].

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">key</dfn>, which is a [=string=]-or-null.

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">id</dfn>, which is a [=string=]-or-null.

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">index</dfn>, which is an integer.

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">state</dfn>, which is a [=serialized state=]-or-null.

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">is same document</dfn>, which is a boolean.

The <dfn attribute for="NavigationDestination">url</dfn> getter steps are to return [=this=]'s [=NavigationDestination/URL=], [=URL serializer|serialized=].

The <dfn attribute for="NavigationDestination">key</dfn> getter steps are to return [=this=]'s [=NavigationDestination/key=].

The <dfn attribute for="NavigationDestination">id</dfn> getter steps are to return [=this=]'s [=NavigationDestination/id=].

The <dfn attribute for="NavigationDestination">index</dfn> getter steps are to return [=this=]'s [=NavigationDestination/index=].

The <dfn attribute for="NavigationDestination">sameDocument</dfn> getter steps are to return [=this=]'s [=NavigationDestination/is same document=].

<div algorithm>
  The <dfn method for="NavigationDestination">getState()</dfn> method steps are:

  1. If [=this=]'s [=NavigationDestination/state=] is null, then return undefined.
  1. Return [$StructuredDeserialize$]([=this=]'s [=NavigationDestination/state=]).
</div>

<h3 id="navigate-event-firing">Firing the event</h3>

<div algorithm="fire a traversal navigate event">
  To <dfn>fire a traversal `navigate` event</dfn> at a {{Navigation}} |navigation| given a [=session history entry=] <dfn for="fire a traversal navigate event">|destinationEntry|</dfn>, and an optional [=user navigation involvement=] <dfn for="fire a traversal navigate event">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>"):

  1. Let |event| be the result of [=creating an event=] given {{NavigateEvent}}, in |navigation|'s [=relevant realm=].
  1. Set |event|'s [=NavigateEvent/classic history API serialized data=] to null.
  1. Let |destination| be a [=new=] {{NavigationDestination}} created in |navigation|'s [=relevant realm=].
  1. Set |destination|'s [=NavigationDestination/URL=] to |destinationEntry|'s [=session history entry/URL=].
  1. If |destinationEntry|'s [=session history entry/document state=]'s [=document state/origin=] is [=same origin=] with |navigation|'s [=relevant settings object=]'s [=environment settings object/origin=], then:
    1. Set |destination|'s [=NavigationDestination/key=] to |destinationEntry|'s [=session history entry/navigation API key=].
    1. Set |destination|'s [=NavigationDestination/id=] to |destinationEntry|'s [=session history entry/navigation API ID=].
    1. Set |destination|'s [=NavigationDestination/index=] to the result of [=getting the navigation API history index=] of |destinationEntry| within |navigation|.
    1. Set |destination|'s [=NavigationDestination/state=] to |destinationEntry|'s [=session history entry/navigation API state=].
  1. Otherwise,
    1. Set |destination|'s [=NavigationDestination/key=] to null.
    1. Set |destination|'s [=NavigationDestination/id=] to null.
    1. Set |destination|'s [=NavigationDestination/index=] to &minus;1.
    1. Set |destination|'s [=NavigationDestination/state=] to null.
  1. Set |destination|'s [=NavigationDestination/is same document=] to true if |destinationEntry|'s [=session history entry/document=] is equal to |navigation|'s [=relevant global object=]'s [=associated Document=]; otherwise false.
  1. Return the result of performing the [=inner navigate event firing algorithm=] given |navigation|, "{{NavigationType/traverse}}", |event|, |destination|, |userInvolvement|, null, and null.
</div>

<div algorithm="fire a non-traversal navigate event">
  To <dfn>fire a non-traversal `navigate` event</dfn> at a {{Navigation}} |navigation| given a {{NavigationType}} <dfn for="fire a non-traversal navigate event">|navigationType|</dfn>, a [=URL=] <dfn for="fire a non-traversal navigate event">|destinationURL|</dfn>, a boolean <dfn for="fire a non-traversal navigate event">|isSameDocument|</dfn>, an optional [=user navigation involvement=] <dfn for="fire a non-traversal navigate event">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>"), an optional [=serialized state=]-or-null <dfn for="fire a non-traversal navigate event">|state|</dfn> (default null), an optional [=entry list=] or null <dfn for="fire a non-traversal navigate event">|formDataEntryList|</dfn> (default null), and an optional [=serialized state=]-or-null <dfn for="fire a non-traversal navigate event">|classicHistoryAPISerializedData|</dfn> (default null):

  1. Let |event| be the result of [=creating an event=] given {{NavigateEvent}}, in |navigation|'s [=relevant realm=].
  1. Set |event|'s [=NavigateEvent/classic history API serialized data=] to |classicHistoryAPISerializedData|.
  1. Let |destination| be a [=new=] {{NavigationDestination}} created in |navigation|'s [=relevant realm=].
  1. Set |destination|'s [=NavigationDestination/URL=] to |destinationURL|.
  1. Set |destination|'s [=NavigationDestination/key=] to null.
  1. Set |destination|'s [=NavigationDestination/id=] to null.
  1. Set |destination|'s [=NavigationDestination/index=] to &minus;1.
  1. Set |destination|'s [=NavigationDestination/state=] to |state|.
  1. Set |destination|'s [=NavigationDestination/is same document=] to |isSameDocument|.
  1. Return the result of performing the [=inner navigate event firing algorithm=] given |navigation|, |navigationType|, |event|, |destination|, |userInvolvement|, |formDataEntryList|, and null.
</div>

<div algorithm="fire a download-requested navigate event">
  To <dfn>fire a download-requested `navigate` event</dfn> at a {{Navigation}} |navigation| given a [=URL=] <dfn for="fire a download-requested navigate event">|destinationURL|</dfn>, a [=user navigation involvement=] <dfn for="fire a download-requested navigate event">|userInvolvement|</dfn>, and a string <dfn for="fire a download-requested navigate event">|filename|</dfn>:

  1. Let |event| be the result of [=creating an event=] given {{NavigateEvent}}, in |navigation|'s [=relevant realm=].
  1. Set |event|'s [=NavigateEvent/classic history API serialized data=] to null.
  1. Let |destination| be a [=new=] {{NavigationDestination}} created in |navigation|'s [=relevant realm=].
  1. Set |destination|'s [=NavigationDestination/URL=] to |destinationURL|.
  1. Set |destination|'s [=NavigationDestination/key=] to null.
  1. Set |destination|'s [=NavigationDestination/id=] to null.
  1. Set |destination|'s [=NavigationDestination/index=] to &minus;1.
  1. Set |destination|'s [=NavigationDestination/state=] to null.
  1. Set |destination|'s [=NavigationDestination/is same document=] to false.
  1. Return the result of performing the [=inner navigate event firing algorithm=] given |navigation|, "{{NavigationType/push}}", |event|, |destination|, |userInvolvement|, null, and |filename|.
</div>

<div algorithm>
  The <dfn>inner `navigate` event firing algorithm</dfn> is the following steps, given a {{Navigation}} |navigation|, a {{NavigationType}} |navigationType|, a {{NavigateEvent}} |event|, a {{NavigationDestination}} |destination|, a [=user navigation involvement=] |userInvolvement|, an [=entry list=] or null |formDataEntryList|, and a string or null |downloadRequestFilename|:

  1. [=Navigation/Promote the upcoming navigation to ongoing=] given |navigation| and |destination|'s [=NavigationDestination/key=].
  1. Let |ongoingNavigation| be |navigation|'s [=Navigation/ongoing navigation=].
  1. If |navigation| [=Navigation/has entries and events disabled=], then:
    1. If |ongoingNavigation| is not null, then [=navigation API method navigation/clean up=] |ongoingNavigation|.

       <p class="note">In this case the [=navigation API method navigation/committed promise=] and [=navigation API method navigation/finished promise=] will never fulfill, since we never create {{NavigationHistoryEntry}}s for the initial `about:blank` {{Document}} so we have nothing to [=resolve=] them with.
    1. Return true.
  1. Let |navigable| be |navigation|'s [=relevant global object=]'s [=Window/navigable=].
  1. Let |document| be |navigation|'s [=relevant global object=]'s [=associated document=].
  1. If |document| <a spec="HTML">can have its URL rewritten</a> to |destination|'s [=NavigationDestination/URL=], and either |destination|'s [=NavigationDestination/is same document=] is true or |navigationType| is not "{{NavigationType/traverse}}", then initialize |event|'s {{NavigateEvent/canIntercept}} to true. Otherwise, initialize it to false.
  1. Let |traverseCanBeCanceled| be true if |userInvolvement| is not "<code>[=user navigation involvement/browser UI=]</code>" or |navigation|'s [=relevant global object=] has [=transient activation=]; otherwise, false.
     <p class="note">We are exploring the possibility of introducing the concept of a "consumable user activation" (i.e., a user activation that can be consumed like a transient user activation, but does not have the timeout of a transient user activation) instead of using transient activation here. This does not have a spec yet.
  1. If any of the following are true:
    * |navigationType| is not "{{NavigationType/traverse}}"; or
    * |navigable| is a [=top-level traversable=] and |traverseCanBeCanceled| is true

    then initialize |event|'s {{Event/cancelable}} to true. Otherwise, initialize it to false.
  1. Initialize |event|'s {{Event/type}} to "{{Navigation/navigate}}".
  1. Initialize |event|'s {{NavigateEvent/navigationType}} to |navigationType|.
  1. Initialize |event|'s {{NavigateEvent/destination}} to |destination|.
  1. Initialize |event|'s {{NavigateEvent/downloadRequest}} to |downloadRequestFilename|.
  1. If |ongoingNavigation| is not null, then initialize |event|'s {{NavigateEvent/info}} to |ongoingNavigation|'s [=navigation API method navigation/info=]. Otherwise, initialize it to undefined.
     <p class="note">At this point |ongoingNavigation|'s [=navigation API method navigation/info=] is no longer needed and can be nulled out instead of keeping it alive for the lifetime of the [=navigation API method navigation=].
  1. Initialize |event|'s {{NavigateEvent/signal}} to a [=new=] {{AbortSignal}} created in |navigation|'s [=relevant realm=].
  1. Let |currentURL| be |document|'s [=Document/URL=].
  1. If all of the following are true:
    * |destination|'s [=NavigationDestination/is same document=] is true;
    * |destination|'s [=NavigationDestination/URL=] [=url/equals=] |currentURL| with <i>[=url/equals/exclude fragments=]</i> set to true; and
    * |destination|'s [=NavigationDestination/URL=]'s [=url/fragment=] is not [=string/is|identical to=] |currentURL|'s [=url/fragment=]

    then initialize |event|'s {{NavigateEvent/hashChange}} to true. Otherwise, initialize it to false.
  1. If |userInvolvement| is not "<code>[=user navigation involvement/none=]</code>", then initialize |event|'s {{NavigateEvent/userInitiated}} to true. Otherwise, initialize it to false.
  1. If |formDataEntryList| is not null, then initialize |event|'s {{NavigateEvent/formData}} to a [=new=] {{FormData}} created in |navigation|'s [=relevant realm=], associated to |formDataEntryList|. Otherwise, initialize it to null.
  1. [=Assert=]: |navigation|'s [=Navigation/ongoing navigate event=] is null.
  1. Set |navigation|'s [=Navigation/ongoing navigate event=] to |event|.
  1. [=Assert=]: |navigation|'s [=Navigation/ongoing navigation signal=] is null.
  1. Set |navigation|'s [=Navigation/ongoing navigation signal=] to |event|'s {{NavigateEvent/signal}}.
  1. Set |navigation|'s [=Navigation/focus changed during ongoing navigation=] to false.
  1. Set |navigation|'s [=Navigation/suppress normal scroll restoration during ongoing navigation=] to false.
  1. Let |dispatchResult| be the result of [=dispatching=] |event| at |navigation|.
  1. If |dispatchResult| is false:
    1. If |navigationType| is not "{{NavigationType/traverse}}" and |event|'s {{NavigateEvent/signal}} is not [=AbortSignal/aborted=], then [=finalize with an aborted navigation error=] given |navigation| and |ongoingNavigation|.
       <p class="note">If |navigationType| is "{{NavigationType/traverse}}", then we will [=finalize with an aborted navigation error=] in [=perform a navigation API traversal=].
    1. Return false.

  1. If |destination|'s [=NavigationDestination/is same document=] is true and |navigationType| is "{{NavigationType/traverse}}":
    1. Set |event|'s [=NavigateEvent/needs continue=] to true.
    1. Return true.
  1. Return the result of [=reacting to navigate event result=] given |navigation| and |event|.
</div>

<div algorithm>
  To <dfn>react to `navigate` event result</dfn>, given a {{Navigation}} |navigation| and a {{NavigateEvent}} |event|:
  1. Let |document| be |navigation|'s [=relevant global object=]'s [=associated document=].
  1. Let |destination| be |event|'s {{NavigateEvent/destination}}.
  1. Let |ongoingNavigation| be |navigation|'s [=Navigation/ongoing navigation=].
  1. Let |navigationType| be |event|'s {{NavigateEvent/navigationType}}.
  1. Let |endResultIsSameDocument| be true if |event|'s [=NavigateEvent/was intercepted=] is true or |destination|'s [=NavigationDestination/is same document=] is true.
  1. [=Prepare to run script=] given |event|'s [=relevant settings object=].
      <div class="note" id="note-suppress-microtasks-during-navigation-events">
        <p>This is done to avoid the [=ECMAScript/execution context stack|JavaScript execution context stack=] becoming empty right after any {{Navigation/currententrychange}} event handlers run as a result of the [=URL and history update steps=] that could soon happen. If the stack were to become empty at that time, then it would immediately [=perform a microtask checkpoint=], causing various promise fulfillment handlers to run interleaved with the event handlers and before any handlers passed to {{NavigateEvent/intercept()|navigateEvent.intercept()}}. This is undesirable since it means promise handler ordering vs. {{Navigation/currententrychange}} event handler ordering vs. {{NavigateEvent/intercept()}} handler ordering is dependent on whether the navigation is happening with an empty [=ECMAScript/execution context stack|JavaScript execution context stack=] (e.g., because the navigation was user-initiated) or with a nonempty one (e.g., because the navigation was caused by a JavaScript API call).

        <p>By inserting an otherwise-unnecessary [=ECMAScript/execution context|JavaScript execution context=] onto the stack in this step, we essentially suppress the [=perform a microtask checkpoint=] algorithm until later, thus ensuring that the sequence is always: {{Navigation/currententrychange}} event handlers, then {{NavigateEvent/intercept()}} handlers, then promise handlers.
      </div>
  1. If |event|'s [=NavigateEvent/was intercepted=] is true:
    1. Let |fromEntry| be the [=Navigation/current entry=] for |navigation|.
    1. [=Assert=]: |fromEntry| is not null.
    1. Set |navigation|'s [=Navigation/transition=] to a [=new=] {{NavigationTransition}} created in |navigation|'s [=relevant realm=], whose [=NavigationTransition/navigation type=] is |navigationType|, [=NavigationTransition/from entry=] is |fromEntry|, and whose [=NavigationTransition/finished promise=] is [=a new promise=] created in |navigation|'s [=relevant realm=].
    1. [=Mark as handled=] |navigation|'s [=Navigation/transition=]'s [=NavigationTransition/finished promise=].
      <p class="note">See <a href="#note-finished-promise-mark-as-handled">the discussion about other finished promises</a> as to why this is done.</p>
    1. If |navigationType| is "{{NavigationType/traverse}}", then set |navigation|'s [=Navigation/suppress normal scroll restoration during ongoing navigation=] to true.
       <p class="note">If |event|'s [=NavigateEvent/scroll behavior=] was set to "{{NavigationScrollBehavior/after-transition}}", then we will [=potentially process scroll behavior|potentially perform scroll restoration=] below. Otherwise, there will be no scroll restoration. That is, no navigation which is intercepted by {{NavigateEvent/intercept()}} goes through the normal scroll restoration process; scroll restoration for such navigations is either done manually, by the web developer, or is done after the transition.
    1. If |navigationType| is "{{NavigationType/push}}" or "{{NavigationType/replace}}", then run the [=URL and history update steps=] given |document| and |event|'s {{NavigateEvent/destination}}'s [=NavigationDestination/URL=], with <i>[=URL and history update steps/serializedData=]</i> set to |event|'s [=NavigateEvent/classic history API serialized data=] and <i>[=URL and history update steps/historyHandling=]</i> set to |navigationType|.

       <p class="note">If |navigationType| is "{{NavigationType/reload}}", then we are converting a reload into a "same-document reload", for which the <a spec="HTML">URL and history update steps</a> are not appropriate. Navigation API-related stuff still happens, such as updating the [=navigable/active session history entry=]'s [=session history entry/navigation API state=] if this was caused by a call to {{Navigation/reload()|navigation.reload()}}, and all the <a href="#ongoing-state">ongoing navigation tracking</a>.
  1. If |endResultIsSameDocument| is true:
    1. Let |promisesList| be an empty [=list=].
    1. [=list/For each=] |handler| of |event|'s [=NavigateEvent/navigation handler list=]:
      1. [=list/Append=] the result of [=invoking=] |handler| to |promisesList| with an empty arguments list.
    1. If |promisesList|'s [=list/size=] is 0, then set |promisesList| to  [=a promise resolved with=] {{undefined}} .
       <p class="note">There is a subtle timing difference between how [=waiting for all=] schedules its success and failure steps when given zero promises versus &geq;1 promises. For most uses of [=waiting for all=], this does not matter. However, with this API, there are so many events and promise handlers which could fire around the same time that the difference is pretty easily observable: it can cause the event/promise handler sequence to vary. (Some of the events and promises involved include: {{Navigation/navigatesuccess}} / {{Navigation/navigateerror}}, {{Navigation/currententrychange}}, {{NavigationHistoryEntry/dispose}}, |ongoingNavigation|'s promises, and the {{NavigationTransition/finished|navigation.transition.finished}} promise.)
    1. [=Wait for all=] of |promisesList|, with the following success steps:
        1. If |event|'s {{NavigateEvent/signal}} is [=AbortSignal/aborted=], then abort these steps.
        1. If |event| equals |navigation|'s [=Navigation/ongoing navigate event=], set |navigation|'s [=Navigation/ongoing navigate event=] to null.
        1. [=Fire an event=] named {{Navigation/navigatesuccess}} at |navigation|.
        1. If |navigation|'s [=Navigation/transition=] is not null, then [=resolve=] |navigation|'s [=Navigation/transition=]'s [=NavigationTransition/finished promise=] with undefined.
        1. Set |navigation|'s [=Navigation/transition=] to null.
        1. If |ongoingNavigation| is non-null, then [=navigation API method navigation/resolve the finished promise=] for |ongoingNavigation|.
        1. [=Potentially reset the focus=] given |navigation| and |event|.
        1. [=Potentially process scroll behavior=] given |event|.
      and the following failure steps given reason |rejectionReason|:
        1. If |event|'s {{NavigateEvent/signal}} is [=AbortSignal/aborted=], then abort these steps.
        1. [=Fire an event=] named {{Navigation/navigateerror}} at |navigation| using {{ErrorEvent}}, with {{ErrorEvent/error}} initialized to |rejectionReason|, and {{ErrorEvent/message}}, {{ErrorEvent/filename}}, {{ErrorEvent/lineno}}, and {{ErrorEvent/colno}} initialized to appropriate values that can be extracted from |rejectionReason| in the same underspecified way the user agent typically does for the <a spec="HTML">report an exception</a> algorithm.
        1. If |navigation|'s [=Navigation/transition=] is not null, then [=reject=] |navigation|'s [=Navigation/transition=]'s [=NavigationTransition/finished promise=] with |rejectionReason|.
        1. Set |navigation|'s [=Navigation/transition=] to null.
        1. If |ongoingNavigation| is non-null, then [=navigation API method navigation/reject the finished promise=] for |ongoingNavigation| with |rejectionReason|.
        1. [=Potentially reset the focus=] given |navigation| and |event|.
           <p class="note">Although we still [=potentially reset the focus=] for such failed transitions, we do <em>not</em> [=potentially process scroll behavior=] for them.
  1. Otherwise, if |ongoingNavigation| is non-null, then [=navigation API method navigation/clean up=] |ongoingNavigation|.
  1. [=Clean up after running script=] given |event|'s [=relevant settings object=].
     <p class="note">Per the <a href="#note-suppress-microtasks-during-navigation-events">previous note</a>, this stops suppressing any potential promise handler microtasks, causing them to run at this point or later.</p>
  1. If |event|'s [=NavigateEvent/was intercepted=] is true, then return false.
  1. Return true.
</div>

<div algorithm>
  To <dfn>maybe continue the `navigate` event</dfn>, given a {{Navigation}} |navigation|:
  1. If |navigation|'s [=Navigation/ongoing navigate event=] is null, or |navigation|'s [=Navigation/ongoing navigate event=]'s [=NavigateEvent/needs continue=] is false, then return.
  1. [=React to navigate event result=] given |navigation| and |navigation|'s [=Navigation/ongoing navigate event=].
</div>

<div algorithm>
  To <dfn>finalize with an aborted navigation error</dfn> given a {{Navigation}} |navigation|, a [=navigation API method navigation=] or null |ongoingNavigation|, and an optional {{DOMException}} |error|:

  1. Set |navigation|'s [=Navigation/focus changed during ongoing navigation=] to false.
  1. Set |navigation|'s [=Navigation/suppress normal scroll restoration during ongoing navigation=] to false.
  1. If |error| was not given, then set |error| to a [=new=] "{{AbortError}}" {{DOMException}}, created in |navigation|'s [=relevant realm=].
  1. If |navigation|'s [=Navigation/ongoing navigate event=] is non-null, then:
    1. Set |navigation|'s [=Navigation/ongoing navigate event=]'s [=Event/canceled flag=] to true.
    1. Set |navigation|'s [=Navigation/ongoing navigate event=] to null.
  1. If |navigation|'s [=Navigation/ongoing navigation signal=] is non-null, then:
    1. [=AbortSignal/Signal abort=] on |navigation|'s [=Navigation/ongoing navigation signal=] given |error|.
    1. Set |navigation|'s [=Navigation/ongoing navigation signal=] to null.
  1. [=Fire an event=] named {{Navigation/navigateerror}} at |navigation| using {{ErrorEvent}}, with {{ErrorEvent/error}} initialized to |error|, and {{ErrorEvent/message}}, {{ErrorEvent/filename}}, {{ErrorEvent/lineno}}, and {{ErrorEvent/colno}} initialized to appropriate values that can be extracted from |error| and the current JavaScript stack in the same underspecified way the user agent typically does for the <a spec="HTML">report an exception</a> algorithm.
     <p class="note">Thus, for example, if this algorithm is reached because of a call to {{Window/stop()|window.stop()}}, these properties would probably end up initialized based on the line of script that called {{Window/stop()|window.stop()}}. But if it's because the user clicked the stop button, these properties would probably end up with default values like the empty string or 0.
  1. If |ongoingNavigation| is non-null, then [=navigation API method navigation/reject the finished promise=] for |ongoingNavigation| with |error|.
  1. If |navigation|'s [=Navigation/transition=] is not null, then:
    1. [=Reject=] |navigation|'s [=Navigation/transition=]'s [=NavigationTransition/finished promise=] with |error|.
    1. Set |navigation|'s [=Navigation/transition=] to null.
</div>

<div algorithm>
  To <dfn>inform the navigation API about canceling navigation</dfn> in a [=navigable=] |navigable|:

  1. Let |navigation| be |navigable|'s [=navigable/active window=]'s [=Window/navigation API=].
  1. If |navigation|'s [=Navigation/ongoing navigation signal=] is null, then return.
  1. [=Finalize with an aborted navigation error=] given |navigation| and |navigation|'s [=Navigation/ongoing navigation=].
</div>

<div algorithm>
  To <dfn>inform the navigation API about nested navigable destruction</dfn> given a [=navigable=] |navigable|:

  1. [=Inform the navigation API about canceling navigation=] in |navigable|.
  1. Let |navigation| be |navigable|'s [=navigable/active window=]'s [=Window/navigation API=].
  1. Let |traversals| be a [=list/clone=] of |navigation|'s [=Navigation/upcoming traverse navigations=].
  1. For each |traversal| of |traversals|: [=finalize with an aborted navigation error=] given |navigation| and |traversal|.
</div>

<div algorithm>
  To <dfn>potentially reset the focus</dfn> given a {{Navigation}} object |navigation| and an {{NavigateEvent}} |event|:

  1. Let |focusChanged| be |navigation|'s [=Navigation/focus changed during ongoing navigation=].
  1. Set |navigation|'s [=Navigation/focus changed during ongoing navigation=] to false.
  1. If |focusChanged| is true, then return.
  1. If |event|'s [=NavigateEvent/was intercepted=] is false, then return.
  1. If |event|'s [=NavigateEvent/focus reset behavior=] is "{{NavigationFocusReset/manual}}", then return.
     <p class="note">If it was left as null, then we treat that as "{{NavigationFocusReset/after-transition}}", and continue onward.
  1. Let |document| be |navigation|'s [=relevant global object=]'s [=associated Document=].
  1. Let |focusTarget| be the <a spec="HTML">autofocus delegate</a> for |document|.
  1. If |focusTarget| is null, then set |focusTarget| to |document|'s <a spec="HTML" lt="the body element">body element</a>.
  1. If |focusTarget| is null, then set |focusTarget| to |document|'s [=document element=].
  1. Run the <a spec="HTML">focusing steps</a> for |focusTarget|, with |document|'s [=viewport=] as the fallback target.
  1. Move the <a spec="HTML">sequential focus navigation starting point</a> to |focusTarget|.
</div>

<div algorithm>
  To <dfn>potentially process scroll behavior</dfn> given a {{NavigateEvent}} |event|:

  1. If |event|'s [=NavigateEvent/was intercepted=] is false, then return.
  1. If |event|'s [=NavigateEvent/scroll behavior=] is "{{NavigationScrollBehavior/manual}}", then return.
     <p class="note">If it was left as null, then we treat that as "{{NavigationScrollBehavior/after-transition}}", and continue onward.
  1. If |event|'s [=NavigateEvent/did process scroll behavior=] is true, then return.
  1. [=Definitely process scroll behavior=] given |event|.
</div>

<div algorithm>
   To <dfn>definitely process scroll behavior</dfn> given a {{NavigateEvent}} |event|:

  1. Set |event|'s [=NavigateEvent/did process scroll behavior=] to true.
  1. If |event|'s {{NavigateEvent/navigationType}} was initialized to "{{NavigationType/traverse}}" or "{{NavigationType/reload}}", then [=restore scroll position data=] given |event|'s [=relevant global object=]'s [=Window/navigable=]'s [=navigable/active session history entry=].
  1. Otherwise,
    1. Let |document| be |event|'s [=relevant global object=]'s [=associated Document=].
    1. If |document|'s [=Document/indicated part=] is null, then [=scroll to the beginning of the document=] given |document|.
    1. Otherwise, [=scroll to the fragment=] given |document|.
</div>

<h2 id="NavigationHistoryEntry-class">Navigation API history entries</h2>

<xmp class="idl">
[Exposed=Window]
interface NavigationHistoryEntry : EventTarget {
  readonly attribute USVString? url;
  readonly attribute DOMString key;
  readonly attribute DOMString id;
  readonly attribute long long index;
  readonly attribute boolean sameDocument;

  any getState();

  attribute EventHandler ondispose;
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/url}}</code>
  <dd>
    <p>The URL of this navigation history entry.

    <p>This can return null if the entry corresponds to a different {{Document}} than the current one (i.e. if {{NavigationHistoryEntry/sameDocument}} is false), and that {{Document}}'s [=policy container/referrer policy=] was <a>"`no-referrer`"</a> or <a>"`origin`"</a>, since that indicates the {{Document}} in question is hiding its URL even from other same-origin pages.
  </dd>

  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/key}}</code>
  <dd>
    <p>A [=user agent=]-generated random UUID string representing this navigation history entry's place in the navigation history list. This value will be reused by other {{NavigationHistoryEntry}} instances that replace this one due to replace-style navigations. This value will survive session restores.

    <p>This is useful for navigating back to this entry in the navigation history list, using {{Navigation/traverseTo(key)|navigation.traverseTo(key)}}.
  </dd>

  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/id}}</code>
  <dd>
    <p>A [=user agent=]-generated random UUID string representing this specific navigation history entry. This value will <em>not</em> be reused by other {{NavigationHistoryEntry}} instances. This value will survive session restores.

    <p>This is useful for associating data with this navigation history entry using other storage APIs.
  </dd>

  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/index}}</code>
  <dd>
    <p>The index of this navigation history entry within {{Navigation/entries()|navigation.entries()}}, or &minus;1 if the entry is not in the navigation history entry list.
  </dd>

  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/sameDocument}}</code>
  <dd>
    <p>Indicates whether or not this navigation history entry is for the same {{Document}} as the current {{Window/document}} value, or not. This will be true, for example, when the entry represents a fragment navigation or single-page app navigations.
  </dd>

  <dt><code><var ignore>state</var> = <var ignore>entry</var>.{{NavigationHistoryEntry/getState()|getState}}()</code>
  <dd>
    <p>Returns the deserialization of the state stored in this entry, which was added to the entry using {{Navigation/navigate()|navigation.navigate()}}. This state survives session restores.

    <p>Note that in general, unless the state value is a primitive, <code>entry.getState() !== entry.getState()</code>, since a fresh copy is returned each time.

    <p>This state is unrelated to the classic history API's {{History/state|history.state}}.
  </dd>
</dl>

Each {{NavigationHistoryEntry}} has an associated <dfn for="NavigationHistoryEntry">session history entry</dfn>, which is a [=session history entry=].

Each {{NavigationHistoryEntry}} has an associated <dfn for="NavigationHistoryEntry">index</dfn>, which is an integer.

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">key</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=].
</div>

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">id</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API ID=].
</div>

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">url</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return null.
  1. Let |she| be [=this=]'s [=NavigationHistoryEntry/session history entry=].
  1. If |she|'s [=session history entry/document=] does not equal [=this=]'s [=relevant global object=]'s [=associated Document=], and |she|'s [=session history entry/document state=]'s [=document state/request referrer policy=] is <a>"`no-referrer`"</a> or <a>"`origin`"</a>, then return null.
  1. Return |she|'s [=session history entry/URL=], [=URL serializer|serialized=].
</div>

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">index</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return &minus;1.
  1. Return [=this=]'s [=NavigationHistoryEntry/index=].
</div>

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">sameDocument</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return false.
  1. Return true if [=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/document=] equals [=this=]'s [=relevant global object=]'s [=associated Document=], and false otherwise.
</div>

<div algorithm>
  The <dfn method for="NavigationHistoryEntry">getState()</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return undefined.
  1. If [=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API state=] is null, then return undefined.
  1. Return [$StructuredDeserialize$]([=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API state=]).

  <p class="note">Unlike {{History/state|history.state}}, this will deserialize upon each access.

  <p class="note">This can in theory throw an exception, if attempting to deserialize a large {{ArrayBuffer}} when not enough memory is available.
</div>

The following are the [=event handlers=] (and their corresponding [=event handler event types=]) that must be supported, as [=event handler IDL attributes=], by objects implementing the {{NavigationHistoryEntry}} interface:

<table>
  <thead>
    <th>[=Event handler=]
    <th>[=Event handler event type=]
  <tbody>
    <tr>
      <td><dfn attribute for="NavigationHistoryEntry">ondispose</dfn>
      <td><dfn event for="NavigationHistoryEntry">dispose</dfn>
</table>

<h2 id="patches">HTML Standard monkeypatches</h2>

<h3 id="session-history-new-she-fields">New [=session history entry=] items</h3>

Each [=session history entry=] gains the following new [=struct/items=]:

* <dfn for="session history entry">navigation API key</dfn>, a string, initially set to the result of [=generating a random UUID=]

* <dfn for="session history entry">navigation API ID</dfn>, a string, initially set to the result of [=generating a random UUID=]

* <dfn for="session history entry">navigation API state</dfn>, which is [=serialized state=] or null, initially null

<h3 id="navigate-patch">Navigate</h3>

<div algorithm="navigate" id="navigate-modifications">
  Modify the <a spec="HTML">navigate</a> algorithms parameter list as follows:

  * Add an optional [=entry list=] or null <dfn for="navigate">|entryList|</dfn> (default null)
  * Add an optional [=user navigation involvement=] <dfn for="navigate">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>")
  * Add an optional [=serialized state=] or null <dfn for="navigate">|navigationAPIState|</dfn> (default null)
  * Remove |cspNavigationType|

  Add the following step early in the algorithm:

  1. Let |cspNavigationType| be "`form-submission`" if |entryList| is non-null; otherwise, "`other`".

  Add the following steps right before we go [=in parallel=]:

  1. Let |navigation| be |navigable|'s [=navigable/active window=]'s [=Window/navigation API=].
  1. If all of the following are false:
    * |userInvolvement| is "<code>[=user navigation involvement/browser UI=]</code>"
    * |navigable|'s [=navigable/active document=]'s [=Document/origin=] is not [=same origin-domain=] with <var ignore>sourceDocument</var>'s [=Document/origin=]
    * |navigable|'s [=navigable/active document=]'s <a spec="HTML">is initial about:blank</a> is true
    * |url|'s [=url/scheme=] is not a [=fetch scheme=]

    then:

      1. Let |continue| be the result of [=firing a non-traversal navigate event=] at |navigation| with <i>[=fire a non-traversal navigate event/navigationType=]</i> set to <var ignore>historyHandling</var>, <i>[=fire a non-traversal navigate event/isSameDocument=]</i> set to false, <i>[=fire a non-traversal navigate event/userInvolvement=]</i> set to |userInvolvement|, <i>[=fire a non-traversal navigate event/formDataEntryList=]</i> set to |entryList|, <i>[=fire a non-traversal navigate event/destinationURL=]</i> set to |url|, and <i>[=fire a non-traversal navigate event/state=]</i> set to |navigationAPIState|.
      1. If |continue| is false, return.

    <p class="note">"<code>[=user navigation involvement/browser UI=]</code>" or [=same origin-domain|cross origin-domain=] navigations that cause [=navigate to a fragment|fragment navigations=] <em>do</em> fire the {{Navigation/navigate}} event; those are handled as part of the [=navigate to a fragment=] algorithm called earlier in <a spec="HTML">navigate</a>, which is not guarded by this condition.
</div>

<h3 id="fragment-patch">Navigate to a fragment</h3>

<div algorithm="navigate to a fragment">
  Modify the [=navigate to a fragment=] algorithm to take a new |userInvolvement| argument. Then prepend the following steps:

  1. Let |navigation| be <var ignore>navigable</var>'s [=navigable/active window=]'s [=Window/navigation API=].
  1. Let |continue| be the result of [=firing a non-traversal navigate event=] at |navigation| given with <i>[=fire a non-traversal navigate event/navigationType=]</i> set to <var ignore>historyHandling</var>, <i>[=fire a non-traversal navigate event/isSameDocument=]</i> set to true, <i>[=fire a non-traversal navigate event/userInvolvement=]</i> set to |userInvolvement|, and <i>[=fire a non-traversal navigate event/destinationURL=]</i> set to <var ignore>url</var>.
  1. If |continue| is false, then return.

  Modify the step which creates the new <var ignore>historyEntry</var> to also copy over the [=session history entry/navigation API state=] from the [=navigable/active session history entry=].

  Insert the following step after the call to [=update document for history step application=]:

  1. [=Navigation/Update the entries for a same-document navigation=] given <var ignore>navigable</var>'s [=navigable/active window=]'s [=Window/navigation API=], <var ignore>navigable</var>'s [=navigable/active session history entry=], and <var ignore>historyHandling</var>.
</div>

</div>

<h3 id="push-replace-state-patch">Shared history push/replace state steps</h3>

<div algorithm="shared history push/replace steps">
  Modify the <a>shared history push/replace state steps</a> by inserting the following steps right before the step that runs the [=URL and history update steps=].

  1. Let |navigation| be <var ignore>history</var>'s [=relevant global object=]'s [=Window/navigation API=].
  1. Let |continue| be the result of [=firing a non-traversal navigate event=] at |navigation| with <i>[=fire a non-traversal navigate event/navigationType=]</i> set to <var ignore>historyHandling</var>, <i>[=fire a non-traversal navigate event/isSameDocument=]</i> set to true, <i>[=fire a non-traversal navigate event/destinationURL=]</i> set to <var ignore>newURL</var>, and <i>[=fire a non-traversal navigate event/classicHistoryAPISerializedData=]</i> set to <var ignore>serializedData</var>.
  1. If |continue| is false, then return.
</div>

<h3 id="uhus-patch">URL and history update steps</h3>

<div algorithm="URL and history update steps update patch">
  Update the [=URL and history update steps=] by appending the following step right after setting the [=navigable/active session history entry=]:

  1. [=Navigation/Update the entries for a same-document navigation=] given <var ignore>document</var>'s [=relevant global object=]'s [=Window/navigation API=], <var ignore>navigable</var>'s [=navigable/active session history entry=], and <var ignore>historyHandling</var>.
</div>

<h3 id="update-for-history-step-patch">Update document for history state application</h3>

<div algorithm="update document for history step application patch">
  Update the [=update document for history step application=] algorithm as follows:

  Prepend the following step:

  1. Let |navigation| be <var ignore>document</var>'s [=relevant global object=]'s [=Window/navigation API=].

  Inside the "<var ignore>documentsEntryChanged</var> is true" block, after [=restore the history state object=]:

  1. If <var ignore>documentIsNew</var> is false, then [=Navigation/update the entries for a same-document navigation=] given |navigation|, |entry|, and "{{NavigationType/traverse}}".

  1. Otherwise, [=Navigation/initialize the entries for a new Navigation=] given |navigation|, <var ignore>sessionHistoryEntries</var> TODO pass this in, and |entry|.

  <p class="note">This means any {{Navigation/currententrychange}} event and {{NavigationHistoryEntry/dispose}} events will fire before the {{Window/popstate}} and {{Window/hashchange}} events, and those event handlers will see an updated {{Navigation}} object.
</div>

<h3 id="finalize-patch">Finalize a cross-document navigation</h3>

<div algorithm="finalize a cross-document navigation">
  Insert the following step into [=finalize a cross-document navigation=]'s "Otherwise" branch (where |entryToReplace| is non-null):

  1. If |historyEntry|'s [=session history entry/document state=]'s [=document state/origin=] is the [=same origin|same=] as |entryToReplace|'s [=session history entry/document state=]'s [=document state/origin=], then set |historyEntry|'s [=session history entry/navigation API key=] to |entryToReplace|'s [=session history entry/navigation API key=].
</div>

<h3 id="reactivate-patch">Reactivate</h3>

<div algorithm="reactivate patch">
  Update the [=Document/reactivate=] algorithm by adding the following step before the final top-level step which checks the current document readiness:

  1. [=Navigation/Update the entries for reactivation=] given <var ignore>document</var>'s [=relevant global object=]'s [=Window/navigation API=], <var ignore>sessionHistoryEntries</var> TODO pass this in (harder), and <var ignore>entry</var> TODO pass this in (easier).
</div>

<h3 id="reload-patch">Reload</h3>

<div algorithm="reload" id="reload-modifications">
  Modify the <a spec="HTML">reload</a> algorithm to take an optional <dfn for="reload">|navigationAPIState|</dfn> (default null) and an optional <dfn for="reload">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>"). Then, prepend the following steps:

  1. Let |navigation| be |navigable|'s [=navigable/active window=]'s [=Window/navigation API=].
  1. If both of the following are true:
    * |userInvolvement| is not "<code>[=user navigation involvement/browser UI=]</code>"
    * |navigable|'s [=navigable/active document=]'s <a spec="HTML">is initial about:blank</a> is false

    then:

      1. Let |continue| be the result of [=firing a non-traversal navigate event=] at |navigation| with <i>[=fire a non-traversal navigate event/navigationType=]</i> set to "{{NavigationType/reload}}", <i>[=fire a non-traversal navigate event/isSameDocument=]</i> set to false, <i>[=fire a non-traversal navigate event/userInvolvement=]</i> set to |userInvolvement|, <i>[=fire a non-traversal navigate event/destinationURL=]</i> set to |navigable|'s [=navigable/active document=]'s [=Document/URL=], and <i>[=fire a non-traversal navigate event/state=]</i> set to |navigationAPIState|.
      1. If |continue| is false, return.
</div>

<h3 id="traverse-patch">Traversal</h3>

Modify the [=traverse the history by a delta=] algorithm to take an optional named argument <dfn for="traverse the history by a delta"><var ignore>userInvolvement</var></dfn> (default "<code>[=user navigation involvement/none=]</code>"). Pass it along when calling [=apply the history step=], which also needs to be modified to take such a argument.

<h3 id="navigate-event-download-patches">Download a hyperlink</h3>

The current specification for <a spec="HTML" lt="download the hyperlink">downloading a hyperlink</a> has several known issues, most notably <a href="https://github.com/whatwg/html/issues/5548">whatwg/html#5548</a> which indicates that the specification should probably be merged into the general <a spec="HTML" lt="navigate">navigation</a> algorithm.

For the purposes of the navigation API, we need to fire the appropriate {{Navigation/navigate}} event, with {{NavigateEvent/downloadRequest}} set to the correct value. We could rigorously detail the ways to modify the current spec to accomplish this. But, given that the current spec will be rewritten anyway, this is probably not very useful. So until such a time as we can properly investigate and rewrite the <a spec="HTML" lt="download the hyperlink">downloading a hyperlink</a> algorithm, we describe here the expected behavior in a less-formal fashion. We believe this is still enough to get interoperability.

<div algorithm="download the hyperlink">
<ul>
  <li><p>Ensure that the algorithm gets an appropriate [=user navigation involvement=] value, |userInvolvement|, passed to it. This is similar to the modifications for the <a spec="HTML">follow the hyperlink</a> algorithm described in [[#call-site-patch-userinvolvement]]. One key difference is that, for the case where the user indicates a preference for downloading, |userInvolvement| must be "<code>[=user navigation involvement/browser UI=]</code>", even if it is triggered as part of [=EventTarget/activation behavior=].

  <li><p>Separate out the sandboxing checks in <a spec="HTML">allowed to download</a> from the user-safeguarding checks. If the sandboxing checks fail, then the user agent must not fire a {{Navigation/navigate}} event. Whereas, the user-safeguarding checks generally happen later, probably [=in parallel=].

  <li>
    <p>Before we reach the point at which it's time to actually go in parallel and fetch content from the server, and after the <a spec="HTML">cannot navigate</a> check, the synchronously-possible part of the <a spec="HTML">allowed to download</a> check, the URL parsing step, and the hyperlink suffix appending step, run the equivalent of the following:

    1. If |userInvolvement| is not "<code>[=user navigation involvement/browser UI=]</code>", then:
      1. Let |navigation| be |subject|'s [=relevant global object=]'s [=Window/navigation API=].
      1. Let |filename| be the value of |subject|'s <{a/download}> attribute.
      1. Let |continue| be the result of [=firing a download-requested navigate event=] at |navigation| with <i>[=fire a download-requested navigate event/destinationURL=]</i> set to |URL|, <i>[=fire a download-requested navigate event/userInvolvement=]</i> set to |userInvolvement|, and <i>[=fire a download-requested navigate event/filename=]</i> set to |filename|.
      1. If |continue| is false, then return.

    <p>Here the variables |subject| and |URL| refer to the same things they currently do in the <a spec="HTML">download the hyperlink</a> algorithm, i.e. the <{a}> or <{area}> element in question, and the parsed [=URL=].

    <p>If we end up triggering the <a spec="HTML">navigate</a> algorithm from the <a spec="HTML">download the hyperlink</a> algorithm, then these steps won't be directly incorporated into the <a spec="HTML">download the hyperlink</a> algorithm. Instead, the modifications in [[#navigate-patch]] will get a bit more complicated, so as to use [=fire a download-requested navigate event=] with the above arguments, instead of [=fire a non-traversal navigate event=], for downloads.
</ul>
</div>

<h3 id="cancel-navigation">Canceling navigations</h3>

The navigation API introduces a new complication into canceling navigations, which is that a navigation might have been fully committed, but still be "ongoing", in the sense of [[#ongoing-state]]. That is, consider a case such as:

<xmp highlight="js">
navigation.addEventListener("navigate", e => {
  e.intercept({
    handler() {
      return new Promise(r => setTimeout(r, 1_000));
    }
  });
  e.signal.addEventListener("abort", () => { ... });
});

const p = navigation.navigate("#1");

setTimeout(() => window.stop(), 500);
</xmp>

Without the {{Navigation/navigate}} event handler, this kind of synchronous fragment navigation would be straightforward: it matures synchronously, and the {{Window/stop()}} call does nothing. But because we have used the {{Navigation/navigate}} handler to indicate that the navigation is still ongoing, we want the {{Window/stop()}} call to [=finalize with an aborted navigation error|finalize that navigation with an aborted navigation error=], in particular causing `p` to reject and the {{AbortSignal/abort}} event to fire on `e.signal`.

We thus need to add the following integrations:

* Wherever the spec currently modifies a [=navigable=] |navigable|'s [=navigable/ongoing navigation=], and thus cancels not-yet-committed navigations, we also [=inform the navigation API about canceling navigation=] in |navigable|. (Regardless of whether or not the [=navigable/ongoing navigation=] is set to a [=navigation ID=] or not.) This likely involves introducing a small abstraction around modifying the ongoing navigation.

* When <a spec="HTML">destroy the nested navigable</a> algortihm runs given a [=navigable=] |navigable|, we also [=inform the navigation API about nested navigable destruction=] given |navigable|.

It would probably be a good idea to rename [=navigable=]'s [=navigable/ongoing navigation=] concept and/or {{Navigation}} objects' [=Navigation/ongoing navigation=], to avoid the naming overlap, since they mean slightly different things.

<h3 id="navigate-event-traversal-patches">Check if unloading is user-canceled</h3>

<div algorithm="check if unloading is user-canceled">
  Modify the [=check if unloading is user-canceled=] algorithm as follows:

  To [=check if unloading is user-canceled=] given a [=list=] of [=navigables=] |navigablesCrossingDocuments|, an optional [=navigable=] |traversable|, an optional integer |targetStep| (default null), and an optional [=user navigation involvement=] |userInvolvement| (default "<code>[=user navigation involvement/none=]</code>"):
  1. Let <var ignore>unloadPromptShown</var> be false.
  1. Let |unloadPromptCanceled| be false.
  1. Let |changingNavigables| be a [=list=] of [=navigables=], initially empty.
  1. If |traversable| is not null and |targetStep| is not null, append the result of [=get all navigables whose current session history entry will change or reload=] given |traversable| and |targetStep| to |changingNavigables|.
  1. Otherwise, append |navigablesCrossingDocuments| to |changingNavigables|.
  1. Let |totalTasks| be the size of |changingNavigables|.
  1. Let |completedTasks| be 0.
  1. If |traversable| is not null and |changingNavigables| [=list/contains=] |traversable|:
    1. Let |targetEntry| be the result of [=getting the target history entry=] given |traversable| and |targetStep|.
    1. Let |isSameOrigin| be true if |targetEntry|'s [=session history entry/document state=]'s [=document state/origin=] is the [=same origin|same=] as |traversable|'s [=navigable/current session history entry=]'s [=session history entry/document state=]'s [=document state/origin=]; otherwise, false.
    1. [=Queue a global task=] on the [=navigation and traversal task source=] given |traversable|'s [=navigable/active window=] to run the following steps:
      1. If |isSameOrigin| is true:
        1. Let |navigateEventResult| be the result of [=firing a traversal navigate event=] at |traversable|'s [=navigable/active window=]'s [=Window/navigation API=] with <i>[=fire a traversal navigate event/destinationEntry=]</i> set to |targetEntry| and <i>[=fire a traversal navigate event/userInvolvement=]</i> set to |userInvolvement|.
        1. If |navigateEventResult| is false, then set |unloadPromptCanceled| to true.
      1. If |unloadPromptCanceled| is false and |navigablesCrossingDocuments| [=list/contains=] |traversable|:
        1. Run the steps to fire a beforeunload event (currently steps 6.1 thru 6.8 in the [=check if unloading is user-canceled=] steps).
      1. Increment |completedTasks|.
    1. Wait for |completedTasks| to be 1.
    1. If |unloadPromptCanceled| is true, then return "<code>refuse</code>";
  1. For each |navigable| of |changingNavigables|:
    1. If |navigable| equals |traversable|, then [=iteration/continue=].
    1. Let |targetEntry| be the result of [=getting the target history entry=] given |traversable| and |targetStep|.
    1. Let |isSameOrigin| be true if |targetEntry|'s [=session history entry/document state=]'s [=document state/origin=] is the [=same origin|same=] as |navigable|'s [=navigable/current session history entry=]'s [=session history entry/document state=]'s [=document state/origin=]; otherwise, false.
    1. [=Queue a global task=] on the [=navigation and traversal task source=] given |navigable|'s [=navigable/active window=] to run the following steps:
      1. If |isSameOrigin| is true:
        1. Let |navigateEventResult| be the result of [=firing a traversal navigate event=] at |navigable|'s [=navigable/active window=]'s [=Window/navigation API=] with <i>[=fire a traversal navigate event/destinationEntry=]</i> set to |targetEntry| and <i>[=fire a traversal navigate event/userInvolvement=]</i> set to |userInvolvement|.
        1. [=Assert=]: |navigateEventResult| is true.
      1. If |navigablesCrossingDocuments| [=list/contains=] |navigable|:
        1. Run the steps to fire a beforeunload event (currently steps 6.1 thru 6.8 in the [=check if unloading is user-canceled=] steps).
      1. Increment |completedTasks|.
  1. Wait for |completedTasks| to be |totalTasks|.
  1. Return |unloadPromptCanceled|.
</div>

<div algorithm="apply the history step">
  Modify the [=apply the history step=] algorithm as follows:

  Change step 5 (which runs the [=check if unloading is user-canceled=] steps) to:
  1. If <var ignore>checkForUserCancelation</var> is true, and the result of [=checking if unloading is user-canceled=] given <var ignore>navigablesCrossingDocuments</var>, <var ignore>traversable</var>, <var ignore>targetStep</var> and <var ignore>userInvolvement</var> is "<code>refuse</code>", then return.

(Recall that we introduced the <var ignore>userInvolvement</var> parameter as part of [[#traverse-patch]].)

  Before the update document for history step application (currently step 14.10.3), add the following step:
  1. If <var ignore>changingNavigableContinuation</var>'s [=update-only=] is true, [=maybe continue the navigate event=] given <var ignore>displayedDocument</var>'s [=relevant global object=]'s [=Window/navigation API=].

</div>

Potentially rename [=check if unloading is user-canceled=] to something like "check for unloading cancelation" to reflect that we are now allowing programmatic cancelation, not just user cancelation.

<h3 id="new-user-navigation-involvement">User navigation involvement</h3>

Introduce (right before the definition of the <a spec="HTML">navigate</a> algorithm) the concept of a <dfn>user navigation involvement</dfn>, which is one of the following:

: "<dfn for="user navigation involvement"><code>browser UI</code></dfn>"
:: The navigation was initiated by the user via browser UI mechanisms
: "<dfn for="user navigation involvement"><code>activation</code></dfn>"
:: The navigation was initiated by the user via the [=EventTarget/activation behavior=] of an element
: "<dfn for="user navigation involvement"><code>none</code></dfn>"
:: The navigation was not initiated by the user

<p class="note">This infrastructure partially solves <a href="https://github.com/whatwg/html/issues/5381">whatwg/html#5381</a>, and it'd be ideal to update the [:Sec-Fetch-Site:] spec at the same time.</p>

Define the <dfn for="Event">user navigation involvement</dfn> for an {{Event}} |event| as "<code>[=user navigation involvement/activation=]</code>" if |event|'s {{Event/isTrusted}} attribute is initialized to true, and "<code>[=user navigation involvement/none=]</code>" otherwise.

<h3 id="call-site-patch">Various call site patches</h3>

<h4 id="call-site-patch-userinvolvement">User navigation involvement</h4>

Modify the <a href="https://html.spec.whatwg.org/multipage/document-lifecycle.html#nav-traversal-ui">Browser user interface considerations</a> section to require setting [=navigate=]'s <i>[=navigate/userInvolvement=]</i>, <a spec="HTML">reload</a>'s <i>[=reload/userInvolvement=]</i>, and [=traverse the history by a delta=]'s <i>[=traverse the history by a delta/userInvolvement=]</i> all to "<code>[=user navigation involvement/browser UI=]</code>" for all operations in that section.

<hr>

Modify the <a spec="HTML">follow the hyperlink</a> algorithm to take a new <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

<div algorithm="area activation behavior">
  Modify the [=EventTarget/activation behavior=] of <{area}> elements by introducing the |event| argument and replacing the <a spec="HTML">follow the hyperlink</a> step with the following:

  1. Otherwise, <a spec="HTML">follow the hyperlink</a> created by <var ignore>element</var> with the [=Event/user navigation involvement=] for |event|.
</div>

<div algorithm="a activation behavior">
  Modify the [=EventTarget/activation behavior=] of <{a}> elements by replacing its <a spec="HTML">follow the hyperlink</a> step with the following:

  1. Otherwise, <a spec="HTML">follow the hyperlink</a> created by <var ignore>element</var> with the [=Event/user navigation involvement=] for <var ignore>event</var>.
</div>

Expand the section on "<a href="https://html.spec.whatwg.org/multipage/semantics.html#providing-users-with-a-means-to-follow-hyperlinks-created-using-the-link-element">Providing users with a means to follow hyperlinks created using the `link` element</a>" by adding the following sentence:

<blockquote><ins>Such invocations of <a spec="HTML">follow the hyperlink</a> algorithm must set the <i>[=navigate/userInvolvement=]</i> argument to "<code>[=user navigation involvement/browser UI=]</code>".</ins></blockquote>

<hr>

Modify the <a spec="HTML">plan to navigate</a> algorithm to take a <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

Modify the <a spec="HTML" lt="submitted">submit</a> algorithm to take an optional <var ignore>userInvolvement</var> argument (default "<code>[=user navigation involvement/none=]</code>").  Have the <a spec="HTML" lt="submitted">submit</a> algorithm pass along its value to all invocations of <a spec="HTML">plan to navigate</a>.

Modify the definition of the [=EventTarget/activation behavior=] for <{input}> elements to take an <var ignore>event</var> argument. Then, pass along this argument to the invocation of the <a spec="HTML">input activation behavior</a>.

Modify the Submit Button state's <a spec="HTML">input activation behavior</a> by having it take an <var ignore>event<var> argument and pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the Image Button state's <a spec="HTML">input activation behavior</a> by having it take an <var ignore>event<var> argument and pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the <{button}> element's [=EventTarget/activation behavior=] by having it take an <var ignore>event</var> argument and, in the Submit Button case, to pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the no-<a spec="HTML">submit button</a> case for <a href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#implicit-submission">implicit form submission</a> to pass along "<code>[=user navigation involvement/activation=]</code>" as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

<p class="note">The case of implicit submission when a submit button is present is automatically taken care of because it fires a (trusted) click event at the submit button.</p>

<hr>

Update the call to from [=navigate=] into [=navigate to a fragment=] to pass along <var ignore>userInvolvement</var>.

<h4 id="call-site-patch-entrylist">Form entry list</h4>

Modify the <a spec="HTML">plan to navigate</a> algorithm to take an additional optional argument <var ignore>entryList</var ignore> (default null). Then, modify the step which calls <a spec="HTML">navigate</a> to pass it along as <i>[=navigate/entryList=]</i>, in place of <var ignore>cspNavigationType</var>.

Modify the <a spec="HTML">submit as entity body</a> algorithm to pass <var ignore>entry list</var> along to <a spec="HTML">plan to navigate</a> as a second argument.

<h3 id="focus-patches">Focus tracking</h3>

To support the {{NavigationInterceptOptions/focusReset}} option, the following patches need to be made:

Update the <a spec="HTML">focusing steps</a> to, right before they call the <a spec="HTML">focus update steps</a>, set the {{Document}}'s [=relevant global object=]'s [=Window/navigation API=]'s [=Navigation/focus changed during ongoing navigation=] to true.

Update the <a spec="HTML">focus fixup rule</a> to additionally set the {{Document}}'s [=relevant global object=]'s [=Window/navigation API=]'s [=Navigation/focus changed during ongoing navigation=] to false.

<p class="note">In combination, these ensure that the [=Navigation/focus changed during ongoing navigation=] reflects any developer- or user-initiated focus changes, unless they were undone by the focus fixup rule. For example, if the user moved focus to an element which was removed from the DOM while the promise returned from a handler passed to {{NavigateEvent/intercept()}} was settling, then that would not count as a focus change.

<h3 id="scroll-restoration-patches">Scroll restoration</h3>

To support the {{NavigationInterceptOptions/scroll}} option, as well as to fix <a href="https://github.com/whatwg/html/issues/7517">whatwg/html#7517</a>, the following patches need to be made:

Add a boolean, <dfn for="Document">has been scrolled by the user</dfn>, initially false, to {{Document}} objects. State that if the user scrolls the document, the user agent must set that document's [=Document/has been scrolled by the user=] to true. Modify the [=Document/unload|unload a document=] algorithm to set this back to false.

<div algorithm>
  Define the process of <dfn>restoring scroll position data</dfn> given a [=session history entry=] |entry| as follows:

  1. Let |document| be |entry|'s [=session history entry/document=].
  1. If |document|'s [=Document/has been scrolled by the user=] is true, then the user agent should return.
  1. The user agent should attempt to use |entry|'s [=session history entry/scroll position data=] to restore the scroll positions of |document|'s <a spec="HTML">restorable scrollable regions</a>. The user agent may continue to attempt to do so periodically, until |document|'s [=Document/has been scrolled by the user=] becomes true.

     <p class="note">This is formulated as an <em>attempt</em>, which is potentially repeated until success or until the user scrolls, due to the fact that relevant content indicated by the [=session history entry/scroll position data=] might take some time to load from the network.

     <p class="note">Scroll restoration might be affected by scroll anchoring. [[CSS-SCROLL-ANCHORING-1]]
</div>

<div algorithm="restore persisted state">
  With this in place, modify the <a spec="HTML">restore persisted state</a> algorithm's first step to read as follows:

  1. If |entry|'s [=session history entry/scroll restoration mode=] is "{{ScrollRestoration/auto}}", and |entry|'s [=session history entry/document=]'s [=relevant global object=]'s [=Window/navigation API=]'s [=Navigation/suppress normal scroll restoration during ongoing navigation=] is false, then [=restore scroll position data=] given |entry|.

  In addition to the existing note, add the following one:

  <p class="note">If the [=Navigation/suppress normal scroll restoration during ongoing navigation=] boolean is true, then [=restoring scroll position data=] might still happen at a later point, as part of [=potentially process scroll behavior|potentially processing scroll behavior=] for the relevant {{Navigation}} object, or via a {{NavigateEvent/scroll()|navigateEvent.scroll()}} method call.
</div>

<h3 id="new-failed-populate-note">Helpful note: failed attempt to populate</h3>

Inside [=apply the history step=], expand the note which currently says

<blockquote>
  <p>This means we tried to populate the document, but were unable to do so, e.g. because of the server returning a 204.
</blockquote>

to instead say:

<div class="note">
  <p>This means we tried to populate the document, but were unable to do so, e.g. because of the server returning a 204.

  <p>These kinds of failed navigations or traversals will not be signaled to the navigation API (e.g., through the promises of any [=Navigation/ongoing navigation=], or the {{NavigationTransition/finished|navigation.transition.finished}} promise, or the {{Navigation/navigateerror}} event). Doing so would leak information about the timing of responses from other origins, in the cross-origin case, and providing different results in the cross-origin versus same-origin cases was deemed too confusing.

  <p>However, implementations could use this opportunity to clear any promise handlers for the {{NavigationTransition/finished|navigation.transition.finished}} promise, as they are guaranteed at this point to never run. And, they might wish to [=report a warning to the console=] if any part of the navigation API initiated these navigations, to make it clear to the web developer the reason why their promises will never settle and events will never fire.
</div>

<h2 id="security-privacy">Security and privacy considerations</h2>

<div nonnormative>

<h3 id="sp-cross-site-tracking">Cross-site tracking</h3>

This specification does not enable any new cross-site tracking capabilities. This is largely because the {{Navigation/entries()|navigation.entries()}} method only returns information about the same-origin, same-frame history entries.

In more detail:

* The storage of [=session history entry/navigation API state=] in session history entries is a convenience with no tracking abilities, since the state is only accessible same-origin. That is, it provides the same power as APIs such as <a href="https://github.com/privacycg/storage-partitioning">partitioned</a> {{WindowSessionStorage/sessionStorage}}.
* The browser-generated UUIDs stored as [=session history entry/navigation API ID=] and [=session history entry/navigation API key=] live only for the lifetime of a browsing session; they are not stable user-specific identifiers, and in particular are not the same across different frames.

<h3 id="sp-navigation-monitoring-interception">Navigation monitoring and interception</h3>

Through the {{Navigation/navigate}} event, this API allows web developers to monitor navigations, and in some cases replace cross-document navigations with same-document ones, or prevent the navigation from going through.

Care has been taken to avoid this being dangerous, or giving insight into user behavior that would not otherwise be available to the site. In particular:

* It is not possible to prevent a back/forward navigation, as this could lead to trapping the user on the page. (We would like to make this possible in the future by adding additional security mitigations; see <a href="https://github.com/WICG/navigation-api/issues/32">#32</a>.)

* Navigations initiated from cross-origin-domain frames do not fire {{Navigation/navigate}} events. An example would be such a frame calling `window.open(url, name)` with `name` targeting the current frame.

* Navigations initiated using browser UI, apart from back/forward navigations or fragment-only navigations, do not fire {{Navigation/navigate}} events. An example would be the user directly editing the URL bar.

We also have a few more restrictions worth noting, which don't directly address any attack, but reduce the surface area and complexity of the navigation interception feature, which can have indirect security benefits:

* Navigations initiated toward non-[=fetch scheme=] URLs, such as `javascript:` URLs, do not fire {{Navigation/navigate}} events.

* Navigations initiated on the initial `about:blank` document do not fire {{Navigation/navigate}} events.

* Navigations initiated by {{Document/open(unused1, unused2)|document.open()}} do not fire {{Navigation/navigate}} events.

* Cross-document traversals cannot be intercepted and converted into same-document traversals.

<h3 id="sp-url-updates">URL updates</h3>

This API, like {{History/pushState()|history.pushState()}} and {{History/replaceState()|history.replaceState()}}, gives the ability to change what is shown in the browser's URL bar. This is part of the navigation interception capability mentioned in the previous section.

This is not dangerous, because the navigation API is subject to the same restrictions as the classic history API: namely, the page's URL can only be changed if the page <a spec="HTML">can have its URL rewritten</a> to the new URL. So in particular no authority-granting components, such as the site or origin, are impacted.

<h3 id="sp-ua-ui">Other user agent UI</h3>

This specification does not add any requirements on how user agents implement their user interfaces. (Even the URL bar updates mentioned in the previous section are not technically part of the specification; the specification only governs the return value of other APIs, like {{Location/href|location.href}}.) This preserves the ability for user agents to protect users through UI changes.

For example, today some user agents take advantage of this flexibility to skip certain history entries when pressing the back button. This can be used to avoid back-trapping by abusive sites, by skipping entries with which the user did not interact and thus allowing the user to escape abusive sites faster.

The navigation API preserves all of these freedoms.

</div>
