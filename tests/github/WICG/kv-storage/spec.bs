<pre class="metadata">
Title: KV Storage
Shortname: kv-storage
Repository: WICG/kv-storage
Inline Github Issues: true
Group: WICG
Status: CG-DRAFT
Level: 1
URL: https://wicg.github.io/kv-storage/
Boilerplate: omit conformance, omit feedback-header
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: This specification details a high level asynchronous key/value storage API, layered on top of IndexedDB, and as a spiritual successor to the original <span class="non-normative">{{Window/localStorage}}</span>.
!Participate: <a href="https://github.com/WICG/kv-storage">GitHub WICG/kv-storage</a> (<a href="https://github.com/WICG/kv-storage/issues/new">new issue</a>, <a href="https://github.com/WICG/kv-storage/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/kv-storage/commits/master/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
</pre>

<pre class="anchors">
url: https://html.spec.whatwg.org/multipage/webstorage.html#dom-localstorage; type: attribute; text: localStorage; for: Window; spec: HTML

urlPrefix: https://tc39.github.io/ecma262/#; spec: ECMASCRIPT
  text: Map; url: sec-map-objects; type: interface
  text: WeakMap; url: sec-weakmap-objects; type: interface
  text: Date; url: sec-date-objects; type: interface
  text: ToString; url: sec-tostring; type: abstract-op
  text: %IteratorPrototype%; url: sec-%iteratorprototype%-object; type: interface
  text: %ObjectPrototype%; url: sec-properties-of-the-object-prototype-object; type: interface
  text: CreateDataProperty; url: sec-createdataproperty; type: abstract-op
  text: CreateBuiltinFunction; url: sec-createbuiltinfunction; type: abstract-op
  text: CreateMethodProperty; url: sec-createmethodproperty; type: abstract-op
  text: CreateArrayFromList; url: sec-createarrayfromlist; type: abstract-op
  text: CreateIterResultObject; url: sec-createiterresultobject; type: abstract-op
  text: NormalCompletion; url: sec-normalcompletion; type: abstract-op
  text: ObjectCreate; url: sec-objectcreate; type: abstract-op
  text: ThrowCompletion; url: sec-throwcompletion; type: abstract-op
  text: Construct; url: sec-construct; type: abstract-op
  text: Type; url: sec-ecmascript-data-types-and-values; type: abstract-op
  text: IsArray; url: sec-isarray; type: abstract-op
  text: SetIntegrityLevel; url: sec-setintegritylevel; type: abstract-op
  text: current Realm; url: current-realm; type: dfn
  text: typed array; url: sec-typedarray-objects; type: dfn
  text: Completion Record; url: sec-completion-record-specification-type; type: dfn
  text: @@asyncIterator; url: table-1; type: dfn

urlPrefix: https://tc39.github.io/Function-prototype-toString-revision/#; spec: FN-TOSTRING
  text: HostHasSourceTextAvailable; url: proposal-sec-hosthassourcetextavailable; type: abstract-op

urlPrefix: https://w3c.github.io/IndexedDB/; spec: INDEXEDDB-2; type: dfn
  text: convert a value to a key
  text: convert a key to a value
  text: close a database connection
  text: unbounded key range
  text: transaction; url: #transaction-concept
  text: connection; for: database; url: #connection
  text: index; url: #index-concept
  for: request
    text: result; url: #request-result
    text: error; url: #request-error
  for: transaction
    text: error; url: #transaction-error
  for: connection
    text: object store set; url: #connection-object-store-set
  for: key
    text: ascending; url: #greater-than
  for: object store
    text: key generator; url: #key-generator
    text: key path; url: #object-store-key-path
    text: name; url: #object-store-name
</pre>

<pre class="link-defaults">
  spec: promises-guide; type: dfn; text: resolve
  spec: infra; type: dfn; text: list
</pre>

<pre class="biblio">
{
  "CLASS-FIELDS": {
    "authors": [
      "Daniel Ehrenberg",
      "Jeff Morrison"
    ],
    "href": "https://tc39.github.io/proposal-class-fields/",
    "title": "Public and private instance fields proposal"
  },
  "JSSTDLIB": {
    "href": "https://github.com/tc39/proposal-javascript-standard-library/",
    "title": "Standard Library Proposal"
  }
}
</pre>

<style>
.selected-text-file-an-issue {
  position: fixed;
  bottom: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.8);
  font-size: smaller;
  padding: 4px 10px;
  z-index: 4;
}

summary {
  cursor: pointer;
}

/* domintro from https://resources.whatwg.org/standard.css */
dl.domintro {
  position: relative;
  color: green;
  background: #DDFFDD;
  margin: 2.5em 0 2em 0;
  padding: 1.5em 1em 0.5em 2em;
}

dl.domintro dt, dl.domintro dt * {
  color: black;
  font-size: inherit;
}
dl.domintro dd {
  margin: 0.5em 0 1em 2em; padding: 0;
}
dl.domintro dd p {
  margin: 0.5em 0;
}
dl.domintro::before {
  content: 'For web developers (non-normative)';
  background: green;
  color: white;
  padding: 0.15em 0.25em;
  font-style: normal;
  position: absolute;
  top: -0.8em;
  left: -0.8em;
}
</style>

<script src="https://resources.whatwg.org/file-issue.js" async></script>


<h2 id="intro">Introduction</h2>

<div class="non-normative">

<em>This section is non-normative.</em>

The {{Window/localStorage}} API is widely used, and loved for its simplicity. However, its synchronous nature leads to <a href="https://hacks.mozilla.org/2012/03/there-is-no-simple-solution-for-local-storage/">terrible performance</a> and cross-window synchronization issues.

This specification proposes a new API, called KV storage, which is intended to provide an analogously simple interface, while being asynchronous. Along the way, it embraces some additional goals:

* <strong>Layer on top of Indexed Database.</strong> This avoids introducing a new type of storage for user agents and web developers to manage, and allows an upgrade path to full IndexedDB usage if a web developer outgrows the KV storage interface. [[INDEXEDDB-2]]

* <strong>Modernize the API surface.</strong> Modern key/value stores in the platform, such as the {{Cache}} or {{Headers}} APIs, have aligned around the operation names given by JavaScript's {{Map}}. We follow their example. As a bonus, this allows us to avoid the legacy [=named properties=] feature that the {{Storage}} interface uses.

* <strong>Support isolated storage areas.</strong> {{Window/localStorage}} requires careful namespacing of keys to use robustly in a multi-actor environment. Popular libraries meant to replace it, like <a href="https://localforage.github.io/localForage/">localForage</a>, have included a way to create new storage areas beyond the default one.

* <strong>Be a built-in module.</strong> There are a variety of reason to support expanding the web's API surface via built-in modules, instead of built-in globals. We want KV storage to be one of the earliest of these, and are in active collaboration with the authors of the <cite>Standard Library Proposal</cite> to be grounded in their work. [[JSSTDLIB]]

<div class="example" id="example-from-html-spec">
  A conversion of <a href="https://html.spec.whatwg.org/multipage/webstorage.html#introduction-15">the HTML Standard's <code>localStorage</code> example</a> to use KV storage might look like the following:

  <xmp highlight="html">
    <p>
      You have viewed this page
      <span id="count">an untold number of</span>
      time(s).
    </p>
    <script type="module">
      import { storage } from "std:kv-storage";

      (async () => {
        let pageLoadCount = await storage.get("pageLoadCount") || 0;
        ++pageLoadCount;

        document.querySelector("#count").textContent = pageLoadCount;

        await storage.set("pageLoadCount", pageLoadCount);
      })();
    </script>
  </xmp>

  As a side note, observe how, in contrast to the original example which performs up to five storage operations, our example only performs two. Also, it updates the UI as soon as possible, instead of delaying the UI update until we've set the new page load count.

  The KV storage API design can take some credit for this, as by forcing us to explicitly state our <code>await</code> points, it makes it more obvious that we're performing a potentially-expensive storage operation.
</div>

</div>


<h2 id="module">The <code>std:kv-storage</code> built-in module</h2>

<dl class="domintro non-normative" id="module-domintro">
  <dt><code>import * as |kvs| from "std:kv-storage"</code>
  <dd>
    <p>Imports the KV storage API's namespace object as the variable |kvs|.

    <p>If the module is not imported in a [=secure context=], the <code>import</code> statement will cause a "{{SecurityError}}" {{DOMException}}, as persistent storage is a powerful feature.
  </dd>

  <dt><code>|kvs|.[=std:kv-storage/storage=]</code>
  <dd>
    <p>Returns the default storage area. It is a pre-constructed instance of the {{StorageArea}} class, meant to be a convenience similar to {{Window/localStorage}}.
  </dd>

  <dt><code>|kvs|.[=std:kv-storage/StorageArea=]</code>
  <dd>
    <p>Returns the constructor for the {{StorageArea}} class, to allow the creation of isolated storage areas.
  </dd>
</dl>

This specification defines a new built-in module. Tentatively, depending on further discussions, we use the specifier "<dfn><code>std:kv-storage</code></dfn>" to denote it for now. This is not final and is subject to change depending on the details of how built-in modules end up working. [[JSSTDLIB]]

Its exports are the following:

: <dfn for="std:kv-storage"><code>storage</code></dfn>
:: An instance of the {{StorageArea}} class, created as if by [$Construct$]({{StorageArea}}, « "<code>default</code>" »).
: <dfn for="std:kv-storage"><code>StorageArea</code></dfn>
:: The {{StorageArea}} class

<div class="example" id="example-importing">
  To get access to these exports, one could use the syntax shown <a href="#module-domintro">above</a>, or import them directly without the intermediate |kvs| variable:

  <xmp highlight="js">
    import { storage, StorageArea } from "std:kv-storage";
  </xmp>
</div>

In addition to establishing its exports, evaluating the module must perform the following steps:

1. If the [=current settings object=] is not [$Is an environment settings object contextually secure?|contextually secure$], throw a "{{SecurityError}}" {{DOMException}}.


<h2 id="storagearea" interface lt="StorageArea">The <code>StorageArea</code> class</h2>

Upon evaluating the <a><code>std:kv-storage</code></a> module, the {{StorageArea}} class must be created in the [=current realm=]. The result must be equivalent to evaluating the following JavaScript code, with the following two exceptions:

<ul>
  <li><p>The constructor, method, and getter bodies must behave as specified below instead of being the no-ops shown in this code block.</p></li>
  <li id="fn-tostring-censorship"><p>[$HostHasSourceTextAvailable$] must return false for all function objects (i.e. the constructor, methods, and getter) created.</p></li>
</ul>

<pre highlight="js">
  class StorageArea {
    constructor(name)  { /* <a href="#storagearea-constructor">see below</a> */ }

    set(key, value)    { /* <a href="#storagearea-set">see below</a> */ }
    get(key)           { /* <a href="#storagearea-get">see below</a> */ }
    delete(key)        { /* <a href="#storagearea-delete">see below</a> */ }
    clear()            { /* <a href="#storagearea-clear">see below</a> */ }

    keys()             { /* <a href="#storagearea-keys">see below</a> */ }
    values()           { /* <a href="#storagearea-values">see below</a> */ }
    entries()          { /* <a href="#storagearea-entries">see below</a> */ }

    get backingStore() { /* <a href="#storagearea-backingstore">see below</a> */ }
  }
</pre>

The <code>prototype</code> property of {{StorageArea}} must additionally have a [=@@asyncIterator=] property, whose value is equal to the same function object as the original value of <code>StorageArea.prototype.entries()</code>.

<div class="note" id="class-definition-explanation">
  <p>The intention of defining the {{StorageArea}} class in this way, using a skeleton JavaScript class definition, is to automatically establish the various properties of the class, its methods, and its getter, which otherwise need to be specified in tedious detail. For example, this automatically establishes the <code>length</code> and <code>name</code> properties of all these functions, their property descriptors, their <code>prototype</code> and <code>constructor</code> properties, etc. And it does so in a way that is consistent with what a JavaScript developer would expect.

  <details>
    <summary>Why not use Web IDL?</summary>

    Apart from the above novel technique, there are two commonly-seen alternatives for defining JavaScript classes. The JavaScript specification, as well as the Streams Standard, defer to the "<a href="https://tc39.github.io/ecma262/#sec-ecmascript-standard-built-in-objects">ECMAScript Standard Built-in Objects</a>" section of the JavaScript specification, which defines many defaults. The more popular alternative, however, is to use Web IDL. Why aren't we using that?

    Web IDL has a few minor mismatches with our goals for built-in modules:

    * Its automatically-generated brand checks are both unforgeable and cross-realm, which is not accomplishable in JavaScript. [=StorageArea/brand check|Our brand checks=] are same-realm-only, as we would like built-in modules to not have special privileges in this regard over non-built-in ones.

    * It does not have a mechanism for exposing classes inside modules; instead they are always exposed on some set of global objects.

    * It produces methods and accessors that are enumerable, which does not match the natural JavaScript implementation. This would make it more difficult to implement a Web IDL-specified built-in module in JavaScript. (But not impossible.)

    * The generic nature of Web IDL means that it is best implemented using code generation. However, most implementers currently do not have a Web IDL bindings generator that wraps JavaScript; using Web IDL would virtually require them to either implement the built-in modules in C++, or create such a bindings generator. Furthermore, the wrappers end up being quite large; see <a href="https://gist.github.com/domenic/b5c395e036781173e123">an example</a>. <!-- TODO: maybe make an actual generated StorageArea example -->

    None of these mismatches are fatal. We could switch this specification to Web IDL, with appropriate extensions for solving the first two problems, if that ends up being desired. We recognize that the goals for built-in modules are still under active discussion, and the above might not end up being important in the end. But for now, we're experimenting with this different—and more aligned-with-JavaScript-modules—mechanism of specifying a class definition.
  </details>
</div>

Each {{StorageArea}} instance must also contain the <dfn>\[[DatabaseName]]</dfn>, <dfn>\[[DatabasePromise]]</dfn>, and <dfn>\[[BackingStoreObject]]</dfn> internal slots. The following is a non-normative summary of their meaning:

<dl class="non-normative">
  <dt>[=[[DatabaseName]]=]
  <dd>A string containing the name of the backing IndexedDB database.
  <dt>[=[[DatabasePromise]]=]
  <dd>A promise for an {{IDBDatabase}} object, lazily initialized when [=perform a database operation|performing any database operation=].
  <dt>[=[[BackingStoreObject]]=]</dt>
  <dd>The object returned by the {{StorageArea/backingStore}} getter, cached to ensure identity across gets.</dd>
</dl>

A JavaScript value |val| <dfn for="StorageArea">brand checks</dfn> as a {{StorageArea}} if [$Type$](|val|) is Object, |val| has a [=[[DatabaseName]]=] internal slot, and |val|'s [=relevant realm=] is equal to the [=current realm=].

<p class="note">The realm check here gives us semantics identical to using JavaScript's {{WeakMap}} or the proposed private class fields. This ensures {{StorageArea}} does not use any magic, like the platform's usual cross-realm brand checks, which go beyond what can be implemented in JavaScript. [[ECMA-262]] [[CLASS-FIELDS]]

<h3 id="storagearea-constructor" constructor for="StorageArea" lt="constructor(name)">constructor(|name|)</h3>

<dl class="domintro non-normative">
  <dt><code>|storage| = new {{StorageArea/constructor(name)|StorageArea}}(|name|)</code>
  <dd>
    <p>Creates a new {{StorageArea}} that provides an async key/value store view onto an IndexedDB database named <code>`kv-storage:${name}`</code>.

    <p>This does not actually open or create the database yet; that is done lazily when other methods are called. This means that all other methods can reject with database-related exceptions in failure cases.
</dl>

<div class="algorithm">
  1. Let |area| be this {{StorageArea}} object.
  1. Let |nameString| be [$ToString$](|name|).
  1. Set |area|.[=[[DatabaseName]]=] to the concatenation of "<code>kv-storage:</code>" and |nameString|.
  1. Set |area|.[=[[DatabasePromise]]=] to null.
  1. Set |area|.[=[[BackingStoreObject]]=] to null.
</div>

<h3 id="storagearea-set" method for="StorageArea">set(|key|, |value|)</h3>

<dl class="domintro non-normative">
  <dt><code>await |storage|.{{StorageArea/set()|set}}(|key|, |value|)</code>
  <dd>
    <p>Asynchronously stores the given |value| so that it can later be retrieved by the given |key|.

    <p>Keys have to follow the same restrictions as IndexedDB keys: roughly, a key can be a number, string, array, {{Date}}, {{ArrayBuffer}}, {{DataView}}, [=typed array=], or an array of these. Invalid keys will cause the returned promise to reject with a "{{DataError}}" {{DOMException}}.

    <p>Values can be any value that can be [$StructuredSerializeForStorage|structured-serialized for storage$]. Un-serializable values will cause a "{{DataCloneError}}" {{DOMException}}. The value undefined will cause the corresponding entry to be deleted.

    <p>The returned promise will fulfill with undefined on success.
</dl>

<div class="algorithm">
  1. If |key| is not [=allowed as a key=], return [=a promise rejected with=] a "{{DataError}}" {{DOMException}}.
  1. Return the result of [=performing a database operation=] given this object, "<code>readwrite</code>", and the following steps operating on |transaction| and |store|:
    1. If |value| is undefined, then
      1. Perform the steps listed in the description of {{IDBObjectStore}}'s {{IDBObjectStore/delete()}} method on |store|, given the argument |key|.
    1. Otherwise,
      1. Perform the steps listed in the description of {{IDBObjectStore}}'s {{IDBObjectStore/put()}} method on |store|, given the arguments |value| and |key|.
    1. Let |promise| be [=a new promise=].
    1. [=Add a simple event listener=] to |transaction| for "<code>complete</code>" that [=resolves=] |promise| with undefined.
    1. [=Add a simple event listener=] to |transaction| for "<code>error</code>" that [=rejects=] |promise| with |transaction|'s [=transaction/error=].
    1. [=Add a simple event listener=] to |transaction| for "<code>abort</code>" that [=rejects=] |promise| with |transaction|'s [=transaction/error=].
    1. Return |promise|.
</div>

<h3 id="storagearea-get" method for="StorageArea">get(|key|)</h3>

<dl class="domintro non-normative">
  <dt><code>|value| = await |storage|.{{StorageArea/get()|get}}(|key|)</code>
  <dd>
    <p>Asynchronously retrieves the value stored at the given |key|, or undefined if there is no value stored at |key|.

    <p>Values retrieved will be [$StructuredDeserialize|structured-deserialized$] from their original form.
</dl>

<div class="algorithm">
  1. If |key| is not [=allowed as a key=], return [=a promise rejected with=] a "{{DataError}}" {{DOMException}}.
  1. Return the result of [=performing a database operation=] given this object, "<code>readonly</code>", and the following steps operating on |transaction| and |store|:
    1. Let |request| be the result of performing the steps listed in the description of {{IDBObjectStore}}'s {{IDBObjectStore/get()}} method on |store|, given the argument |key|.
    1. Let |promise| be [=a new promise=].
    1. [=Add a simple event listener=] to |request| for "<code>success</code>" that [=resolves=] |promise| with |request|'s [=request/result=].
    1. [=Add a simple event listener=] to |request| for "<code>error</code>" that [=rejects=] |promise| with |request|'s [=request/error=].
    1. Return |promise|.
</div>

<h3 id="storagearea-delete" method for="StorageArea">delete(|key|)</h3>

<dl class="domintro non-normative">
  <dt><code>await |storage|.{{StorageArea/delete()|delete}}(|key|)</code>
  <dd>
    <p>Asynchronously deletes the entry at the given |key|. This is equivalent to |storage|.{{StorageArea/set()|set}}(|key|, undefined).

    <p>The returned promise will fulfill with undefined on success.
</dl>

<div class="algorithm">
  1. If |key| is not [=allowed as a key=], return [=a promise rejected with=] a "{{DataError}}" {{DOMException}}.
  1. Return the result of [=performing a database operation=] given this object, "<code>readwrite</code>", and the following steps operating on |transaction| and |store|:
    1. Perform the steps listed in the description of {{IDBObjectStore}}'s {{IDBObjectStore/delete()}} method on |store|, given the argument |key|.
    1. Let |promise| be [=a new promise=].
    1. [=Add a simple event listener=] to |transaction| for "<code>complete</code>" that [=resolves=] |promise| with undefined.
    1. [=Add a simple event listener=] to |transaction| for "<code>error</code>" that [=rejects=] |promise| with |transaction|'s [=transaction/error=].
    1. [=Add a simple event listener=] to |transaction| for "<code>abort</code>" that [=rejects=] |promise| with |transaction|'s [=transaction/error=].
    1. Return |promise|.
</div>

<h3 id="storagearea-clear" method for="StorageArea">clear()</h3>

<dl class="domintro non-normative">
  <dt><code>await |storage|.{{StorageArea/clear()|clear}}()</code>
  <dd>
    <p>Asynchronously deletes all entries in this storage area.

    <p>This is done by actually deleting the underlying IndexedDB database. As such, it always can be used as a fail-safe to get a clean slate, <a href="#clear-recover-from-changes">as shown below</a>.

    <p>The returned promise will fulfill with undefined on success.
</dl>

<div class="algorithm">
  1. Let |area| be this object.
  1. If |area| does not [=StorageArea/brand check=], return [=a promise rejected with=] a {{TypeError}} exception.
  1. If |area|.[=[[DatabasePromise]]=] is not null, return the result of [=transforming=] |area|.[=[[DatabasePromise]]=] by fulfillment and rejection handlers that both perform the following steps:
    1. Set |area|.[=[[DatabasePromise]]=] to null.
    1. Return the result of [=deleting the database=] given by |area|.[=[[DatabaseName]]=].
  1. Otherwise, return the result of [=deleting the database=] given by |area|.[=[[DatabaseName]]=].
</div>

To <dfn lt="deleting the database|delete the database">delete the database</dfn> given a string |name|:

<div class="algorithm">
  1. Let |promise| be [=a new promise=].
  1. Let |request| be the result of performing the steps listed in the description of {{IDBFactory}}'s {{IDBFactory/deleteDatabase()}} method on the <a>current <code>IDBFactory</code></a>, given the argument |name|.
  1. If those steps threw an exception, catch the exception and [=reject=] |promise| with it.
  1. Otherwise:
    1. [=Add a simple event listener=] to |request| for "<code>success</code>" that [=resolves=] |promise| with undefined.
    1. [=Add a simple event listener=] to |request| for "<code>error</code>" that [=rejects=] |promise| with |request|'s [=request/error=].
  1. Return |promise|.
</div>

<div class="example" id="clear-recover-from-changes">
  This method can be used to recover from unexpected modifications to the backing store. For example,

  <xmp highlight="js">
    // This upgrade to version 100 breaks the "cats" storage area: since StorageAreas
    // assume a version of 1, "cats" can no longer be used with KV storage.
    const openRequest = indexedDB.open("kv-storage:cats", 100);
    openRequest.onsuccess = () => {
      openRequest.onsuccess.close();
    };

    (async () => {
      const area = new StorageArea("cats");

      // Due to the above upgrade, all other methods will reject:
      try {
        await area.set("fluffy", new Cat());
      } catch (e) {
        // This will be reached and output a "VersionError" DOMException
        console.error(e);
      }

      // But clear() will delete the database entirely:
      await area.clear();

      // Now we can use it again!
      await area.set("fluffy", new Cat());
      await area.set("tigger", new Cat());

      // Also, the version is back down to 1:
      console.assert(area.backingStore.version === 1);
    })();
  </xmp>
</div>

<h3 id="storagearea-keys" method for="StorageArea">keys()</h3>

<dl class="domintro non-normative">
  <dt><code>for await (const |key| of |storage|.{{StorageArea/keys()|keys}}()) { ... }</code>
  <dd>
    <p>Retrieves an async iterator containing the keys of all entries in this storage area.

    <p>Keys will be yielded in [=key/ascending=] order; roughly, segregated by type, and then sorted within each type. They will be [=key round-tripped=] from their original form.

    <p>The iterator provides a live view onto the storage area: modifications made to entries sorted after the last-returned one will be reflected in the iteration.
</dl>

<div class="algorithm">
  1. Let |area| be this object.
  1. If |area| does not [=StorageArea/brand check=], throw a {{TypeError}} exception.
  1. Return the result of [=creating a storage area async iterator=] given |area| and "<code>keys</code>".
</div>

<div class="example" id="example-live-async-iterator">
  To illustrate the live nature of the async iterator, consider the following:

  <xmp highlight="js">
    await storage.set(10, "value 10");
    await storage.set(20, "value 20");
    await storage.set(30, "value 30");

    const keysSeen = [];
    for await (const key of storage.keys()) {
      if (key === 20) {
        await storage.set(15, "value 15");
        await storage.delete(20);
        await storage.set(25, "value 25");
      }
      keysSeen.push(key);
    }

    console.log(keysSeen);   // logs 10, 20, 25, 30
  </xmp>

  That is, calling {{StorageArea/keys()}} does not create a snapshot as of the time it was called; it returns a live asynchronous iterator, that lazily retrieves the next key after the last-seen one.
</div>

<h3 id="storagearea-values" method for="StorageArea">values()</h3>

<dl class="domintro non-normative">
  <dt><code>for await (const |value| of |storage|.{{StorageArea/values()|values}}()) { ... }</code>
  <dd>
    <p>Asynchronously retrieves an array containing the values of all entries in this storage area.

    <p>Values will be ordered as corresponding to their keys; see {{StorageArea/keys()}}. They will be [$StructuredDeserialize|structured-deserialized$] from their original form.

    <p>The iterator provides a live view onto the storage area: modifications made to entries sorted after the last-returned one will be reflected in the iteration.
</dl>

<div class="algorithm">
  1. Let |area| be this object.
  1. If |area| does not [=StorageArea/brand check=], throw a {{TypeError}} exception.
  1. Return the result of [=creating a storage area async iterator=] given |area| and "<code>values</code>".
</div>

<h3 id="storagearea-entries" method for="StorageArea">entries()</h3>

<dl class="domintro non-normative">
  <dt><code>for await (const [|key|, |value|] of |storage|.{{StorageArea/entries()|entries}}()) { ... }</code>
  <dt><code>for await (const [|key|, |value|] of |storage|) { ... }</code>
  <dd>
    <p>Asynchronously retrieves an array of two-element <code>[key, value]</code> arrays, each of which corresponds to an entry in this storage area.

    <p>Entries will be ordered as corresponding to their keys; see {{StorageArea/keys()}}. Each key and value will be [=key round-tripped=] and [$StructuredDeserialize|structured-deserialized$] from its original form, respectively.

    <p>The iterator provides a live view onto the storage area: modifications made to entries sorted after the last-returned one will be reflected in the iteration.
</dl>

<div class="algorithm">
  1. Let |area| be this object.
  1. If |area| does not [=StorageArea/brand check=], throw a {{TypeError}} exception.
  1. Return the result of [=creating a storage area async iterator=] given |area| and "<code>entries</code>".
</div>

<div class="example" id="example-entries-to-server">
  Assuming you knew that that you only stored JSON-compatible types in <code>[=storage=]</code>, you could use the following code to send all locally-stored entries to a server:

  <xmp highlight="js">
    const entries = [];
    for await (const entry of storage.entries()) {
      entries.push(entry);
    }

    fetch("/storage-receiver", {
      method: "POST",
      body: entries,
      headers: {
        "Content-Type": "application/json"
      }
    });
  </xmp>
</div>

<h3 id="storagearea-backingstore" attribute for="StorageArea" lt="backingStore">get backingStore()</h3>

<dl class="domintro non-normative">
  <dt><code>{ |database|, |store|, |version| } = |storage|.{{StorageArea/backingStore}}</code>
  <dd>
    <p>Asynchronously retrieves an an object containing all of the information necessary to manually interface with the IndexedDB backing store that underlies this storage area:

    * |database| will be a string equal to "<code>kv-storage:</code>" concatenated with the database name passed to the constructor. (For the default storage area, it will be "<code>kv-storage:default</code>".)
    * |store| will be the string "<code>store</code>".
    * |version| will be the number 1.

    <p>It is good practice to use the {{StorageArea/backingStore}} property to retrieve this information, instead of memorizing the above factoids.
</dl>

<div class="algorithm">
  1. Let |area| be this object.
  1. If |area| does not [=StorageArea/brand check=], throw a {{TypeError}} exception.
  1. If |area|.[=[[BackingStoreObject]]=] is null, then:
    1. Let |backingStoreObject| be [$ObjectCreate$]({{%ObjectPrototype%}}).
    1. Perform [$CreateDataProperty$](|backingStoreObject|, "<code>database</code>", |area|.[=[[DatabaseName]]=]).
    1. Perform [$CreateDataProperty$](|backingStoreObject|, "<code>store</code>", "<code>store</code>").
    1. Perform [$CreateDataProperty$](|backingStoreObject|, "<code>version</code>", 1).
    1. Perform [$SetIntegrityLevel$](|backingStoreObject|, "<code>frozen</code>").
    1. Set |area|.[=[[BackingStoreObject]]=] to |backingStoreObject|.
  1. Return |area|.[=[[BackingStoreObject]]=].
</div>

<div class="example" id="example-backingstore">
  Consider a checklist application, which tracks the Pokémon a user has collected. It might use <code>[=std:kv-storage/storage=]</code> like so:

  <xmp highlight="js">
    bulbasaur.onchange = () => storage.set("bulbasaur", bulbasaur.checked);
    ivysaur.onchange = () => storage.set("ivysaur", ivysaur.checked);
    venusaur.onchange = () => storage.set("venusaur", venusaur.checked);
    // ...
  </xmp>

  (Hopefully the developer quickly realizes that the above will be hard to maintain, and refactors the code into a loop. But in the meantime, their repetitive code makes for a good example, so let's take advantage of that.)

  The developer now realizes they want to add an evolution feature, e.g. for when the user transforms their Bulbasaur into an Ivysaur. They might first implement this like so:

  <xmp highlight="js">
    bulbasaurEvolve.onclick = async () => {
      await storage.set("bulbasaur", false);
      await storage.set("ivysaur", true);
    };
  </xmp>

  However, our developer starts getting bug reports from their users: if the users happen to open up the checklist app in a second tab while they're evolving in the first tab, the second tab will sometimes see that their Bulbasaur has disappeared, without ever turning into an Ivysaur! A Pokémon has gone missing!

  The solution here is to step beyond the comfort zone of KV storage, and start using the full power of IndexedDB: in particular, its [=transactions=] feature. The {{StorageArea/backingStore}} getter is the gateway to this world:

  <xmp highlight="js">
    const { database, store, version } = storage.backingStore;
    const request = indexedDB.open(database, version);
    request.onsuccess = () => {
      const db = request.result;

      bulbasaurEvolve.onclick = () => {
        const transaction = db.transaction(store, "readwrite");
        const store = transaction.objectStore(store);

        store.put("bulbasaur", false);
        store.put("ivysaur", true);

        db.close();
      };
    };
  </xmp>

  Satisfied with their web app's Pokémon integrity, our developer is now happy and fulfilled. (At least, until they realize that none of their code has error handling.)
</div>

<h2 id="async-iterator">The storage area async iterator</h2>

<p class="note">Much of this section is amenable to being generalized into a reusable primitive, probably via Web IDL. See <a href="https://github.com/heycam/webidl/issues/580">heycam/webidl#580</a>.</p>

Upon evaluating the <a><code>std:kv-storage</code></a> module, let <dfn>the storage area async iterator prototype object</dfn> be object obtained via the following steps executed in the [=current realm=]:

1. Let |proto| be [$ObjectCreate$]({{%IteratorPrototype%}}).
1. Let |next| be [$CreateBuiltinFunction$](the steps of [[#storageareaasynciterator-next]]).
1. Perform [$CreateMethodProperty$](|proto|, "<code>next</code>", |next|).
1. Return |proto|.

<h3 id="async-iterator-create">Creation</h3>

To <dfn lt="create a storage area async iterator|creating a storage area async iterator">create a storage area async iterator</dfn>, given a {{StorageArea}} |area| and a string |mode| which is one of either "<code>keys</code>", "<code>values</code>", or "<code>entries</code>":

1. Let |iter| be [$ObjectCreate$]([=the storage area async iterator prototype object=], « <dfn>\[[Area]]</dfn>, <dfn>\[[Mode]]</dfn>, <dfn>\[[LastKey]]</dfn>, <dfn>\[[OngoingPromise]]</dfn> »).
1. Set |iter|.[=[[Area]]=] to |area|.
1. Set |iter|.[=[[Mode]]=] to |mode|.
1. Set |iter|.[=[[LastKey]]=] to [=not yet started=].
1. Set |iter|.[=[[OngoingPromise]]=] to undefined.
1. Return |iter|.

The following is a non-normative summary of the internal slots that get added to objects created in such a way:

<dl class="non-normative">
  <dt>[=[[Area]]=]
  <dd>A pointer back to the originating {{StorageArea}}, used so that the async iterator can [=perform a database operation|perform database operations=].

  <dt>[=[[Mode]]=]
  <dd>One of "<code>keys</code>", "<code>values</code>", or "<code>entries</code>", indicating the types of values that iteration will retrieve from the storage area.

  <dt>[=[[LastKey]]=]
  <dd>The key of the entry that was most recently iterated over, used to perform the next iteration. Or, if {{the storage area async iterator prototype object/next()}} has not yet been called, it will be set to [=not yet started=].

  <dt>[=[[OngoingPromise]]=]
  <dd>A reference to the promise that was returned by the most recent call to {{the storage area async iterator prototype object/next()}}, if that promise has not yet settled, or undefined if it has. Used to prevent concurrent executions of the main [=get the next IterResult=] algorithm, which would be bad because that algorithm needs to complete in order for [=[[LastKey]]=] to be set correctly.
</dl>

<h3 id="storageareaasynciterator-next" method for="the storage area async iterator prototype object" lt="next()">next()</h3>

1. Let |iter| be this object.
1. If [$Type$](|iter|) is not Object, or |iter|'s [=relevant realm=] is not equal to the [=current realm=], or |iter| does not have a \[[Area]] internal slot, then return [=a promise rejected with=] a {{TypeError}} exception.
1. Let |currentOngoingPromise| be |iter|.[=[[OngoingPromise]]=].
1. Let |resultPromise| be undefined.
1. If |currentOngoingPromise| is not undefined, then set |resultPromise| to the result of [=transforming=] |currentOngoingPromise| by the result of [=getting the next IterResult=] given |iter|.
1. Otherwise, set |resultPromise| to the result of [=getting the next IterResult=] given |iter|.
1. Set |iter|.[=[[OngoingPromise]]=] to |resultPromise|.
1. Return |resultPromise|.

To <dfn lt="get the next IterResult|getting the next IterResult">get the next IterResult</dfn> given |iter|:

1. Return the result of [=performing a database operation=] given |iter|.[=[[Area]]=], "<code>read</code>", and the following steps operating on |transaction| and |store|:
  1. Let |lastKey| be |iter|.[=[[LastKey]]=].
  1. If |lastKey| is undefined, then return [$CreateIterResultObject$](undefined, true).
  1. Let |range| be the result of [=getting the range for=] |lastKey|.
  1. Let |key| and |iterResultValue| be null.
  1. Let |promise| be [=a new promise=].
  1. Switch on |iter|.[=[[Mode]]=]:
    <dl class="switch">
      <dt>"<code>keys</code>"</dt>
      <dd>
        1. Let |request| be the result of performing the steps listed in the description of {{IDBObjectStore}}'s {{IDBObjectStore/getKey()}} method on |store|, given the argument |range|.
        1. [=Add a simple event listener=] to |request| for "<code>success</code>" that performs the following steps:
          1. Set |key| to |request|'s [=request/result=].
          1. Set |iterResultValue| to |key|.
          1. [=Finish up=].
        1. [=Add a simple event listener=] to |request| for "<code>error</code>" that [=rejects=] |promise| with |request|'s [=request/error=].
      </dd>
      <dt>"<code>values</code>"</dt>
      <dd>
        1. Let |keyRequest| be the result of performing the steps listed in the description of {{IDBObjectStore}}'s {{IDBObjectStore/getKey()}} method on |store|, given the argument |range|.
        1. Let |valueRequest| be the result of performing the steps listed in the description of {{IDBObjectStore}}'s {{IDBObjectStore/get()}} method on |store|, given the argument |range|.
        1. [=Add a simple event listener=] to |valueRequest| for "<code>success</code>" that performs the following steps:
          1. Set |key| to |keyRequest|'s [=request/result=].
          1. Set |iterResultValue| to |valueRequest|'s [=request/result=].
          1. [=Finish up=].
        1. [=Add a simple event listener=] to |keyRequest| for "<code>error</code>" that [=rejects=] |promise| with |keyRequest|'s [=request/error=].
        1. [=Add a simple event listener=] to |valueRequest| for "<code>error</code>" that [=rejects=] |promise| with |valueRequest|'s [=request/error=].
      </dd>
      <dt>"<code>entries</code>"</dt>
      <dd>
        1. Let |keyRequest| be the result of performing the steps listed in the description of {{IDBObjectStore}}'s {{IDBObjectStore/getKey()}} method on |store|, given the argument |range|.
        1. Let |valueRequest| be the result of performing the steps listed in the description of {{IDBObjectStore}}'s {{IDBObjectStore/get()}} method on |store|, given the argument |range|.
        1. [=Add a simple event listener=] to |valueRequest| for "<code>success</code>" that performs the following steps:
          1. Set |key| to |keyRequest|'s [=request/result=].
          1. Let |value| be |valueRequest|'s [=request/result=].
          1. Set |iterResultValue| to [$CreateArrayFromList$](« |key|, |value| »).
          1. [=Finish up=].
        1. [=Add a simple event listener=] to |keyRequest| for "<code>error</code>" that [=rejects=] |promise| with |keyRequest|'s [=request/error=].
        1. [=Add a simple event listener=] to |valueRequest| for "<code>error</code>" that [=rejects=] |promise| with |valueRequest|'s [=request/error=].
      </dd>
    </dl>

    When the above steps say to <dfn>finish up</dfn>, which they will do after having set |key| and |iterResultValue| appropriately, perform the following steps:
      1. Set |iter|.[=[[LastKey]]=] to |key|.
      1. Set |iter|.[=[[OngoingPromise]]=] to undefined.
      1. Let |done| be true if |key| is undefined, and false otherwise.
      1. [=Resolve=] |promise| with [$CreateIterResultObject$](|iterResultValue|, |done|).
  1. Return |promise|.

<h2 id="supporting">Supporting operations and concepts</h3>

To <dfn>add a simple event listener</dfn>, given an {{EventTarget}} |target|, an event type string |type|, and a set of steps |steps|:

<div class="algorithm">
  1. Let |jsCallback| be a new JavaScript function object, created in the [=current realm=], that performs the steps given by |steps|. Other properties of the function (such as its <code>name</code> and <code>length</code> properties, or \[[Prototype]]) are unobservable, and can be chosen arbitrarily.
  1. Let |idlCallback| be the result of [=converted to an IDL value|converting=] |jsCallback| to an {{EventListener}}.
  1. Perform the steps listed in the description of {{EventTarget}}'s {{EventTarget/addEventListener()}} method on |target| given the arguments |type| and |idlCallback|.
</div>

The <dfn>current <code>IDBFactory</code></dfn> is the {{IDBFactory}} instance returned by the following steps:

<div class="algorithm">
  1. Assert: the [=current global object=] [=includes=] {{WindowOrWorkerGlobalScope}}.
  1. Return the result of performing the steps listed in the description of the getter for {{WindowOrWorkerGlobalScope}}'s {{WindowOrWorkerGlobalScope/indexedDB}} attribute on the [=current global object=].
</div>

To <dfn lt="performing a database operation|perform a database operation">perform a database operation</dfn> given a {{StorageArea}} |area|, a mode string |mode|, and a set of steps |steps| that operate on an {{IDBTransaction}} |transaction| and an {{IDBObjectStore}} |store|:

<div class="algorithm">
  1. If |area| does not [=StorageArea/brand check=], return [=a promise rejected with=] a {{TypeError}} exception.
  1. Assert: |area|.[=[[DatabaseName]]=] is a string (and in particular is not null).
  1. If |area|.[=[[DatabasePromise]]=] is null, [=initialize the database promise=] for |area|.
  1. Return the result of [=transforming=] |area|.[=[[DatabasePromise]]=] by a fulfillment handler that performs the following steps, given |database|:
    1. Let |transaction| be the result of performing the steps listed in the description of {{IDBDatabase}}'s {{IDBDatabase/transaction()}} method on |database|, given the arguments "<code>store</code>" and |mode|.
    1. Let |store| be the result of performing the steps listed in the description of {{IDBTransaction}}'s {{IDBTransaction/objectStore()}} method on |transaction|, given the argument "<code>store</code>".
    1. Return the result of performing |steps|, passing along |transaction| and |store|.
</div>

To <dfn>initialize the database promise</dfn> for a {{StorageArea}} |area|:

<div class="algorithm">
  1. Set |area|.[=[[DatabasePromise]]=] to [=a new promise=].
  1. If the [=current global object=] does not [=include=] {{WindowOrWorkerGlobalScope}}, [=reject=] |area|.[=[[DatabasePromise]]=] with a {{TypeError}}, and return.
  1. Let |request| be the result of performing the steps listed in the description of {{IDBFactory}}'s {{IDBFactory/open()}} method on the <a>current <code>IDBFactory</code></a>, given the arguments |area|.[=[[DatabaseName]]=] and 1.
  1. If those steps threw an exception, catch the exception, [=reject=] |area|.[=[[DatabasePromise]]=] with it, and return.
  1. [=Add a simple event listener=] to |request| for "<code>success</code>" that performs the following steps:
    1. Let |database| be |request|'s [=request/result=].
    1. [=Check the database schema=] for |database|. If the result is false, [=reject=] |area|.[=[[DatabasePromise]]=] with an "{{InvalidStateError}}" {{DOMException}} and abort these steps.
    1. [=Add a simple event listener=] to |database| for "<code>close</code>" that sets |area|.[=[[DatabasePromise]]=] to null.
      <p class="note">This means that if the database is [=close a database connection|closed abnormally=], future invocations of [=perform a database operation=] will attempt to reopen it.</p>
    1. [=Add a simple event listener=] to |database| for "<code>versionchange</code>" that performs the steps listed in the description of {{IDBDatabase}}'s {{IDBDatabase/close()}} method on |database|, and then sets |area|.[=[[DatabasePromise]]=] to null.
        <p class="note">This allows attempts to upgrade the underlying database, or to delete it (e.g. via the {{StorageArea/clear()}} method), to succeed. Without this, if two {{StorageArea}} instances were both open referencing the same underlying database, {{StorageArea/clear()}} would hang, as it only closes the connection maintained by the {{StorageArea}} it is invoked on.</p>
    1. [=Resolve=] |promise| with |database|.
  1. [=Add a simple event listener=] to |request| for "<code>error</code>" that [=rejects=] |promise| with |request|'s [=request/error=].
  1. [=Add a simple event listener=] to |request| for "<code>upgradeneeded</code>" that performs the following steps:
    1. Let |database| be |request|'s [=request/result=].
    1. Perform the steps listed in the description of {{IDBDatabase}}'s {{IDBDatabase/createObjectStore()}} method on |database|, given the arguments "<code>store</code>".
    1. If these steps throw an exception, catch the exception and [=reject=] |area|.[=[[DatabasePromise]]=] with it.
</div>

To <dfn>check the database schema</dfn> for an {{IDBDatabase}} |database|:

<div class="algorithm">
  1. Let |objectStores| be |database|'s [=database/connection=]'s [=connection/object store set=].
  1. If |objectStores|'s [=set/size=] is not 1, return false.
  1. Let |store| be |objectStores|[0].
  1. If |store|'s [=object store/name=] is not "<code>store</code>", return false.
  1. If |store| has a [=object store/key generator=], return false.
  1. If |store| has a [=object store/key path=], return false.
  1. If any [=indexes=] reference |store|, return false.
  1. Return true.
</div>

<p class="note">[=Check the database schema=] only needs to be called in the initial setup algorithm, [=initialize the database promise=], since once the database connection has been opened, the schema cannot change.</p>

A value |value| is <dfn>allowed as a key</dfn> if the following steps return true:

<div class="algorithm">
  1. If [$Type$](|value|) is Number or String, return true.
  1. If [$IsArray$](|value|) is true, return true.
  1. If |value| has a \[[DateValue]] internal slot, return true.
  1. If |value| has a \[[ViewedArrayBuffer]] internal slot, return true.
  1. If |value| has an \[[ArrayBufferByteLength]] internal slot, return true.
  1. Return false.
</div>

<div class="note">
  A value being [=allowed as a key=] means that it can at least plausibly be used as a key in the IndexedDB APIs. In particular, the values which are [=allowed as a key=] are a subset of those for which IndexedDB's [=convert a value to a key=] algorithm will succeed.

  Most notably, using the [=allowed as a key=] predicate ensures that {{IDBKeyRange}} objects, or any other special object that is accepted as a query in future IndexedDB specification revisions, will be disallowed. Only straightforward key values are accepted by the KV storage API.
</div>

<dfn lt="key round-trip">Key round-tripping</dfn> refers to the way in which JavaScript values are processed by first being passed through IndexedDB's [=convert a value to a key=] operation, then converted back through its [=convert a key to a value=] operation. Keys returned by the {{StorageArea/keys()}} or {{StorageArea/entries()}} methods will have gone through this process.

Notably, any [=typed arrays=] or {{DataView}}s will have been "unwrapped", and returned back as just {{ArrayBuffer}}s containing the same bytes. Also, similar to the [$StructuredSerializeForStorage|structured-serialization$]/[$StructuredDeserialize|deserialization$] process, any "expando" properties or other modifications will not be preserved by [=key round-tripping=].

<p class="note">For primitive string or number values, there's no need to worry about [=key round-tripping=]; the values are indistinguishable.</p>

To <dfn lt="get the range for a key|getting the range for|getting the range for a key">get the range for a key</dfn> |key|:

1. If |key| is [=not yet started=], then return the result of performing the steps listed in the description of the {{IDBKeyRange/lowerBound(lower)|IDBKeyRange.lowerBound()}} static method, given the argument &minus;Infinity.
   <p class="note">The intent here is to get an [=unbounded key range=], but this is the closest thing we can get that is representable as an {{IDBKeyRange}} object. It works equivalently for our purposes, but will behave incorrectly if Indexed DB ever adds keys that sort below &minus;Infinity. See <a href="https://github.com/WICG/kv-storage/issues/6#issuecomment-452054944">some discussion on potential future improvements</a>.</p>
1. Otherwise, return the result of performing the steps listed listed in the description of the {{IDBKeyRange/lowerBound(lower, lowerOpen)|IDBKeyRange.lowerBound()}} static method, given the arguments |lastKey| and true.

The special value <dfn>not yet started</dfn> can be taken to be any JavaScript value that is not equal to any other program-accessible JavaScript value (but is equal to itself). It is used exclusively as an argument to the [=get the range for a key=] algorithm.

<p class="example" id="example-not-yet-started">A newly created object or symbol, e.g. <code highlight="js">const nys = {}</code> or <code highlight="js">const nys = Symbol()</code>, would satisfy this definition.</code></p>

<h2 id="perfect-polyfill">Appendix: is this API perfectly layered?</h2>

The APIs in this specification, being layered on top of Indexed DB as they are, are almost entirely well-layered, in the sense of building on low-level features in the way promoted by the <cite>Extensible Web Manifesto</cite>. (Indeed, the <a href="#class-definition-explanation">unusual class definition pattern</a> was motivated by a desire to further improve this layering.) However, it fails in two ways, both around ensuring the encapsulation of the implementation: [[EXTENSIBLE]]

* By <a href="#fn-tostring-censorship">requiring censorship</a> of the output of <code>Function.prototype.toString()</code> for the functions produced. See <a href="https://github.com/drufball/layered-apis/issues/7">drufball/layered-apis#7</a>.

* By directly invoking the algorithms of various IDL operations and attributes, instead of going through the global, potentially-overridable JavaScript APIs. (E.g., in various algorithm steps that say "performing the steps listed in the description of", or the [=allowed as a key=] algorithm which uses [$IsArray$] directly instead of going through <code>Array.isArray()</code>.) See <a href="https://github.com/drufball/layered-apis/issues/6">drufball/layered-apis#6</a>.

Eventually we hope to introduce the ability for web authors to write code that gets these same benefits, instead of locking them up so that only web platform APIs like KV storage can achieve this level of encapsulation. That's a separate effort, however, which is best followed in the above-linked issue threads.

<h2 id="acks" class="no-num">Acknowledgments</h2>

The editor would like to thank
Andrew Sutherland,
Kenneth Rohde Christiansen,
Jake Archibald,
Jan Varga,
Joshua Bell, and
Victor Costan
for their contributions to this specification.

<h2 id="conformance" class="no-num">Conformance</h2>

This specification depends on the Infra Standard. [[!INFRA]]
