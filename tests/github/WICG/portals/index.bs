<pre class="metadata">
Title: Portals
Shortname: portals
Level: 1
Status: CG-DRAFT
Group: WICG
URL: https://wicg.github.io/portals/
Editor: Jeremy Roman, Google, jbroman@chromium.org
Abstract: This specification defines a mechanism that allows for rendering of, and seamless navigation to, embedded content.
Repository: https://github.com/WICG/portals/
Markup Shorthands: css no, markdown yes
Assume Explicit For: yes
WPT Path Prefix: /portals/
WPT Display: inline
</pre>
<pre class="anchors">
spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: attribute
        urlPrefix: comms.html
            text: origin; for: MessageEvent; url: dom-messageevent-origin
            text: source; for: MessageEvent; url: dom-messageevent-source
            text: ports; for: MessageEvent; url: dom-messageevent-ports
            text: data; for: MessageEvent; url: dom-messageevent-data
    type: dfn
        urlPrefix: browsers.html
            text: browsing context group; url: browsing-context-group
            text: create a new top-level browsing context; url: creating-a-new-top-level-browsing-context
        urlPrefix: browsing-the-web.html
            text: prompt to unload; url: prompt-to-unload-a-document
            text: unload; url: unload-a-document
            text: reserved environment; for: navigation params; url: navigation-params-reserved-environment
            text: request; for: navigation params; url: navigation-params-request
        urlPrefix: common-dom-interfaces.html
            text: limited to only known values; url: limited-to-only-known-values
            text: reflect; url: reflect
        urlPrefix: history.html
            text: session history; url: session-history
        urlPrefix: parsing.html
            text: completely loaded; url: completely-loaded
        urlPrefix: urls-and-fetching.html
            text: parse a URL; url: parse-a-url
            text: resulting URL record; url: resulting-url-record
            text: valid non-empty URL potentially surrounded by spaces; url: valid-non-empty-url-potentially-surrounded-by-spaces
        urlPrefix: window-object.html
            text: close a browsing context; url: close-a-browsing-context
            text: discard a browsing context; url: a-browsing-context-is-discarded
spec: ecma-262; urlPrefix: http://tc39.github.io/ecma262/
    type: dfn
        text: agent; url: sec-agents
        text: promise; url: sec-promise-objects
</pre>

<details class="annoying-warning">
  <summary>This spec is behind the explainer</summary>

  <p>This specification document has not yet been updated to reflect the 2020-04 updates to
  <a href="https://github.com/WICG/portals#readme">the explainer</a>. We'll fix that as soon as we
  can, but please be aware that there are probably contradictions, and the explainer should be taken
  as more authoritative for the time being.</p>
</details>

<section class="non-normative">
  Introduction {#intro}
  =====================

  *This section is non-normative.*

  This specification extends [[HTML]] to define a new kind of [=top-level browsing context=],
  which can be embedded in another document, and a mechanism for replacing the contents of another
  top-level browsing context with the previously embedded context.

  It is structured as a series of patches to HTML and other specifications, with each major section
  indicating where each it would be placed in the event of eventual graduation from incubation.

  See also the <a href="https://github.com/WICG/portals">explainer</a> for more background and
  motivation.
</section>

<section>
  Portal browsing contexts {#concepts}
  ====================================

  <em>The following section would be added as a new sub-section of [[HTML]]'s
  <a href="https://html.spec.whatwg.org/#windows">Browsing contexts</a> section.</em>

  Every [=browsing context=] has a <dfn>portal state</dfn>, which may be "`none`" (the default), "`portal`" or "`orphaned`".
  A [=nested browsing context=] always has the [=portal state=] "`none`".

  <div class="note">
    Briefly, these correspond to:

    * "`portal`": top-level browsing contexts embedded in a <{portal}> element
    * "`orphaned`": top-level browsing contexts which have run {{HTMLPortalElement/activate}}
        but have not (yet) been [=adopt the predecessor browsing context|adopted=]
    * "`none`": all other browsing contexts

    <!-- https://docs.google.com/drawings/d/1uh-YiJIqf8OTV0JfJ9TPPK1V0vy0T39b8hECj1I7emg/edit?usp=sharing -->
    <img src="portals-state-transitions.svg" width="881" height="392" style="width: 100%" alt="Diagram of portal state transitions">

    A top-level "`none`" context can become "`orphaned`" by [=activate a portal browsing context|activating=]
    another context. An "`orphaned`" context can be [=adopt the predecessor browsing context|adopted=] to
    become a "`portal`" context. A "`portal`" context can become a "`none`" context by being
    [=activate a portal browsing context|activated=] by its [=host browsing context=].

    A browsing context can be [=close a browsing context|closed=] while in any of these states.
  </div>

  A <dfn>portal browsing context</dfn> is a [=browsing context=] whose [=portal state=] is "`portal`".

  The <dfn>host element</dfn> of a [=portal browsing context=] is a <{portal}>
  element which embeds its rendered output and receives messages sent from the
  portal browsing context.

  <div class="note">
    A <{portal}> element may only be a [=host element=] while it is
    [=browsing-context connected=] or during the dispatch of the
    {{Window/portalactivate!!event}} event from which it was obtained
    using {{PortalActivateEvent/adoptPredecessor()}}.
  </div>

  The <dfn>host browsing context</dfn> of a [=portal browsing context=] is its
  [=host element=]'s [=Node/node document=]'s [=browsing context=].

  The <dfn>portal task source</dfn> is a [=task source=] used for tasks related to the
  portal lifecycle and communication between a [=portal browsing context=] and its [=host browsing context=].

  <section algorithm="portal-browsing-context-activate">
    To <dfn>activate a portal browsing context</dfn> |successorBrowsingContext| in
    place of |predecessorBrowsingContext| with [=origin=] |sourceOrigin|, optional data
    |serializeWithTransferResult|, and optional promise |promise|, run the following steps [=in parallel=]:

    1. [=Assert=]: The [=portal state=] of |predecessorBrowsingContext| is "`none`".

    1. If |successorBrowsingContext|'s only entry in its [=session history=] is the initial
        `about:blank` {{Document}}, then wait until either this is no longer true, or
        |successorBrowsingContext|'s [=host element=] becomes null.

        <p class="note">This means that the initial load is still happening in
        |successorBrowsingContext|. We wait for it to complete, either successfully or
        unsuccessfully, before continuing.</p>

    1. If |successorBrowsingContext|'s [=host element=] is null, then:

        1. [=Queue a global task=] on the [=portal task source=] given
            |predecessorBrowsingContext|'s [=browsing context/active window=] to [=reject=]
            |promise| with an "{{InvalidStateError}}" {{DOMException}}.

        1. Return.

    1. Set the [=host element=] of |successorBrowsingContext| to null.

        User agents *should*, however, attempt to preserve the rendering of the
        guest browsing context until |predecessorBrowsingContext| has been replaced
        with |successorBrowsingContext| in the rendering.

        Note: This is intended to avoid a visual glitch, such as a "white flash", where
        the guest browsing context briefly disappears.

    1. Set the [=portal state=] of |predecessorBrowsingContext| to "`orphaned`".

    1. Update the user interface to replace |predecessorBrowsingContext| with |successorBrowsingContext|
        (e.g., by updating the tab/window contents and browser chrome).

    1. Let |successorWindow| be |successorBrowsingContext|'s associated {{WindowProxy}}'s \[[Window]] internal slot value.

    1. [=Queue a global task=] on the [=portal task source=] given |successorWindow| to run the
        following steps:

        1. [=Assert=]: The [=portal state=] of |successorBrowsingContext| is "`portal`".

        1. Set the [=portal state=] of |successorBrowsingContext| to "`none`".

        1. Let |targetRealm| be |successorWindow|'s [=global object/realm=].

        1. Let |dataClone| be null.

        1. If |serializeWithTransferResult| is given and |successorBrowsingContext|'s [=active document=]'s
            [=Document/origin=] is [=same origin=] with |sourceOrigin|, then:

            1. Let |deserializeRecord| be
                [$StructuredDeserializeWithTransfer$](|serializeWithTransferResult|, |targetRealm|),
                and set |dataClone| to |deserializeRecord|.\[[Deserialized]].

                If this throws an exception, catch it and do nothing.

        1. Let |event| be the result of [=creating an event=] using {{PortalActivateEvent}} and |targetRealm|.

        1. Initialize |event|'s {{Event/type}} attribute to {{Window/portalactivate!!event}}.

        1. Initialize |event|'s {{PortalActivateEvent/data}} attribute to |dataClone|.

        1. Set |event|'s [=PortalActivateEvent/predecessor browsing context=] to |predecessorBrowsingContext|.

        1. Set |event|'s [=PortalActivateEvent/successor window=] to |successorWindow|.

        1. Set |event|'s [=PortalActivateEvent/activation promise=] to |promise|, if it is given, and null otherwise.

        1. [=Dispatch=] |event| to |successorWindow|.

        1. Let |adoptedPredecessorElement| be |event|'s [=PortalActivateEvent/adopted predecessor element=].

        1. If |adoptedPredecessorElement| is not null, then:

            1. Set |adoptedPredecessorElement|'s [=HTMLPortalElement/just-adopted flag=] to false.

            1. If |adoptedPredecessorElement| [=may have a guest browsing context|may not have a guest browsing context=] and
                its [=HTMLPortalElement/guest browsing context=] is not null, then [=discard a browsing context|discard=] it.

                <div class="note">
                  This unceremoniously [=discard a browsing context|discards=]
                  the browsing context, as if the element had been removed from
                  the document after previously being attached. This is
                  distinct from the case where the predecessor was never
                  adopted, below, which [=close a browsing context|closes=] the
                  browsing context. Closing [=unload|unloads=] the predecessor's
                  document, somewhat similarly to if it had performed an ordinary
                  navigation.

                  Typically authors would not call
                  {{PortalActivateEvent/adoptPredecessor()}} unless they intend
                  to insert it into the document before the [=HTMLPortalElement/just-adopted flag=]
                  becomes false.
                </div>

        1. Otherwise:

            1. If |promise| is given, [=queue a global task=] on the [=portal task source=] given
                |predecessorBrowsingContext|'s [=browsing context/active window=] to resolve
                |promise| with undefined.

            1. [=Close a browsing context|Close=] |predecessorBrowsingContext|.

                The user agent *should not* ask the user for confirmation during the
                [=prompt to unload=] step (and so the browsing context should be
                [=discard a browsing context|discarded=]).

                <div class="note">
                  Authors should not expect the {{Window/unload!!event}} event
                  to be dispatched consistently following portal activation. In
                  addition to adoption of the predecessor, where the predecessor
                  would not be [=unload|unloaded=] at all, the predecessor could
                  also enter bfcache (back forward cache) where the unload event
                  would not be dispatched.
                </div>
                <div class="issue">
                  Determine how to treat unload/beforeunload handlers. See
                  <a href="https://github.com/WICG/portals/issues/225">issue #225</a>
                  for discussion.
                </div>
  </section>

  <wpt>
    portal-activate-event.html
    portals-host-hidden-after-activation.html
  </wpt>

  <div class="issue">
    In the case that structured deserialization throws, it may be useful to do something else to indicate it,
    rather than simply providing null data.
  </div>

  <div class="issue">
    We need to specify how the [=session history=] of each browsing context is
    affected by activation, and supply non-normative text that explains how
    these histories are expected to be presented to the user.
  </div>

  <section algorithm="portal-browsing-context-adopt-predecessor">
    To <dfn>adopt the predecessor browsing context</dfn> |predecessorBrowsingContext| in |successorWindow|, run the following steps:

    1. Let |document| be the [=associated Document|document=] of |successorWindow|.

    1. Let |portalElement| be the result of [=creating an element=] given |document|, `portal`, and the [=HTML namespace=].

    1. Set |portalElement|'s [=HTMLPortalElement/just-adopted flag=] to true.

    1. [=Assert=]: |portalElement| is an {{HTMLPortalElement}}.

    1. [=Queue a global task=] on the [=portal task source=] given |predecessorBrowsingContext|'s
        [=browsing context/active window=] to run the following steps:

        1. [=Assert=]: The [=portal state=] of |predecessorBrowsingContext| is "`orphaned`".

        1. Set the [=portal state=] of |predecessorBrowsingContext| to "`portal`", and
            set the [=host element=] of |predecessorBrowsingContext| to |portalElement|.

    1. Return |portalElement|.
  </section>

  <div class="note">
    Since the task to set the [=portal state=], and thus expose the
    {{PortalHost}} object, is queued first, and from the same [=task source=],
    it is exposed at the time the [=PortalActivateEvent/activation promise=] returned from
    {{HTMLPortalElement/activate(options)}} is resolved.

    <xmp highlight="javascript">
    // In the successor document.
    onportalactivate = event => {
      // The predecessor document is adopted into a <portal> element...
      document.body.appendChild(event.adoptPredecessor());
    });

    // In the predecessor document.
    portalElement.activate().then(() => {
      // ...and it is guaranteed to observe that change by the time the
      // activation promise resolves.
      console.assert(window.portalHost instanceof PortalHost);
    });
    </xmp>
  </div>
</section>

<section>
  The `portal` element {#the-portal-element}
  ==========================================

  <em>The following section would be added as a new subsection of [[HTML]]'s
  <a href="https://html.spec.whatwg.org/#embedded-content">Embedded content</a> section.</em>

  A <dfn element>portal</dfn> element allows for a [=portal browsing context=] to be embedded in an HTML document.

  <wpt>
    portals-rendering.html
  </wpt>

  A <{portal}> element |portalElement| has a <dfn for="HTMLPortalElement">guest
  browsing context</dfn>, which is the [=portal browsing context=] whose [=host
  element=] is |portalElement|, or null if no such browsing context exists.

  A <{portal}> element has a <dfn for="HTMLPortalElement">just-adopted
  flag</dfn>, which is a [=boolean=] and is initially false. It is set during
  dispatch of the {{Window/portalactivate!!event}} event.

  The <dfn element-attr for="portal">src</dfn> attribute gives the [=URL=] of a
  page that the [=HTMLPortalElement/guest browsing context=] is to contain. The attribute, if
  present, must be a [=valid non-empty URL potentially surrounded by spaces=].

  The <dfn element-attr for="portal">referrerpolicy</dfn> attribute is a [=referrer policy attribute=].
  Its purpose is to set the [=referrer policy=] used when
  [=set the source URL of a portal element|setting the source URL of a portal element=]. [[REFERRER-POLICY]]

  <p class="note">
    A <{portal}> is similar to an <{iframe}>, in that it allows another
    browsing context to be embedded.  However, the [=portal browsing context=]
    hosted by a <{portal}> is part of a separate [=browsing context group=],
    and thus a separate [=agent=].  The user agent therefore uses a
    separate [=agent/event loop=] for the browsing contexts, even if they are [=same
    origin-domain=].
  </p>

  <xmp class="idl">
      [Exposed=Window]
      interface HTMLPortalElement : HTMLElement {
          [HTMLConstructor] constructor();

          [CEReactions] attribute USVString src;
          [CEReactions] attribute DOMString referrerPolicy;

          [NewObject] Promise<undefined> activate(optional PortalActivateOptions options = {});
          undefined postMessage(any message, optional StructuredSerializeOptions options = {});

          attribute EventHandler onmessage;
          attribute EventHandler onmessageerror;
      };

      dictionary PortalActivateOptions : StructuredSerializeOptions {
          any data;
      };
  </xmp>

  <wpt>
    portals-api.html
    idlharness.window.js
  </wpt>

  The <dfn attribute for="HTMLPortalElement">src</dfn> IDL attribute must [=reflect=] the <{portal/src}> content attribute.

  The <dfn attribute for="HTMLPortalElement">referrerPolicy</dfn> IDL attribute must [=reflect=] the <{portal/referrerpolicy}> content attribute, [=limited to only known values=].

  <section algorithm="htmlportalelement-activate">
    The <dfn method for="HTMLPortalElement"><code>activate(|options|)</code></dfn> method *must* run these steps:

    1. Let |portalBrowsingContext| be the [=HTMLPortalElement/guest browsing context=] of [=this=].

    1. If |portalBrowsingContext| is null, throw an "{{InvalidStateError}}" {{DOMException}}.

        <wpt>
          portals-activate-no-browsing-context.html
        </wpt>

    1. Let |predecessorBrowsingContext| be the [=Document/browsing context=] of
        [=this=]'s [=Node/node document=].

    1. If |predecessorBrowsingContext| is null, throw an "{{InvalidStateError}}" {{DOMException}}.

    1. If the [=portal state=] of |predecessorBrowsingContext| is not "`none`",
        throw an "{{InvalidStateError}}" {{DOMException}}.

        Note: This means that a <{portal}> element inside a [=portal browsing context=]
        cannot be activated.

    1. Let |serializeWithTransferResult| be
        [$StructuredSerializeWithTransfer$](|options|["{{PortalActivateOptions/data}}"],
        |options|["{{StructuredSerializeOptions/transfer}}"]).
        Rethrow any exceptions.

    1. Let |promise| be a new [=promise=].

    1. Let |sourceOrigin| be [=this=]'s [=relevant settings object=]'s
        [=environment settings object/origin=].

    1. Run the steps to [=activate a portal browsing context|activate=] |portalBrowsingContext|
        in place of |predecessorBrowsingContext| with |sourceOrigin|, |serializeWithTransferResult|,
        and |promise|.

    1. Return |promise|.

    <wpt>
      portal-activate-data.html
      portals-activate-inside-iframe.html
      portals-activate-inside-portal.html
      portals-activate-resolution.html
      portals-activate-twice.html
    </wpt>
  </section>

  <section algorithm="htmlportalelement-postmessage">
    The <dfn method for="HTMLPortalElement"><code>postMessage(|message|, |options|)</code></dfn> method *must* run these steps:

    1. Let |portalBrowsingContext| be the [=HTMLPortalElement/guest browsing context=] of [=this=].

    1. If |portalBrowsingContext| is null, throw an "{{InvalidStateError}}" {{DOMException}}.

    1. Let |sourceOrigin| be [=this=]'s [=relevant settings object=]'s [=environment settings object/origin=].

    1. Let |transfer| be |options|["{{StructuredSerializeOptions/transfer}}"].

    1. Let |serializeWithTransferResult| be [$StructuredSerializeWithTransfer$](|message|, |transfer|). Rethrow any exceptions.

    1. [=Queue a global task=] on the [=portal task source=] given |portalBrowsingContext|'s [=browsing context/active
        window=] to run the following steps:

        1. If |portalBrowsingContext|'s [=active document=]'s [=Document/origin=] is not
            [=same origin=] with |sourceOrigin|, then abort these steps.

        1. Let |origin| be the [=serialization of an origin|serialization=] of |sourceOrigin|.

        1. Let |targetWindow| be |portalBrowsingContext|'s associated {{WindowProxy}}'s \[[Window]] internal slot value.

        1. Let |portalHost| be the |targetWindow|'s [=portal host object=].

        1. Let |targetRealm| be the |targetWindow|'s [=global object/realm=].

        1. Let |deserializeRecord| be [$StructuredDeserializeWithTransfer$](|serializeWithTransferResult|, |targetRealm|).

            If this throws an exception, catch it, [=fire an event=] named {{PortalHost/messageerror!!event}} at |portalHost| using {{MessageEvent}}
            with the {{MessageEvent/origin}} attribute initialized to |origin| and the {{MessageEvent/source}} attribute initialized to |portalHost|,
            then abort these steps.

        1. Let |messageClone| be |deserializeRecord|.\[[Deserialized]].

        1. Let |newPorts| be a new [=frozen array type|frozen array=] consisting of all {{MessagePort}} objects in
            |deserializeRecord|.\[[TransferredValues]], if any, maintaining their relative order.

        1. [=Fire an event=] named {{PortalHost/message!!event}} at |portalHost| using {{MessageEvent}}, with the {{MessageEvent/origin}} attribute
            initialized to |origin|, the {{MessageEvent/source}} attribute initialized to |portalHost|, the {{MessageEvent/data}} attribute
            initialized to |messageClone|, and the {{MessageEvent/ports}} attribute initialized to |newPorts|.

    <wpt>
      portals-post-message.sub.html
    </wpt>
  </section>

  <section algorithm="htmlportalelement-may-have-guest-browsing-context">
    To determine whether a <{portal}> element <dfn>may have a guest browsing context</dfn>, run the following steps:

    1. If |element|'s [=Node/node document=]'s [=browsing context=] is not a [=top-level browsing context=], then return false.

        <wpt>
          portals-nested.html
        </wpt>

        <p class="note">
          The user agent may choose to emit a warning if the author attempts to
          use a <{portal}> element in a [=nested browsing context=], as this is not
          supported.
        </p>

    1. If |element|'s [=Node/node document=]'s [=Document/URL=]'s [=url/scheme=] is not an
        [=HTTP(S) scheme=], then return false.

        <wpt>
          about-blank-cannot-host.html
        </wpt>

        <p class="note">
          This is to prevent problems later, if the portaled content attempts to
          [=adopt the predecessor browsing context|adopt its predecessor=]. Since portaled content
          can only have a [=HTTP(S) scheme=], adoption would fail, and so its simpler to restrict
          things at this stage.
        </p>

    1. If |element|'s [=Node/node document=]'s [=Document/active sandboxing flag set=] is not empty,
        then return false.

        <wpt>
          no-portal-in-sandboxed-popup.html
        </wpt>

        <p class="note">
          Since portals cannot be created in [=child browsing contexts=] anyway, this step is about
          preventing portal uses in [=auxiliary browsing contexts=] spawned by sandboxed
          <{iframe}>s, or pages using CSP's [=sandbox=] directive.
        </p>

        <p class="note">
          This restriction is largely added for simplicity. If there are use cases for portals
          inside sandboxed documents, we can enable them in the future, with appropriate opt-in. See
          <a href="https://github.com/WICG/portals/issues/207">issue #207</a> for discussion.
        </p>

    1. If |element| is [=browsing-context connected=], then return true.

    1. If |element|'s [=HTMLPortalElement/just-adopted flag=] is true, then return true.

    1. Return false.
  </section>

  <section algorithm="htmlportalelement-close">
    To <dfn>close a <{portal}> element</dfn> |element|, run the following steps:

    1. If |element|'s [=HTMLPortalElement/guest browsing context=] is not null, then [=close a browsing context|close=] it.

        The user agent *should not* ask the user for confirmation during the
        [=prompt to unload=] step (and so the browsing context should be
        [=discard a browsing context|discarded=]).
  </section>

  <section algorithm="htmlportalelement-setsourceurl">
    To <dfn>set the source URL of a <{portal}> element</dfn> |element|, run the following steps:

    1. [=Assert=]: |element| [=may have a guest browsing context=].

    1. Let |hostBrowsingContext| be |element|'s [=Node/node document=]'s [=browsing context=].

    1. [=Assert=]: |hostBrowsingContext| is a [=top-level browsing context=].

    1. [=close a portal element|Close=] |element|.

    1. If |element| has no <{portal/src}> attribute specified, or its value is the empty string,
        then return.

    1. [=Parse a URL|Parse=] the value of the <{portal/src}> attribute. If that is not successful,
        then return.

        Otherwise, let |url| be the [=resulting URL record=].

    1. Assert: |element|'s [=HTMLPortalElement/guest browsing context=] is null.

    1. Let |guestBrowsingContext| be the result of
        [=create a new top-level browsing context|creating a new top-level browsing context=].

    1. Set the [=portal state=] of |guestBrowsingContext| to "`portal`", and set the [=host element=]
        of |guestBrowsingContext| to |element|.

    1. Let |resource| be a new [=request=] whose [=request/url=] is |url|
        and whose [=request/referrer policy=] is the current state of
        |element|'s <{portal/referrerpolicy}> content attribute.

    1. [=Navigate=] |guestBrowsingContext| to |resource|.

    <div class="note">
      Unlike an <{iframe}> element, a <{portal}> element supports a state where it has no associated
      browsing context. This is the initial state of a <{portal}> element. That is, the [=portal
      browsing context=] has no web-developer-visible initial `about:blank` {{Document}}; instead it
      [=navigates=] directly to the first parsable URL assigned to it, and if the navigation cannot
      finish successfully, it [=close a browsing context|closes=] the browsing context before the
      navigation algorithm finishes.

      Similarly, a <{portal}> element responds to an unparsable <{portal/src}> URL by [=close a
      browsing context|closing=] its browsing context, rather than by navigating to `about:blank`.
    </div>
  </section>

  <wpt>
    portals-cross-origin-load.sub.html
    portals-referrer.html
    portals-referrer-inherit-header.html
    portals-referrer-inherit-meta.html
  </wpt>

  Whenever a <{portal}> element |element| has its <{portal/src}> attribute set,
  changed, or removed, run the following steps:

  1. If |element| [=may have a guest browsing context=], then [=set the source URL of a portal element|set the source URL=] of |element|.

  Whenever a <{portal}> element |element| [=become browsing-context connected|becomes
  browsing-context connected=], run the following steps:

  1. If |element| [=may have a guest browsing context|may not have a guest browsing context=], then abort these steps.

  1. If |element|'s [=HTMLPortalElement/guest browsing context=] is not null, then abort these steps.

      <div class="note">
        This ensures that a newly [=adopt the predecessor browsing context|adopted=]
        <{portal}> element can be inserted into the document without navigating
        it.
      </div>

  1. [=set the source URL of a portal element|Set the source URL=] of |element|.

  Whenever a <{portal}> element |element| [=become browsing-context disconnected|becomes
  browsing-context connected=], run the following steps:

  1. If |element| [=may have a guest browsing context|may not have a guest browsing context=] and its [=HTMLPortalElement/guest browsing context=] is not null, then [=discard a browsing context|discard=] it.

  <div class="issue">
    It might be convenient to not immediately detach the portal element, but instead to do so
    in a microtask. This would allow developers to reinsert the <{portal}> element without losing
    its browsing context.
  </div>

  Whenever a <{portal}> element |element| is [=adopting steps|adopted=], run the following steps:

  1. Let |guestBrowsingContext| be |element|'s [=HTMLPortalElement/guest browsing context=].

  1. If |guestBrowsingContext| is null, then abort these steps.

  1. [=discard a browsing context|Discard=] |guestBrowsingContext|.

  <div class="note">
    In particular, this means a <{portal}> element loses its [=HTMLPortalElement/guest browsing
    context=] if it is moved to the [=active document=] of a [=nested browsing
    context=].

    Similarly, the steps when a <{portal}> element's
    [=set the source URL of a portal element|source URL is set=] prevent
    elements from creating a new [=HTMLPortalElement/guest browsing context=] while inside such
    documents.

    It is therefore impossible to embed a [=portal browsing context=] in a
    [=nested browsing context=].
  </div>

  Whenever a {{Document}} object |document| whose [=Document/browsing context=] is a
  [=portal browsing context=] is marked as [=completely loaded=], run the following steps as part of
  the queued task:

  1. Let |element| be |document|'s [=Document/browsing context=]'s [=host element=].

  1. [=Fire an event=] named {{HTMLElement/load!!event}} at |element|.

  <wpt>
    portal-onload-event.html
    portals-cross-origin-load.sub.html
  </wpt>

  <section algorithm="htmlportalelement-activation-behavior">
    A <{portal}> element |el|'s [=EventTarget/activation behavior=] is to run the following steps:

    1. Let |portalBrowsingContext| be the [=HTMLPortalElement/guest browsing context=] of |el|.

    1. If |portalBrowsingContext| is null, return.

    1. Let |predecessorBrowsingContext| be the [=Document/browsing context=] of |el|'s [=Node/node
        document=].

    1. If |predecessorBrowsingContext| is null, return.

    1. If the [=portal state=] of |predecessorBrowsingContext| is not "`none`", return.

    1. Let |sourceOrigin| be |el|'s [=relevant settings object=]'s
        [=environment settings object/origin=].

    1. Run the steps to [=activate a portal browsing context|activate=] |portalBrowsingContext|
        in place of |predecessorBrowsingContext| with |sourceOrigin|.

    <div class="note">
      This is substantially similar to the steps in {{HTMLPortalElement/activate(options)}}, with default options.
      User agents might wish to display suitable console messages under the same conditions that would
      result in promise rejection in those steps.
    </div>
  </section>

  The following events are dispatched on {{HTMLPortalElement}} objects:

  <table class="data" dfn-for="HTMLPortalElement">
    <thead>
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Dispatched when</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><dfn event for="HTMLPortalElement"><code>message</code></dfn></td>
        <td>{{MessageEvent}}</td>
        <td>A message is received by the object, and deserialization does not throw an exception.</td>
      </tr>
      <tr>
        <td><dfn event for="HTMLPortalElement"><code>messageerror</code></dfn></td>
        <td>{{MessageEvent}}</td>
        <td>A message is received by the object, but deserialization throws an exception.</td>
      </tr>
    </tbody>
  </table>

  The <{portal}> element exposes {{HTMLPortalElement/onmessage}} and {{HTMLPortalElement/onmessageerror}}
  as [=event handler content attributes=].

  <wpt>
    htmlportalelement-event-handler-content-attributes.html
  </wpt>

  Portal hosts {#the-portalhost-interface}
  ------------------------------------------------------

  Every {{Window}} has a <dfn>portal host object</dfn>, which is a {{PortalHost}}. It is exposed
  through the {{Window/portalHost}} attribute getter at times when the window may be in a
  [=portal browsing context=].

  <div class="note">
    The [=portal host object=] can be used to communicate with the [=host browsing context=]. Its
    operations throw if used while its context is not a [=portal browsing context=] (i.e. there is
    no host), in the event that JavaScript code has saved a reference to it. At such times, the
    {{Window/portalHost|window.portalHost}} getter will return null.
  </div>

  <xmp class="idl">
      partial interface Window {
          readonly attribute PortalHost? portalHost;
      };
  </xmp>

  <section algorithm="window-portalhost">
    The <dfn attribute for="Window">portalHost</dfn> attribute's getter *must* run the following steps:

    1. Let |context| be [=this=]'s [=Window/browsing context=].

    1. If |context| is null or the [=portal state=] of |context| is not "`portal`", then return null.

    1. Return [=this=]'s [=portal host object=].
  </section>

  <wpt>
    portals-host-exposure.sub.html
    portals-host-null.html
  </wpt>

  <hr>

  The {{PortalHost}} interface definition is as follows:

  <xmp class="idl">
      [Exposed=Window]
      interface PortalHost : EventTarget {
          undefined postMessage(any message, optional StructuredSerializeOptions options = {});

          attribute EventHandler onmessage;
          attribute EventHandler onmessageerror;
      };
  </xmp>

  <section algorithm="portalhost-postmessage">
    The <dfn method for="PortalHost"><code>postMessage(|message|, |options|)</code></dfn> method *must* run these steps:

    1. Let |browsingContext| be [=this=]'s [=relevant global object=]'s [=Window/browsing context=].

    1. If |browsingContext| has a [=portal state=] other than "`portal`", throw an "{{InvalidStateError}}" {{DOMException}}.

        Note: This roughly means that it has not yet been activated, as far as this [=event loop=] has been told.
        It is possible that this browsing context will be [=activate a portal browsing context|activated=] in parallel
        to this message being sent; in such cases, messages may not be delivered.

    1. Let |sourceOrigin| be [=this=]'s [=relevant settings object=]'s [=environment settings object/origin=].

    1. Let |transfer| be |options|["{{StructuredSerializeOptions/transfer}}"].

    1. Let |serializeWithTransferResult| be [$StructuredSerializeWithTransfer$](|message|, |transfer|). Rethrow any exceptions.

    1. Let |hostElement| be the [=host element=] of |browsingContext|.

    1. [=Queue an element task=] on the [=portal task source=] given |hostElement| to run the following steps:

        1. If |browsingContext| is not the [=HTMLPortalElement/guest browsing context=] of |hostElement|, then abort these steps.

            Note: This might happen if this [=event loop=] had a queued task to deliver a message, but
            it was not executed before the portal was [=activate a portal browsing context|activated=].
            In such cases, the message is not delivered.

        1. Let |targetSettings| be the [=relevant settings object=] of |hostElement|.

        1. If |targetSettings|'s [=environment settings object/origin=] is not [=same origin=] with
            |sourceOrigin|, then abort these steps.

        1. Let |origin| be the [=serialization of an origin|serialization=] of |sourceOrigin|.

        1. Let |targetRealm| be |targetSettings|'s [=environment settings object/realm=].

        1. Let |deserializeRecord| be [$StructuredDeserializeWithTransfer$](|serializeWithTransferResult|, |targetRealm|).

            If this throws an exception, catch it, [=fire an event=] named {{HTMLPortalElement/messageerror!!event}} at |element| using {{MessageEvent}}
            with the {{MessageEvent/origin}} attribute initialized to |origin| and the {{MessageEvent/source}} attribute initialized to |element|.

        1. Let |messageClone| be |deserializeRecord|.\[[Deserialized]].

        1. Let |newPorts| be a new [=frozen array type|frozen array=] consisting of all {{MessagePort}} objects in
            |deserializeRecord|.\[[TransferredValues]], if any, maintaining their relative order.

        1. [=Fire an event=] named {{HTMLPortalElement/message!!event}} at the |element| using {{MessageEvent}}, with the {{MessageEvent/origin}} attribute
            initialized to |origin|, the {{MessageEvent/source}} attribute initialized to |element|, the {{MessageEvent/data}} attribute
            initialized to |messageClone|, and the {{MessageEvent/ports}} attribute initialized to |newPorts|.
  </section>

  <wpt>
    portals-host-post-message.sub.html
  </wpt>

  The following events are dispatched on {{PortalHost}} objects:

  <table class="data" dfn-for="PortalHost">
    <thead>
      <tr>
        <th>Event name</th>
        <th>Interface</th>
        <th>Dispatched when</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><dfn event for="PortalHost"><code>message</code></dfn></td>
        <td>{{MessageEvent}}</td>
        <td>A message is received by the object, and deserialization does not throw an exception.</td>
      </tr>
      <tr>
        <td><dfn event for="PortalHost"><code>messageerror</code></dfn></td>
        <td>{{MessageEvent}}</td>
        <td>A message is received by the object, but deserialization throws an exception.</td>
      </tr>
    </tbody>
  </table>

  The `PortalActivateEvent` interface {#the-portalactivateevent-interface}
  ------------------------------------------------------------------------

  <xmp class="idl">
      [Exposed=Window]
      interface PortalActivateEvent : Event {
          constructor(DOMString type, optional PortalActivateEventInit eventInitDict = {});

          readonly attribute any data;
          HTMLPortalElement adoptPredecessor();
      };

      dictionary PortalActivateEventInit : EventInit {
          any data = null;
      };
  </xmp>

  <div class="note">
    For now, there is no <code>ports</code> attribute on {{PortalActivateEvent}}, despite it being
    used for data transfer in a similar way to {{MessageEvent}}. This omission is for simplicity,
    and could be reconsidered if a use case is found. (See also
    <a href="https://github.com/whatwg/html/issues/4521">whatwg/html#4521</a> for a potential
    expansion.)
  </div>

  A {{PortalActivateEvent}} has an associated <dfn for="PortalActivateEvent">predecessor browsing context</dfn>,
  which is a [=top-level browsing context=] or null, a <dfn for="PortalActivateEvent">successor window</dfn>, which is
  a {{Window}}, an <dfn for="PortalActivateEvent">activation promise</dfn>, which is a [=promise=] or null, and a
  <dfn for="PortalActivateEvent">adopted predecessor element</dfn>, which is a <{portal}> element or null.

  <section algorithm="portalactivateevent-event-constructing-steps">
    The [=event constructing steps=] for {{PortalActivateEvent}}, given an |event|, are as follows:

    1. Set |event|'s [=PortalActivateEvent/predecessor browsing context=] to null.

    1. Set |event|'s [=PortalActivateEvent/successor window=] to null.

    1. Set |event|'s [=PortalActivateEvent/adopted predecessor element=] to null.
  </section>

  <wpt>
    portal-activate-event-constructor.html
  </wpt>

  <section algorithm="portalactivateevent-adoptpredecessor">
    The <dfn method for="PortalActivateEvent"><code>adoptPredecessor()</code></dfn> method *must* run these steps:

    1. If [=this=]'s [=PortalActivateEvent/adopted predecessor element=] is not null, throw an "{{InvalidStateError}}" {{DOMException}}.

    1. Let |predecessorBrowsingContext| be [=this=]'s [=PortalActivateEvent/predecessor browsing context=].

    1. Let |successorWindow| be [=this=]'s [=PortalActivateEvent/successor window=].

    1. Run the steps to [=adopt the predecessor browsing context=] |predecessorBrowsingContext| in |successorWindow|,
        and let |adoptedPredecessorElement| be the result.

    1. Set [=this=]'s [=PortalActivateEvent/adopted predecessor element=] to |adoptedPredecessorElement|.

    1. If [=this=]'s [=PortalActivateEvent/activation promise=] is not null, [=queue a global task=] on the [=portal task source=]
        given |predecessorBrowsingContext|'s [=browsing context/active window=] to resolve it with undefined.

        Note: Queuing this immediately makes it possible to send messages to the adopted
        portal during dispatch of the {{Window/portalactivate!!event}} event without
        ordering issues between the task to resolve the activation promise and the task
        to deliver the message.

    1. Return |adoptedPredecessorElement|.

    <wpt>
      portals-adopt-predecessor.html
    </wpt>
  </section>
</section>

<section>
  Miscellaneous HTML updates {#miscellaneous-extensions}
  ====================================================

  <em>This section contains various small patches to miscellaneous areas of the HTML Standard.</em>

  The {{MessageEvent}} interface {#patch-messageevent}
  ----------------------------------------------------

  The {{MessageEventSource}} union is extended to include the new interfaces
  which can produce {{MessageEvent}} events.

  <xmp class="idl">
  typedef (WindowProxy or MessagePort or ServiceWorker or HTMLPortalElement or PortalHost) MessageEventSource;
  </xmp>

  Event handlers {#patch-event-handlers}
  --------------------------------------

  The table of [=event handlers=] which must be supported by {{Window}} objects, as [=event handler
  IDL attributes=] on the {{Window}} objects themselves (i.e. the table containing `onafterprint`),
  gets extended with the following row:

  <table class="data" dfn-for="Window">
    <thead>
      <tr>
        <th>[=Event handler=]</th>
        <th>[=Event handler event type=]</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><dfn attribute for="Window"><code>onportalactivate</code></dfn></td>
        <td>{{Window/portalactivate}}</td>
      </tr>
    </tbody>
  </table>

  The corresponding {{WindowEventHandlers}} mixin gets extended as follows:

  <xmp class="idl">
      partial interface mixin WindowEventHandlers {
          attribute EventHandler onportalactivate;
      };
  </xmp>

  The <a href="https://html.spec.whatwg.org/#events-2">Events index</a> is also updated with the
  following additional row:

  <table class="data" dfn-for="Window">
    <thead>
      <tr>
        <th>Event</th>
        <th>Interface</th>
        <th>Interesting targets</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><dfn event for="Window"><code>portalactivate</code></dfn></td>
        <td>{{PortalActivateEvent}}</td>
        <td>{{Window}}</td>
        <td>Fired at the {{Window}} of a [=portal browsing context=] when that [=portal browsing
        context=] is activated.</td>
      </tr>
    </tbody>
  </table>

  APIs for creating and navigating browsing contexts by name {#patch-window-apis}
  -------------------------------------------------------------------------------

  Modify the definition of <a spec=HTML>script-closable</a> to prevent window closing while in a
  [=portal browsing context=]:

  A [=browsing context=] is <dfn noexport>script-closable</dfn> if either of the following is true:

  * it is an [=auxiliary browsing context=] that was created by script (as opposed to by an action
    of the user); or
  * it is a [=top-level browsing context=] <ins>whose [=portal state=] is "`none`"</ins> and whose
    [=session history=] contains only one {{Document}}.

  <wpt>
    portals-close-window.html
  </wpt>

  Navigation {#patch-navigation}
  ------------------------------

  Patch the <a spec=HTML>navigate</a> algorithm to prevent certain navigations in a
  portal as follows:

  <div algorithm="process a navigate response patch">
    In <a spec=HTML>process a navigate response</a>, append the following after the step which
    establishes the value of |failure|, but before the step which uses it to display an error page:

    1. If |browsingContext|'s [=portal state=] is not "`none`", and any of the following hold:

          * |failure| is true;
          * |navigationParams|'s [=navigation params/request=] is null;
          * |navigationParams|'s [=navigation params/request=]'s [=request/current URL=]'s
            [=url/scheme=] is not a [=HTTP(S) scheme=];
          * |response| has a \``Content-Disposition`\` header specifying the `attachment`
              disposition type; or
          * |response|'s [=response/status=] is 204 or 205,

        then:

        1. If |browsingContext|'s only entry in its [=session history=] is the initial `about:blank`
            {{Document}}, then:
            1. [=Close a portal element|Close=] |browsingContext|'s [=host element=].
            1. Run the [=environment discarding steps=] for <var ignore>navigationParam</var>'s
                [=navigation params/reserved environment=].
        1. Return.
  </div>

  <div algorithm="process a navigate URL scheme patch">
    In <a spec=HTML>process a navigate URL scheme</a>, insert the following step before the step
    which displays inline content:

    1. Otherwise, if |browsingContext|'s [=portal state=] is not "`none`", then [=close a portal
        element|close=] |browsingContext|'s [=host element=].
  </div>

  <wpt>
    portal-non-http-navigation.html
  </wpt>

  Downloading resources {#patch-downloading}
  ------------------------------------------

  Modify the <a spec=HTML>allowed to download</a> algorithm to ensure that portaled content never
  performs downloads, by prepending the following steps:

  <div algorithm="allowed to download patch">
    1. If <var ignore>initiator browsing context</var>'s [=portal state=] is not "`none`", then
        return false.

    1. If <var ignore>instantiator browsing context</var>'s [=portal state=] is not "`none`", then
        return false.
  </div>

</section>

<section>
  Updates to other specifications {#other-spec-updates}
  =====================================================

  Content Security Policy {#csp}
  ------------------------------

  This specification integrates with [[CSP]] as follows.

  <p class="issue">Although `navigate-to` works as expected while the content is portaled, we also
  need to apply it to prevent activation (which is basically a navigation). This is not yet specced,
  pending spec updates to the navigation and session history handling.</p>

  The following new subsection of [[CSP#directives-fetch]] is added:

  ### `portal-src` ### {#portal-src-directive}

  The <dfn export>portal-src</dfn> directive restricts the URLs which may be loaded into [=portal
  browsing contexts=]. The syntax for the directive's name and value is described by the following
  ABNF:

  <pre highlight="abnf">
  directive-name  = "portal-src"
  directive-value = <a grammar>serialized-source-list</a>
  </pre>

  <div class="example" id="example-portal-src">
    Given a page with the following Content Security Policy:

    <pre>
      <a http-header>Content-Security-Policy</a>: <a>portal-src</a> https://example.com/
    </pre>

    Fetches for the following code will return a network errors, and thus result in [=close a portal
    element|closing=] the portal, as the URL provided does not match `portal-src`'s [=source list=]:

    <xmp highlight="html">
      <portal src="https://example.org/"></portal>
    </xmp>
  </div>

  #### `portal-src` Pre-request check #### {#portal-src-pre-request}

  This directive's [=directive/pre-request check=] is as follows:

  <div algorithm="portal-src pre-request check">
    Given a [=request=] |request| and a policy |policy|:

    1. Let |name| be the result of executing [[CSP#effective-directive-for-a-request]] on |request|.

    1. If the result of executing [[CSP#should-directive-execute]] on |name|, `portal-src` and
        |policy| is "`No`", return "`Allowed`".

    1. If the result of executing [[CSP#match-request-to-source-list]] on |request|, this directive's
        [=directive/value=], and |policy| is "`Does Not Match`", return "`Blocked`".

    1.  Return "`Allowed`".
  </div>

  #### `portal-src` Post-request check #### {#portal-src-post-request}

  This directive's [=directive/post-request check=] is as follows:

  <div algorithm="portal-src post-request check">
    Given a [=request=] |request|, a [=response=] |response|, and a policy |policy|:

    1. Let |name| be the result of executing [[CSP#effective-directive-for-a-request]] on |request|.

    1. If the result of executing [[CSP#should-directive-execute]] on |name|, `portal-src` and
        |policy| is "`No`", return "`Allowed`".

    1. If the result of executing [[CSP#match-response-to-source-list]] on |response|, |request|,
        this directive's [=directive/value=], and |policy| is "`Does Not Match`", return
        "`Blocked`".

    4.  Return "`Allowed`".
  </div>

  ### `default-src` ### {#default-src-patch}

  The informative example text which expands it into all other fetch directives in
  [[CSP#directive-default-src]] will need updating to include [=portal-src=].

  ### Get fetch directive fallback list ### {#directive-fallback-list-patch}

  The algorithm in [[CSP#directive-fallback-list]] needs updating to account for the new
  [=portal-src=] fetch directive. Add a new case to step 1:

  <dl class="switch">
    : "`portal-src`"
    ::
        1. Return « "`portal-src`", "`prefetch-src`", "`default-src`" ».
  </dl>

  Fetch Metadata Request Headers {#fetch-metadata}
  ------------------------------------------------

  This specification integrates with [[FETCH-METADATA]] as follows.

  <section algorithm="fetch-metadata-set-mode">
    The algorithm to [[FETCH-METADATA#abstract-opdef-set-mode|set the Sec-Fetch-Mode header]] for a request |r|
    is modified as follows:

    1. Where the algorithm checks whether |r|'s [=request/reserved client=]'s [=environment/target
        browsing context=] is a [=nested browsing context=], check instead whether it is a [=nested
        browsing context=] or a [=portal browsing context=].
  </section>

  <div class="note">
    The effect of this is that the request for a document in a [=portal browsing context=]
    will contain the following HTTP header, as though it were in a [=nested browsing context=].

    ```
    Sec-Fetch-Mode: nested-navigate
    ```
  </div>

  <div class="note">
    Per the existing processing model, the other fetch metadata headers will automatically have the
    same values as they would would if the load were occurring in an <{iframe}> element, with no
    spec updates needed.
  </div>
</section>

<section>
  Security Considerations {#security-considerations}
  ==================================================

  <div class="issue">
    We should expand this section further. Much of what was formerly there is in
    [[#other-spec-updates]] now. Once we have a more comprehensive view of all the security-related
    spec updates, we should summarize them in a non-normative fashion here.
  </div>

  Overview {#security-overview}
  -----------------------------

  *This section is non-normative.*

  In general, a [=portal browsing context=] should respect policies that would apply to
  a [=nested browsing context=], e.g. that would restrict whether a document can be embedded
  in a document from another [=origin=].
</section>

<section>
  Untriaged tests {#untriaged-tests}
  ==================================

  In order to get this spec to build without warnings, we need to include all the web platform tests
  explicitly. This section contains all the tests which we haven't yet written spec text for, or
  haven't triaged into the appropriate sections.

  <wpt>
    history/history-manipulation-inside-portal-with-subframes.html
    history/history-manipulation-inside-portal.html
    portal-activate-default.html
    portals-activate-empty-browsing-context.html
    portals-activate-network-error.html
    portals-activate-while-unloading.html
    portals-no-frame-crash.html
    portals-focus.sub.html
    portals-navigate-after-adoption.html
    portals-repeated-activate.html
    portals-set-src-after-activate.html
    predecessor-fires-unload.html
  </wpt>

  The following tests are actively incorrect and need to get updated:

  <wpt>
    csp/frame-ancestors.sub.html
    xfo/portals-xfo-deny.sub.html
    xfo/portals-xfo-sameorigin.html
    csp/frame-src.sub.html
  </wpt>
</section>
