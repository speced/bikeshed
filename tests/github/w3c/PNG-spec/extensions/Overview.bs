<pre class='metadata'>
Title: Extensions to the PNG Third Edition Specification, Version 1.6.0
Shortname: pngext
Level: none
Status: NOTE-FPWD
Group: PNGWG
URL: https://w3c.github.io/PNG-spec/extensions/Overview.html
TR: https://w3.org/TR/png-extensions/
Editor: Chris Lilley, W3C, https://svgees.us/, w3cid 1438
Former Editor: Glenn Randers-Pehrson
Repository: https://github.com/w3c/PNG-spec/
Abstract: This document is an extension to the Portable Network Graphics (PNG) specification, third edition [[PNG]]. It describes additional public chunk types and contains additional information for use in PNG images.
Local Boilerplate: header yes
Local Boilerplate: footer yes
Local Boilerplate: logo yes
Local Boilerplate: copyright yes
</pre>

<style>
    span.chunk {
        font-family: Courier, monospace;
        color:green;
        font-weight:bold;
    }
</style>

<pre class=biblio>
	{
		"dSIG-spec": {
			"href": "http://ftp-osl.osuosl.org/pub/libpng/documents/signatures/PNG_Digital_Signatures.spec.pdf",
			"title": "PNG Digital Signatures: Extension Specification",
            "authors": "Thomas Kopp",
			"date": "17 Nov 2008"
		},
		"dSIG-example": {
			"href": "http://ftp-osl.osuosl.org/pub/libpng/documents/signatures/PNG_Digital_Signatures.sample.html",
			"title": "PNG Digital Signatures: Commented Example",
			"authors": "Martin Bo√ület, Thomas Kopp",
			"date": "18 May 2008"
		}
	}
</pre>

<h2 id="intro">
Introduction
</h2>

    This document,
    together with the PNG specification [[!PNG]],
    contains the entire list of registered "public" PNG chunks.
    The additional registered chunks appearing in this document are the
    <span class="chunk">oFFs</span>,
    <span class="chunk">pCAL</span>,
    <span class="chunk">sCAL</span>,
    <span class="chunk">gIFg</span>,
    <span class="chunk">gIFs</span>,
    <span class="chunk">sTER</span>, and
    <span class="chunk">fRAc</span> chunks,
    plus the deprecated <span class="chunk">gIFt</span> chunk.

    Additional chunk types may be proposed
    for inclusion in this list
    by contacting the PNG specification maintainers at
    public-png@w3.org
    or by raising an issue on their
    <a href="https://github.com/w3c/PNG-spec/issues/">GitHub repository</a>
    (preferred).
    Attention is drawn to the
    <a href="https://www.w3.org/TR/PNG/#B-NewChunksAppendix">Guidelines for new chunk types</a>.

    Chunks described here
    are expected to be less widely supported
    than those defined in the basic specification.
    However,
    application authors are encouraged
    to use these chunk types
    whenever appropriate
    for their applications.

    This document
    also describes data representations
    that do not occur in the core PNG format,
    but are used in one or more special-purpose chunks.
    New chunks should use these representations
    whenever applicable,
    in order to maximize portability
    and simplify decoders.

<h2 id="DataRep">
    Data Representation
</h2>

<h3 id="DR.Integer-values">
    Integer values
</h3>

    Refer to <a href="https://w3c.github.io/PNG-spec/#7Integers-and-byte-order">Section 7.1
    of the PNG specification</a> [[!PNG]] for the format and
    range of integer values

<h3 id="DR.Floating-point-values">
    Floating-point values
</h3>

    The core of PNG
    does not use floating-point numbers anywhere;
    it uses integers
    or, where applicable,
    fixed-point fractional values.
    However, special-purpose chunks
    may need to represent values
    that do not fit comfortably in fixed-point notation.
    The textual floating-point notation
    defined here
    is recommended for use in all such cases.
    This representation is simple,
    has no a priori limits on range or precision,
    and is portable across all machines.

    A floating-point value
    in this notation
    is represented by an ASCII text string
    in a standardized decimal floating-point format.
    The string is variable-length
    and must be terminated by a null (zero) character
    unless it is the last item in its chunk.
    The string consists of
    an optional sign ("+" or "-"),
    an integer part,
    a fraction part beginning with a decimal point ("."),
    and an exponent part beginning with an "E" or "e"
    and optional sign.
    The integer, fraction, and exponent parts
    each contain one or more digits (ASCII "0" to "9").
    Either the integer part or the fraction part,
    but not both,
    may be omitted.
    A decimal point is allowed,
    but not required,
    if there is no fraction part.
    The exponent part may be omitted.
    No spaces
    or any other character besides those specified
    may appear.

    Note: in particular, C-language "F" and "L" suffixes
    are not allowed,
    the string "." is not allowed as a shorthand for 0
    as in some other programming languages,
    and no commas or underscores are allowed.
    This format ought to be easily readable
    in all programming environments.

<h2 id="Summary">
    Summary of Special-Purpose Chunks
</h2>

    This table summarizes some properties of the chunks described in this document.
    For standard chunks, see the PNG specification [[!PNG]].

    <table>
        <tr><th>Name&nbsp; &nbsp;</th><th>Multiple OK?</th><th>Ordering constraints</th></tr>
        <tr><td><a href="#C.oFFs"><span class="chunk">oFFs</span></a></td><td>No</td><td>Before IDAT</td></tr>
        <tr><td><a href="#C.pCAL"><span class="chunk">pCAL</span></a></td><td>No</td><td>Before IDAT</td></tr>
        <tr><td><a href="#C.sCAL"><span class="chunk">sCAL</span></a></td><td>No</td><td>Before IDAT</td></tr>
        <tr><td><a href="#C.gIFg"><span class="chunk">gIFg</span></a></td><td>Yes</td><td>None</td></tr>
        <tr><td><a href="#DC.gIFt"><span class="chunk">gIFt</span></a></td><td>Yes</td><td>None <em>(this chunk is deprecated)</em></td></tr>
        <tr><td><a href="#C.gIFx"><span class="chunk">gIFx</span></a></td><td>Yes</td><td>None</td></tr>
        <tr><td><a href="#C.sTER"><span class="chunk">sTER</span></a></td><td>No</td><td>Before IDAT</td></tr>
        <tr><td><a href="R.dSIG"><span class="chunk">dSIG</span></a></td><td>Yes</td><td>In pairs, immediately after IHDR and before IEND</td></tr>
        <!--
            Moved to main PNG specification, 3rd edition
            <tr><td><span class="chunk">eXIf</span></td><td>No</td><td>None</td></tr>
        -->
        <tr><td><a href="R.fRAc"><span class="chunk">fRAc</span></a></td><td>Yes</td><td>None</td></tr>
    </table>

    <h2 id="Chunks">
        Chunk Descriptions
    </h2>

    <h3 id="C.oFFs">
        <span class="chunk">oFFs</span> Image offset
    </h3>

    The <span class="chunk">oFFs</span> chunk
    gives the position on a printed page
    at which the image should be output
    when printed alone.
    It can also be used
    to define the image's location
    with respect to a larger screen
    or other application-specific coordinate system.

    The <span class="chunk">oFFs</span> chunk contains:

   <table>
       <tr><th>X position:</th><td>4 bytes (signed integer)</td></tr>
       <tr><th>Y position:</th><td>4 bytes (signed integer)</td></tr>
       <tr><th>Unit specifier:</th><td>1 byte</td></tr>
   </table>

    Both position values are signed. The following values are legal for the unit specifier:

    <table>
        <tr><th>0:</th><td>unit is the pixel (true dimensions unspecified)</td></tr>
        <tr><th>1:</th><td>unit is the micrometer</td></tr>
    </table>

    Note: for conversions,
    one inch is equal to exactly 25400 micrometers.
    A micrometer (also called a micron)
    is 10<sup>-6</sup> meter.

    The X position is measured rightwards
    from the left edge of the page to the left edge of the image;
    the Y position is measured downwards
    from the top edge of the page to the top edge of the image.
    Note that negative values are permitted,
    and denote displacement in the opposite directions.
    Although oFFs can specify
    an image placement that is partially or wholly outside the page boundaries,
    the result of such placement is application-dependent.

    If present, this chunk must precede the first <span class="chunk">IDAT</span> chunk.


<h3 id="C.pCAL">
    <span class="chunk">pCAL</span> Calibration of pixel values
</h3>

When a PNG file is being used
to store physical data other than color values,
such as a two-dimensional temperature field,
the <span class="chunk">pCAL</span> chunk can be used
to record the relationship (mapping)
between stored pixel samples,
original samples,
and actual physical values.
The <span class="chunk">pCAL</span> data might be used
to construct a reference color bar beside the image,
or to extract the original physical data values from the file.
It is not expected to affect the way the pixels are displayed.
Another method should be used
if the encoder wants the decoder to modify the sample values for display purposes.

The <span class="chunk">pCAL</span> chunk contains:

<table>
    <tr><th>Calibration name:  </th><td>1-79 bytes (character string) </td></tr>
    <tr><th>Null separator:  </th><td>1 byte </td></tr>
    <tr><th>Original zero (x0): </th><td>4 bytes (signed integer) </td></tr>
    <tr><th>Original max  (x1): </th><td>4 bytes (signed integer) </td></tr>
    <tr><th>Equation type: </th><td>1 byte </td></tr>
    <tr><th>Number of parameters: </th><td>1 byte </td></tr>
    <tr><th>Unit name:  </th><td>0 or more bytes (character string) </td></tr>
    <tr><th>Null separator:  </th><td>1 byte  </td></tr>
    <tr><th>Parameter 0 (p0):  </th><td>1 or more bytes (<a href="#DR.Floating-point-values">ASCII floating-point</a>) </td></tr>
    <tr><th>Null separator:  </th><td>1 byte  </td></tr>
    <tr><th>Parameter 1 (p1): </th><td>1 or more bytes (<a href="#DR.Floating-point-values">ASCII floating-point</a>) </td></tr>
    <tr><td colspan="2">...etc...</td></tr>
</table>

    There is no null separator
    after the final parameter
    (or after the unit name,
    if there are zero parameters).
    The number of parameters field
    must agree with
    the actual number of parameters present in the chunk,
    and must be correct for the specified equation type (see below).

    The calibration name
    can be any convenient name for referring to the mapping,
    and is subject to the same restrictions as
    the keyword in a PNG text chunk:
    it must contain only printable Latin-1 [ISO/IEC-8859-1] characters
    (decimal codes 33-126 and 161-255)
    and spaces (decimal code 32),
    but no leading, trailing, or consecutive spaces.

    <!-- handwavy section which contradicts the restriction to one pCAL -->
    The calibration name
    can permit applications or people
    to choose the appropriate pCAL chunk
    when more than one is present
    (this could occur in a multi-image PNG file, but not in a static PNG file).
    For example, a calibration name of "SI" or "English"
    could be used to identify the system of units in the pCAL chunk
    as well as in other chunk types,
    to permit a decoder
    to select an appropriate set of chunks based on their names.

    The <span class="chunk">pCAL</span> chunk defines two mappings:

    - A mapping from the stored samples,
        which are unsigned integers in the range 0..max,
        where max=2<sup>bitdepth</sup>-1,
        to the original samples,
        which are signed integers.
        The x0 and x1 fields,
         together with the bit depth for the image,
         define this mapping.

    - A mapping from the original samples
        to the physical values,
        which are usually real numbers with units.
        This mapping is defined by x0, x1,
        the equation type, parameters, and unit name.

    The mapping between the stored samples
    and the original samples
    is given by the following equations:

    <pre class="lang-C">
    original_sample =
        (stored_sample * (x1-x0) + max/2) / max + x0

    stored_sample =
         ((original_sample - x0) * max + (x1-x0)/2) / (x1-x0)
         clipped to the range 0..max
    </pre>

    In these equations,
    "/" means integer division that rounds toward negative infinity,
    so <code>n/d = integer(floor(real(a)/real(b))))</code>.
    Note that this is the same as
    the "/" operator in the C programming language
    when n and d are nonnegative,
    but not necessarily when n or d is negative.

    Notice that x0 and x1 are the original samples
    that correspond to the stored samples 0 and max, respectively.
    Encoders will usually set x0=0 and x1=max to indicate
    that the stored samples are equal to the original samples.
    Note that x0 is not constrained to be less than x1,
    and neither is constrained to be positive,
    but they must be different from each other.

    This mapping is lossless and reversible
    when <code>abs(x1-x0) <= max</code>
    and the original sample is in the range
    <code>x0..x1</code>.
    If <code>abs(x1-x0) > max</code>
    then there can be no lossless reversible mapping,
    but the functions provide the best integer approximations
    to floating-point affine transformations.

    The mapping between the original samples and the physical values
    is given by one of several equations,
    depending on the equation type,
    which may have the following values:

    <table>
        <tr><th>0:</th><td>Linear mapping</td></tr>
        <tr><th>1:</th><td>Base-e exponential mapping</td></tr>
        <tr><th>2:</th><td>Arbitrary-base exponential mapping</td></tr>
        <tr><th>3:</th><td>Hyperbolic mapping</td></tr>
    </table>

    For equation type 0:

    <pre class="lang-C">
    physical_value = p0 + p1 * original_sample / (x1-x0)
    </pre>

    For equation type 1:

    <pre class="lang-C">
    physical_value =
       p0 + p1 * exp(p2 * original_sample / (x1-x0))
    </pre>

    For equation type 2:

     <pre class="lang-C">
    physical_value =
       p0 + p1 * pow(p2, (original_sample / (x1-x0)))
     </pre>

    For equation type 3:

    <pre class="lang-C">
    physical_value =
       p0 + p1 * sinh(p2 * (original_sample - p3) / (x1-x0))
    </pre>

    For these physical value equations, "/" means floating-point division.

    The function <code>exp(x)</code>
    is <code>e</code> raised to the power of <code>x</code>,
    where <code>e</code> is the base of the natural logarithms,
    approximately 2.71828182846.
    The exponential function <code>exp()</code>
    is the inverse the natural logarithm function <code>ln()</code>.

    The function <code>pow(x,y)</code>
    is <code>x</code>
    raised to the power of <code>y</code>.

    <pre class="lang-C">
    physical_value =pow(x,y) = exp(y * ln(x))
    </pre>

    The function <code>sinh(x)</code> is
    the hyperbolic sine of <code>x</code>.

    <pre class="lang-C">
    physical_value =
        sinh(x) = 0.5 * (exp(x) - exp(-x))
    </pre>

    The units for the physical values
    are given by the unit name,
    which may contain any number of printable Latin-1 characters,
    with no limitation on the number and position of blanks.

    <div class="example">
        For example, "K", "population density", "MPa".
        A zero-length string can be used for dimensionless data.
    </div>

    For color types 0 (gray) and 4 (gray-alpha),
    the mappings apply to the gray sample values
    (but not to the alpha sample).
    For color types 2 (RGB), 3 (indexed RGB), and 6 (RGBA),
    the mappings apply independently
    to each of the red, green, and blue sample values
    (but not the alpha sample).
    In the case of color type 3 (indexed RGB),
    the mapping refers to the RGB samples
    and not to the index values.

    Linear data can be expressed with equation type 0.

    Pure logarithmic data can be expressed
    with either equation type 1 or 2:

    <table>
        <tr><th>Equation type 1</th><th>Equation type 2</th></tr>
        <tr><td>x0 = 0 </td><td>x0 = 0</td></tr>
        <tr><td>x1 = max</td><td>x1 = max</td></tr>
        <tr><td>p0 = 0</td><td>p0 = 0</td></tr>
        <tr><td>p1 = bottom</td><td>p1 = bottom</td></tr>
        <tr><td>p2 = ln(top/bottom)</td><td>p2 = top/bottom</td></tr>
    </table>

    Equation types 1 and 2 are functionally equivalent;
    both are defined because authors may find
    one or the other more convenient.

    Using equation type 3,
    floating-point data can be reduced (with loss)
    to a set of integer samples
    such that the resolution of the stored data
    is roughly proportional to its magnitude.

    <div class="example">
        For example,
        floating-point data ranging from
        -10<sup>31</sup> to 10<sup>31</sup>
        (the usual range of 32-bit floating-point numbers)
        can be represented with:

        <pre>
            Equation type 3
            x0 = 0
            x1 = 65535
            p0 = 0.0
            p1 = 1.0e-30
            p2 = 280.0
            p3 = 32767.0
        </pre>
    </div>

    The resolution near zero is about 10<sup>-33</sup>,
    while the resolution near 10<sup>31</sup> or -10<sup>31</sup>
    is about 10<sup>28</sup>.
    Everywhere, the resolution is about 0.4 percent of the magnitude.

    <div class="note">
        Note: those floating-point parameters
        could be stored in the chunk more compactly
        as follows:

        <pre>
            p0 = 0
            p1 = 1e-30
            p2 = 280
            p3 = 32767
        </pre>
    </div>

    Applications should use double precision arithmetic
    (or take other precautions)
    while performing the mappings for equation types 1, 2, and 3,
    to prevent overflow of intermediate results
    when <code>p1</code> is small
    and the <code>exp()</code>,
    <code>pow()</code>, or
    <code>sinh()</code>
    function is large.

    If present,
    the <span class="chunk">pCAL</span> chunk must appear
    before the first <span class="chunk">IDAT</span> chunk.
    Only one instance of the <span class="chunk">pCAL</span> chunk
    is permitted in a PNG datastream.

    <h3 id="C.sCAL">
        <span class="chunk">sCAL</span> Physical scale of image subject
    </h3>

    While the <span class="chunk">pHYs</span> chunk
    is used to record the physical size of the image itself
    as it was scanned
    or as it should be printed,
    certain images
    (such as maps, photomicrographs, astronomical surveys, floor plans, and others)
    may benefit from knowing the actual physical dimensions of the image's subject
    for remote measurement and other purposes.
    The <span class="chunk">sCAL</span> chunk serves this need. It contains:

    <table>
        <tr><th>Unit specifier:</th><td>1 byte</td></tr>
        <tr><th>Pixel width:</th><td>1 or more bytes (<a href="#DR.Floating-point-values">ASCII floating-point</a>)</td></tr>
        <tr><th>Null separator:</th><td>1 byte</td></tr>
        <tr><th>Pixel height:</th><td>1 or more bytes (<a href="#DR.Floating-point-values">ASCII floating-point</a>)</td></tr>
    </table>

    The following values are legal for the unit specifier:

    <table>
        <tr><th>1:</th><td>unit is the meter</td></tr>
        <tr><th>2:</th><td>unit is the radian</td></tr>
    </table>

    Following the unit specifier are two ASCII strings.
    The first string defines the physical width represented by one image pixel;
    the second string defines the physical height represented by one pixel.
    The two strings are separated by a zero byte (null character).
    As in the text chunks, there is no trailing zero byte for the final string.
    Each of these strings contains a floating-point constant
    in the format specified above
    (<a href="#DR.Floating-point-values">Floating-point values, Section 2.2</a>).
    Both values are required to be greater than zero.

    If present, this chunk must precede
    the first <span class="chunk">IDAT</span> chunk.

    <h3 id="C.gIFg">
        <span class="chunk">gIFg</span> GIF Graphic Control Extension
    </h3>

    The <span class="chunk">gIFg</span> chunk is provided
    for backward compatibility with the GIF89a Graphic Control Extension [[GIF]].
    It contains:

    <table>
       <tr><th>Disposal Method:</th><td>1 byte</td></tr>
       <tr><th>User Input Flag:</th><td>1 byte</td></tr>
       <tr><th>Delay Time:</th><td>2 bytes (byte order converted from GIF)</td></tr>
    </table>

    The Disposal Method indicates
    the way in which the graphic is to be treated
    after being displayed.
    The User Input Flag indicates
    whether user input is required before continuing.
    The Delay Time specifies
    the number of hundredths (1/100) of a second to delay
    before continuing with the processing of the datastream.
    Note that this field is to be byte-order-converted.

    The "Transparent Color Flag" and "Transparent Color Index" fields
    found in the GIF89a Graphic Control Extension
    are omitted from <span class="chunk">gIFg</span>.
    These fields should be converted using the transparency features of basic PNG.

    The GIF specification allows
    at most one Graphic Control Extension
    to preceed each graphic rendering block.
    Because a static PNG file holds only one image,
    it is expected that <span class="chunk">gIFg</span>
    will appear at most once, before <span class="chunk">IDAT</span>,
    but there is no strict requirement.

    Note: this chunk is provided solely to improve round-tripping
    when converting from animated GIF to static PNG.
    It has no effect on rendering of the PNG image.
    Including this chunk does not make the PNG animated.

<h3 id="C.gIFx">
    <span class="chunk">gIFx</span> GIF Application Extension
</h3>

    The <span class="chunk">gIFx</span> chunk is provided
    for backward compatibility with the GIF89a Application Extension [[GIF]].
    The Application Extension contains application-specific information.
    This chunk contains:

    <table>
        <tr><th>Application Identifier:</th><td>8 bytes</td></tr>
        <tr><th>Authentication Code:</th><td>3 bytes</td></tr>
        <tr><th>Application Data:</th><td><em>n</em> bytes</td></tr>
    </table>

    The Application Identifier is a sequence of eight printable ASCII characters
    used to identify the application creating the Application Extension.
    The Authentication Code is three additional bytes
    that the application may use to further validate the Application Extension.
    The remainder of the chunk is application-specific data
    whose content is not defined by the GIF specification.

    Note that GIF-to-PNG converters
    should not attempt to perform byte reordering
    on the contents of the Application Extension.
    The data is simply transcribed without any processing
    except for de-blocking GIF sub-blocks.

    Applications that formerly used GIF Application Extensions
    may define special-purpose PNG chunks
    to replace their application extensions.
    If a GIF-to-PNG converter recognizes the Application Identifier
    and is aware of a corresponding PNG chunk,
    it may choose to convert the Application Extension into that PNG chunk type
    rather than using <span class="chunk">gIFx</span>.

<h3 id="C.sTER">
    <span class="chunk">sTER</span> Indicator of Stereo Image
</h3>

    When present, the <span class="chunk">sTER</span> chunk
    indicates that the datastream contains a stereo pair of subimages
    within a single PNG image.

    The <span class="chunk">sTER</span> chunk contains:

    <table>
       <tr><th>Mode:</th><td>1 byte</td></tr>
    </table>

    The following values are legal for the mode specifier:

    <table>
        <tr><th>0:</th><td>cross-fuse layout</td></tr>
        <tr><th>1:</th><td>diverging-fuse layout</td></tr>
    </table>

    The <span class="chunk">sTER</span> chunk
    with <code>mode==0</code> or <code>mode==1</code>
    indicates that the datastream contains two subimages,
    encoded within a single PNG image.
    They are arranged side-by-side,
    with one subimage intended for presentation to the right eye
    and the other subimage intended for presentation to the left eye.

    The left edge of the right subimage
    must be on a column that is evenly divisible by eight,
    so that if interlacing is employed
    the two images will have coordinated interlacing.
    Padding columns between the two subimages
    must be introduced by the encoder if necessary.
    The <span class="chunk">sTER</span> chunk
    imposes no requirements on the contents of the padding pixels.
    For compatibility with software not supporting <span class="chunk">sTER</span>,
    it does not exempt the padding pixels from existing requirements;
    for example, in palette images,
    the padding pixels must be valid palette indices.
    The two subimages must have the same dimensions
    after removal of any padding.

    When <code>mode==0</code>,
    the right-eye image appears at the left
    and the left-eye image appears at the right,
    suitable for cross-eyed free viewing.
    When <code>mode==1</code>,
    the left-eye image appears at the left
    and the right-eye image appears at the right,
    suitable for divergent (wall-eyed) free viewing.

    Decoders that are aware of the <span class="chunk">sTER</span> chunk
    may display the two images in any suitable manner,
    with or without the padding.
    Decoders that are not aware of the <span class="chunk">sTER</span> chunk,
    and those that recognize the chunk
    but choose not to treat stereo pairs differently from regular PNG images,
    will naturally display them side-by-side in a manner
    suitable for free viewing.

    If present, the <span class="chunk">sTER</span> chunk
    must appear before the first <span class="chunk">IDAT</span> chunk.

    Given two subimages with width <code>subimage_width</code>,
    encoders can calculate the inter-subimage <code>padding</code>
    and total width <code>W</code> using the following pseudocode:

    <pre class="lang-pascal">
        padding  := 7 - ((subimage_width - 1) mod 8)
        W        := 2 * subimage_width + padding
    </pre>

    Given an image with width <code>W</code>,
    decoders can calculate the <code>subimage_width</code>
    and inter-subimage <code>padding</code>
    using the following pseudocode:

    <pre class="lang-pascal">
        padding := 15 - ((W - 1) mod 16)
        if (padding > 7) then error
        subimage_width := (W - padding) / 2
    </pre>

    Decoders can assume that the samples
    in the left and right subimages
    are cosited,
    such that the subimages and their centers
    are coincident at the projection plane.
    Decoders can also assume that the left and right subimages
    are intended to be presented directly
    to the right and left eyes of the user/viewer
    without independent scaling,
    rotation
    or displacement.
    I.e., the subimages will be presented at the same size
    in the same relative position and orientation
    to each eye of the viewer.

    Encoders should use the <span class="chunk">pHYs</span> chunk
    to indicate the pixel's size ratio
    when it is not 1:1.

    It is recommended that encoders use
    the cross-fusing layout (mode==0),
    especially when the image centers are separated
    by more than 65 millimeters
    when displayed on a typical monitor.

    <h2 id="RemoteChunks">
        Chunks Not Described Here
    </h2>

    <h3 id="R.dSIG">
        <span class="chunk">dSIG</span> Digital signature
    </h3>

    The <span class="chunk">dSIG</span> chunk
    provides a digital signature
    that guarantees that the contents
    of the portion of the entire datastream
    enclosed in a pair of such chunks
    has not changed
    since the digital signature was added.

    This chunk is described in detail
    in a separate document, [[!dSIG-spec]],
    which is accompanied by an example
    provided in [[dSIG-example]].

    <h3 id="R.fRAc">
        <span class="chunk">fRAc</span> Fractal image parameters
    </h3>

    The <span class="chunk">fRAc</span> chunk
    was intended to describe
    the parameters used to generate a fractal image.
    The specification
    for the contents of the <span class="chunk">fRAc</span> chunk
    was being developed by Tim Wegner, twegner @ phoenix.net.

    In the future, chunks will be fully specified
    before they are registered.

<h2 id="Keywords">
    Text Chunk Keywords
</h2>

<h3 id="K.Keywords">
    Additional Registered Keywords
</h3>

<h4 id="K.Collection">
    Collection
</h4>

    Name of a collection
    to which the image belongs.
    An image may belong to one or more collections,
    each named by a separate text chunk.


<h3 id="K.Syntax">
    Keyword Syntax
</h3>

    All registered textual keywords
    in text chunks
    and all other chunk types
    are limited to the ASCII characters A-Z, a-z, 0-9, space,
    and the following 20 symbols:

    <pre>
    ! " % & ' ( ) * + , - . / : ; < = > ? _
    </pre>

    but not the remaining 12 symbols:

    <pre>
    # $ @ [ \ ] ^ ` { | } ~
    </pre>

    This restricted set
    is the ISO-646 "invariant" character set [[!ISO 646]].
    These characters have the same numeric codes
    in all ISO character sets,
    including all national variants of ASCII.

<h2 id="DepChunks">
    Deprecated Chunks
</h2>

    The chunks listed in this section are registered, but deprecated. Encoders are <em>discouraged</em> from using them, and decoders are not encouraged to support them.

<h3 id="DC.gIFt">
    gIFt GIF Plain Text Extension
</h3>

    The <span class="chunk">gIFt</span> chunk
    was originally provided for backward compatibility
    with the GIF89a Plain Text Extension [[GIF]],
    but <span class="chunk">gIFt</span> is now deprecated
    because it suffers from some fundamental design flaws.

    * GIF considers a Plain Text Extension
        to be a Graphic Rendering Block,
        just like an image,
        so a GIF datastream
        containing an image
        and a Plain Text Extension
        is really a multi-image datastream
        with ordering issues
        (like associating each Graphic Control Extension
        with the proper Graphic Rendering Block).
        PNG, being a single-image format
        with no provisions for handling these ordering issues,
        is not equipped to contain both <span class="chunk">IDAT</span>
        and <span class="chunk">gIFt</span> simultaneously.
        Since <span class="chunk">IDAT</span> is required,
        <span class="chunk">gIFt</span> must be discouraged.

    * The Text Foreground Color and Text Background Color fields
        of the Plain Text Extension
        are converted to RGB,
        rather than being converted to RGBA
        or left as palette indexes.
        Therefore, transparency information can be lost.

    The <span class="chunk">gIFt</span> chunk contains:

    <table>
        <tr><th>Text Grid Left Position:</th><td>4 bytes (signed integer, byte order and size converted)</td></tr>
        <tr><th>Text Grid Top Position:</th><td>4 bytes (signed integer, byte order and size converted)</td></tr>
        <tr><th>Text Grid Width:</th><td>4 bytes (unsigned integer, byte order and size converted)</td></tr>
        <tr><th>Text Grid Height:</th><td>4 bytes (unsigned integer, byte order and size converted)</td></tr>
        <tr><th>Character Cell Width:</th><td>1 byte</td></tr>
        <tr><th>Character Cell Height:</th><td>1 byte</td></tr>
        <tr><th>Text Foreground Color:</th><td>3 bytes (R,G,B samples)</td></tr>
        <tr><th>Text Background Color:</th><td>3 bytes (R,G,B samples)</td></tr>
        <tr><th>Plain Text Data:</th><td><em>n</em> bytes</td></tr>
    </table>

    Text Grid Left Position,
    Top Position,
    Width,
    and Height
    specify the text area position
    and size in pixels.
    The converter must reformat these fields
    from 2-byte LSB-first unsigned integers
    to 4-byte MSB-first signed or unsigned integers.

    Note: GIF defines the position
    to be relative to the upper left corner
    of the logical screen.
    If an <span class="chunk">oFFs</span> chunk is also present,
    a decoder should assume that the oFFs chunk
    defines the offset of the image
    relative to the GIF logical screen;
    hence subtracting the oFFs values
    (converted from micrometers to pixels if necessary)
    from the Text Grid Left and Top Positions
    gives the text area position
    relative to the main PNG image.

    Character Cell Width and Height
    give the dimensions of each character in pixels.

    Text Foreground
    and Background Color
    give the colors to be used
    to render text foreground and background.

    Note: the GIF-to-PNG converter
    must replace the palette index values
    found in the GIF Plain Text Extension block
    with the corresponding palette entry.

    The remainder of the chunk is the text to be displayed.

    Note: this data is not in GIF sub-block format,
    but is a continuous datastream.

    <!-- what is the text encoding, is this specified at all -->

    <h2 id="Security">
        Security Considerations
    </h2>

    The normal precautions
    (see the <a href="https://w3c.github.io/PNG-spec/#13Security-considerations">Security
    considerations section</a>
    of the PNG specification)
    should be taken when displaying text
    contained in the <span class="chunk">sCAL</span> calibration name,
    <span class="chunk">pCAL</span> unit name,
    or any <a href="DR.Floating-point-values">ASCII floating-point fields</a>.

    Applications must take care
    to avoid underflow and overflow
    of intermediate results
    when converting data from one form to another
    according to the <span class="chunk">pCAL</span> mappings.

    <!-- eXIf security in main PNG spec -->

<h2 id="SampleCode">
    Appendix: Sample code
</h2>

    This appendix provides some sample code
    that can be used in encoding and decoding PNG chunks.
    It does not form a part of the specification.
    In the event of a discrepancy
    between the sample code in this appendix
    and the chunk definition,
    the chunk definition prevails.

<h3 id="SC.pCAL">
    <span class="chunk">pCAL</span> Sample code
</h3>

<pre class=include-code>
path: pcal.c
highlight: c
</pre>

<h3 id="SC.Fixed-point-gamma-corr">
    Fixed-point gamma correction
</h3>

<pre class=include-code>
path: pcal.c
highlight: c
</pre>

<h2 id="Rationale">
    Rationale
</h2>

<h3 id="R.pCAL">
    pCAL Rationale
</h3>

    This section gives the reasoning behind
    some of the design decisions
    in the pCAL chunk.
    It does not form a part of the specification.

<h4 id="pCAL.red">
    Redundant equation types
</h4>

    Equation types 1 and 2 seem to be equivalent.
    Why have both?

    We don't want to force people
    to do the exponentiation using
    <code>ln()</code> and <code>exp()</code>, since
    <code>pow()</code> may provide better accuracy
    in some floating-point math libraries.
    We also don't want to force people
    using base-10 logs
    to store a sufficiently accurate value
    of <code>ln(10)</code> in the
    <span class="chunk">pCAL</span> chunk.

    When the base is <code>e</code>,
    we don't want to force people
    to encode a sufficiently accurate value
    of <code>e</code> in the
    <span class="chunk">pCAL</span> chunk,
    or to use <code>pow()</code>
    when <code>exp()</code> is sufficient.

<h4 id="pCAL.x0x1">
What are <code>x0</code> and <code>x1</code> for?
</h4>

    First, <code>x0</code> and <code>x1</code> provide a way
    to recover the original data,
    losslessly,
    when the original range is not a power of two.
    Sometimes the digitized values
    do not have a range that fills the full depth of a PNG.

    <div class="example">
    For example, if the original samples
    range from 0 (corresponding to black)
    to 800 (corresponding to white),
    PNG requires that these samples be scaled
    to the range 0 to 65535.
    By recording <code>x0=0</code> and <code>x1=800 </code>
    we can recover the original samples,
    and we indicate the precision of the data.
    </div>

    Even if the original data had a range
    identical to a valid PNG image sample,
    like 0 (black) to 65535 (white),
    one might want to create a derived image
    by stretching the contrast
    in a limited intensity range
    containing the important details.

    <div class="example">
    For example,
    we might want to scale the samples
    so that 46000 becomes 0 (black) and
    47000 becomes 65535 (white).
    As in the previous case,
    by recording <code>x0=46000</code> and <code>x1.4.200</code>,
    we can recover the original data samples
    that fell between 46000 and 47000.
    </div>

<h4 id="pCAL.division">
    Integer division
</h4>

    Why define integer divison
    to round toward negative infinity?
    This is different from many C implementations
    and from all Fortran implementations,
    which round toward zero.

    We cannot leave the choice unspecified.
    If we were to specify rounding toward zero,
    we'd have to account for a discontinuity
    at zero.
    A division by positive <code>d</code>
    would map the <code>2d-1</code> values from
    <code>-(d-1)</code> through <code>d-1</code> to zero,
    but would map only <code>d</code> values
    to any other value;
    for example, <code>3d</code> through <code>4d-1</code>
    would be mapped to 3.
    Achieving lossless mappings
    in spite of this anomaly
    would be difficult.

<!-- eXIf Rationale in man PNG document -->


<h2 id="History">
    Appendix: Revision History
</h2>

<ul>
    <li>24 Jan Dec 2022 (version 1.6.0)</li>

    <ul>
        <li>Moved <span class="chunk">eXIF</span> to main PNG document</li>
        <li>Converted source document to Bikeshed</li>
    </ul>

    <li>15 July 2017 (version 1.5.0)
    <ul>
    <li>
    Added the <code>eXIf</code> chunk
    </li><li>
    Replaced ftp://www.simplesystems.org/pub/png/documents/ URL
    with http://libpng.download/documents/
    </li></ul>

    </li><li>12 June 2017 (version 1.4.1):

    <ul>
    <li>Changed "name=" markup to "id=" in order to pass w3c validation
    </li><li>Removed incorrect nroff-style page numbers from Table of Contents
    </li><li>Added internal links in the Table of Contents
    </li><li>Added reference to RFC-2119 for interpretation of "should", etc.
    </li><li>Removed trailing blanks
    </li><li>Added "Collection" keyword which was approved in 2004.
    </li><li>Added Cosmin Truta (who suggested the Collection keyword) to Credits

    </li></ul>

    </li><li>1 May 2008 (version 1.4.0):

    <ul>

    <li>Added the <code>dSIG</code> chunk.

    </li></ul>


    </li><li>31 August 2006 (version 1.3.0):

    <ul>

    <li>Added the <code>sTER</code> chunk.

    </li></ul>

    </li><li>14 July 1999 (version 1.2.0):

    <ul>

    <li>Deleted the <code>iTXt</code> chunk, which has been moved to the core spec.

    </li></ul>

    </li><li>9 February 1999 (version 1.1.1):

    <ul>

    <li>Added the <code>iTXt</code> chunk
    </li><li>Limited the character set for future registered keywords

    </li></ul>

    </li><li>30 December 1998 (version 1.1.0):

    <ul>

    <li>Added <code>pCAL</code> chunk and related sample code
    </li><li>Deprecated the <code>gIFT</code> chunk
    </li><li>Added sample gamma-correction code that uses integer arithmetic

    </li></ul>

    </li><li>11 March 1996 (version 0.96): First public release

    </li></ul>


<h2 id="Credits">
    Credits
</h2>

<h3 id="Credits.editors">
    Editors
</h3>

    * Chris Lilley, chris @ w3.org
    * Glenn Randers-Pehrson, glennrp @ users.sourceforge.net (versions 1.1 to 1.5)
    * Tom Lane, tgl @ sss.pgh.pa.us (edited the first release of this document)

<h3 id="Credits.contrib">
    Contributors
</h3>

    Names of contributors
    not already listed in the PNG specification
    are presented in alphabetical order:

    </p><ul>
    <li>Adeluc, <a href="http://www.adeluc.com">www.adeluc.com</a>,
    png&nbsp;@&nbsp;adeluc.com
    </li><li>Brendan Bolles
    </li><li>Todd French, <code>tfrench&nbsp;@&nbsp;sandia.gov</code>
    </li><li>Phil Harvey
    </li><li>Nancy M. Randers-Pehrson
    </li><li>Alaric B. Snell, <code>alaric&nbsp;@&nbsp;alaric-snell.com</code>
    </li><li>Michael Stokes
    </li><li>Jason Summers
    </li><li>Cosmin Truta, <code>cosmin&nbsp;@&nbsp;cs.toronto.edu</code>
    </li><li>Pavel Zlatovratskii
    </li></ul>

<h3 id="Credits.marks">
    Trademarks
</h3>

    <p>GIF is a service mark of CompuServe Incorporated.
    PostScript is a trademark of Adobe Systems.
