<!--
Before editing this document, please see
https://github.com/w3c/trusted-types/blob/master/README.md#spec-changes
-->

<pre class='metadata'>
Title: Trusted Types
Shortname: trusted-types
Group: webappsec
Level: none
Status: ED
URL: https://w3c.github.io/trusted-types/dist/spec/
Editor: Krzysztof Kotowicz, Google LLC https://google.com, koto@google.com
Former Editor: Mike West, Google LLC https://google.com, mkwst@google.com
Repository: w3c/trusted-types
Abstract: An API that allows applications to lock down powerful APIs to only accept non-spoofable, typed values in place of strings to prevent vulnerabilities caused by using these APIs with attacker-controlled inputs.
Markup Shorthands: algorithm yes, biblio yes, css no, dfn yes, markdown yes, markup yes
Ignored Terms: h1, h2, h3, h4, h5, h6, xmp, EmptyString
Complain About: missing-example-ids yes
Boilerplate: idl-index no
<!-- WPT Path Prefix: /trusted-types/ # Cannot add this, as it requires all the tests to be referenced in the spec -->
</pre>

<pre class="anchors">
spec: DOM-Parsing; urlPrefix: https://w3c.github.io/DOM-Parsing/
    type: enum; text: SupportedType
    type: abstract-op; text: fragment parsing algorithm; url: html-fragment-parsing-algorithm
spec: DOM-Parsing; url: https://w3c.github.io/DOM-Parsing/#dom-innerhtml; type: interface; text: InnerHTML
urlPrefix: https://html.spec.whatwg.org/multipage/common-dom-interfaces.html; type: dfn; spec: HTML
    text: reflect
url: https://heycam.github.io/webidl/#this; type: dfn; spec: WebIDL
    text: this
spec:ECMA-262; urlPrefix: https://tc39.github.io/ecma262/
    type:abstract-op; text:ToString; url: sec-tostring
    type:abstract-op; text:Get; url: sec-get-o-p
    type:dfn; text:current realm record; url: current-realm
spec: HTML; urlPrefix: https://html.spec.whatwg.org/
    type: dfn; text: prepare the script element; url: prepare-the-script-element
</pre>

<pre class="link-defaults">
spec:fetch; type:dfn; for:/; text:request
spec:DOM Parsing; type:idl; for:Element; text:innerHTML
spec:html; type:dfn; for:global object; text:realm
spec:csp3; type:dfn; text:csp list
spec:csp3; type:dfn; for:global object; text:csp list
spec:webidl; type:dfn; text:identifier
</pre>

<!-- TODO
Complain About: broken-links yes
-->

# Introduction # {#introduction}

*This section is not normative.*

Certain classes of vulnerabilities occur when a web application
takes a value from an attacker-controlled source (e.g. the
document URL parameter, or postMessage channel) and passes that value,
without appropriate sanitization to one of the
[[#injection-sinks|injection sinks]] - various Web API functions with
powerful capabilities.

These types of issues are traditionally difficult to prevent.
Applications commonly call those injection sinks with attacker-controlled
values without authors realizing it, since it's not clear if the
input was attacker-controlled when invoking the injection sink.
Due to the dynamic nature of JavaScript it's also difficult to ascertain
that such pattern is not present in a given program. It is often missed
during manual code reviews, and automated code analysis. As an example,
if `aString` contains untrusted data, `foo[bar] = aString` is a statement
that potentially can trigger a vulnerability, depending on a value
of `foo` and `bar`.

This document focuses on preventing DOM-Based Cross-Site Scripting
that occurs when attacker-controlled data reaches
[[#dom-xss-injection-sinks]], as that eventually causes execution of the
script payload controlled by the attacker. DOM XSS is prevalent in the
web applications as there are over 60 different
injection sinks (e.g. `Element.innerHTML`, or `Location.href` setters).

This document defines [[#trusted-types|Trusted Types]] - an API that allows applications
to lock down [=injection sinks=] to only accept non-spoofable, typed values
in place of strings. These values can in turn only be created from
application-defined [=policies=], allowing the authors to define rules
guarding dangerous APIs, reducing the attack surface to small, isolated parts
of the web application codebase, which are substantially easier to safeguard,
monitor and review.





## Goals ## {#goals}

*   Minimize the likelihood of client-side vulnerabilities that occur when
    calling powerful Web APIs with untrusted data - for example,
    minimize the likelihood of DOM XSS.

*   Encourage a design in which security decisions are
    encapsulated within a small part of the application.

*   Reduce security review surface for complex web application
    codebases.

*   Allow the detection of vulnerabilities similar to how regular
    programming errors are detected and surfaced to the developers, with the
    assist of dynamic and static analysis tools.

## Non-goals ## {#non-goals}

*   Prevent, or mitigate the result of injections into server-side generated
    markup, in specific reflections into the body of the scripts running in a
    document. To address server-side XSS vectors, we recommend existing
    solutions like templating systems or [[CSP3|CSP]]
    [=script-src=].
*   Address resource confinement, e.g. to prevent data exfiltration, or
    connecting to external sources via [[Fetch]].
*   Control subresource loading. Trusted Types aim to allow the authors to
    control loading resources that can script the current document, but not
    other subresources.
*   Prevent *cross-origin* JavaScript execution (for example, Trusted Types
    don't guard loading new documents with JavaScript code via `data:` URLs).
*   Prevent malicious authors of the web application's JavaScript code
    from being able to bypass the restrictions; attempting to protect against
    malicious authors would result in an overly complex and not-practical
    design.

## Use cases ## {#use-cases}

*   An author maintains a complex web application written in a framework
    that uses a secure templating system to generate the UI
    components. The application also depends on 3rd party client-side
    libraries that perform auxiliary tasks (e.g. analytics, performance
    monitoring). To ensure that none of these components introduce DOM
    XSS vulnerabilities, author defines a Trusted Type policy in the
    templating library and enables the enforcement for the [[#dom-xss-injection-sinks]].

*   A large team maintains a complex client-side application.
    They create a number of Trusted Types policies that satisfy the security
    requirements for the application. The team consolidates the policy
    implementations and the safe abstractions that use them in a small number
    of heavily reviewed files and requires extra approval for commits that
    affect these files.

    The need to create trusted values to affect [=injection sinks=],
    combined with additional scrutiny on changes that affect policy
    code, incents developers to use safe abstractions instead of writing ad-hoc
    string composition code when interacting with [[#dom-xss-injection-sinks]].

    When considering the risk of DOM XSS, security auditors find a
    small attack surface; they focus on the small amount of code that
    crafts the CSP header and provides the safe abstractions, and ignore the
    bulk of client-side application code.

*   An existing web application interacts with the DOM mostly using XSS-safe
    patterns (i.e. without using [[#dom-xss-injection-sinks]]). In a few places,
    however, it resorts to using risky patterns like loading additional script using
    JSONP, calling into `innerHTML` or `eval`.

    Review finds that those places do not cause XSS (e.g. because
    user-controlled data is not part of the input to those sinks), but it's
    hard to migrate the application off using these patterns.

    As such, CSP cannot be enforced on this application (without resorting to
    an unsafe version using `'unsafe-eval' 'unsafe-inline'`). Additionally,
    it's possible some codebase with DOM XSS flaws was not included in a review,
    or will be introduced in the future.

    To address this risk, the author converts the reviewed parts to using
    Trusted Types, and enables Trusted Type [=enforcement=]. Additional places
    using the injection sinks, should they exist in the future, are correctly
    blocked and reported.

*   A security team is tasked with assuring that the client-side heavy
    application code does not contain XSS vulnerabilities. Since the server side
    code is homogeneous (it's mostly an API backend), and the application
    enforces Trusted Types, the review only focuses on the Trusted Type
    [=policies=] and their rules. Later on the reviewed policy names are
    allowed in the 'trusted-types' CSP directive, safe for the developers to
    use.

    Any additional code, including the code of often-changing dependencies,
    can be excluded from the review, unless it creates a Trusted Type policy.
    Without it, the code cannot cause a DOM XSS.

# Framework # {#framework}

## Injection sinks ## {#injection-sinks}

*This section is not normative.*

An <dfn>injection sink</dfn> is a powerful Web API function that should only
be called with trusted, validated or appropriately sanitized input.
Calling the injection sink with attacker-controlled (i.e. injected) inputs
has undesired consequences and is considered a security vulnerability.

Note: The exact list of injection sinks covered by this document is defined in
[[#integrations]].

It's difficult to determine if a given application contains such a
vulnerability (e.g. if it is vulnerable to DOM XSS) only by analyzing
the invocations of [=injection sinks=], as their inputs (usually strings)
do not carry the information about their provenance. For example, while
the application might intentionally call `eval()` with dynamically created
inputs (e.g. for code obfuscation purposes), calling `eval()` on strings
supplied by the attacker is definitely a security vulnerability - but
it's not easy to distinguish one from the other.

This document organizes the injection sinks into groups, based on the
capabilities that sinks in a given group have. [=Enforcement=] for groups is controlled via <a>trusted-types-sink-group</a> values.

### HTML injection sinks ### {#html-injection-sinks}

*This section is not normative.*

HTML <a>injection sinks</a> parse input strings into a DOM tree. Since HTML parsers
can create arbitrary elements, including scripts, and set arbitrary attributes,
enabling the [=enforcement=] of any <a>trusted-types-sink-group</a> also implies
enforcing types for HTML injection sinks.

Examples of HTML injection sinks include:

  * Functions that parse & insert HTML strings into the document like
    [[DOM-Parsing#widl-Element-innerHTML|Element.innerHTML]],
    [[DOM-Parsing#widl-Element-outerHTML|Element.outerHTML]] setter, or {{Document/write|Document.write}}.
  * Functions that create a new same-origin {{Document}} with caller-controlled
    markup like {{DOMParser/parseFromString()}},

### DOM XSS injection sinks ### {#dom-xss-injection-sinks}

*This section is not normative.*

DOM XSS <a>injection sinks</a>  evaluate an input string value in a way that could
result in DOM XSS if that value is untrusted.

Examples of include:

  * Setters for {{Element}} attributes that accept a URL of the code to load
    like {{HTMLScriptElement/src!!attribute|HTMLScriptElement.src}},
  * Setters for {{Element}} attributes that accept a code to execute like
    {{HTMLScriptElement/text!!attribute|HTMLScriptElement.text}},
  * Functions that execute code directly like `eval`,
  * Navigation to 'javascript:' URLs.

Guarding DOM XSS injection sinks is controlled by the <a>trusted-types-sink-group</a> named 'script'.

## Trusted Types ## {#trusted-types}

To allow the authors to control values reaching injection sinks,
we introduce [[#trusted-types]]. The following list of
<dfn>Trusted Type</dfn>s indicating that a given value is
trusted by the authors to be used with an [=injection sink=] in a certain context.

Note: **Trusted** in this context signifies the fact that the application author
is confident that a given value can be safely used with an injection sink - she
*trusts* it does not introduce a vulnerability. That does not imply that the
value is indeed *safe*.

Note: This allows the authors to specify the intention when creating a given
value, and the user agents to introduce checks based on the type of
such value to preserve the authors' intent. For example, if
authors intend a value to be used as an HTML snippet, an attempt to
load a script from that value would fail.

Note: All Trusted Types wrap over an immutable string, specified when the
objects are created. These objects are unforgeable in a sense that
there is no JavaScript-exposed way to replace the inner string value
of a given object - it's stored in an internal slot with no setter
exposed.

Note: All Trusted Types stringifiers return the inner string value.
This makes it easy to incrementally migrate the application code into using
Trusted Types in place of DOM strings (it's possible to start
producing types in parts of the application, while still using and
accepting strings in other parts of the codebase). In that sense,
Trusted Types are backwards-compatible with the regular DOM APIs.

### <dfn interface>TrustedHTML</dfn> ### {#trusted-html}

The TrustedHTML interface represents a string that a developer can
confidently insert into an [=injection sink=] that will render it as HTML.
These objects are immutable
wrappers around a string, constructed via a {{TrustedTypePolicy}}'s
{{TrustedTypePolicy/createHTML(input)|createHTML}} method.

<pre class="idl">
[Exposed=(Window,Worker)]
interface TrustedHTML {
  stringifier;
  DOMString toJSON();
  static TrustedHTML fromLiteral(object templateStringsArray);
};
</pre>

TrustedHTML objects have a `[[Data]]` internal slot which holds a
DOMString. The slot's value is set when the object is created, and
will never change during its lifetime.

<dfn method for="TrustedHTML">toJSON()</dfn> method steps and the
<dfn for="TrustedHTML">stringification behavior</dfn> steps of a
TrustedHTML object are to return the value from its
`[[Data]]` internal slot.

The <dfn method for="TrustedHTML">fromLiteral(object templateStringsArray)</dfn> method, when invoked, returns the result of executing a [$Create a Trusted Type from literal$] algorithm,
with {{TrustedHTML}} as |type| and |templateStringsArray| as |template|.

### <dfn interface>TrustedScript</dfn> ### {#trusted-script}

The TrustedScript interface represents a string with an uncompiled
script body that a developer can confidently pass into an [=injection sink=]
that might lead to executing that script.
These objects are immutable wrappers
around a string, constructed via a {{TrustedTypePolicy}}'s
{{TrustedTypePolicy/createScript(input)|createScript}} method.

<pre class="idl">
[Exposed=(Window,Worker)]
interface TrustedScript {
  stringifier;
  DOMString toJSON();
  static TrustedScript fromLiteral(object templateStringsArray);
};
</pre>

TrustedScript objects have a `[[Data]]` internal slot which holds a
DOMString. The slot's value is set when the object is created, and
will never change during its lifetime.

<dfn method for="TrustedScript">toJSON()</dfn> method steps and the
<dfn for="TrustedScript">stringification behavior</dfn> steps of a
TrustedScript object are to return the value from its
`[[Data]]` internal slot.

The <dfn method for="TrustedScript">fromLiteral(object templateStringsArray)</dfn> method, when invoked, returns the result of executing a [$Create a Trusted Type from literal$] algorithm,
with {{TrustedScript}} as |type| and |templateStringsArray| as |template|.

### <dfn interface>TrustedScriptURL</dfn> ### {#trused-script-url}

The TrustedScriptURL interface represents a string that a developer
can confidently pass into an [=injection sink=] that will parse it as a URL of
an external script resource.
These objects are immutable wrappers around a
string, constructed via a {{TrustedTypePolicy}}'s
{{TrustedTypePolicy/createScriptURL(input)|createScriptURL}} method.

<pre class="idl">
[Exposed=(Window,Worker)]
interface TrustedScriptURL {
  stringifier;
  USVString toJSON();
  static TrustedScriptURL fromLiteral(object templateStringsArray);
};
</pre>

TrustedScriptURL objects have a `[[Data]]` internal slot which holds a
USVString. The slot's value is set when the object is created, and
will never change during its lifetime.

<dfn method for="TrustedScriptURL">toJSON()</dfn> method steps and the
<dfn for="TrustedScriptURL">stringification behavior</dfn> steps of a
TrustedScriptURL object are to return the value from its
`[[Data]]` internal slot.

The <dfn method for="TrustedScriptURL">fromLiteral(object templateStringsArray)</dfn> method, when invoked, returns the result of executing a [$Create a Trusted Type from literal$] algorithm,
with {{TrustedScriptURL}} as |type| and |templateStringsArray| as |template|.

## <dfn>Policies</dfn> ## {#policies-hdr}

Trusted Types can only be created via user-defined
and immutable policies that define rules for converting a string into
a given Trusted Type object. Policies allows the authors to specify custom,
programmatic rules that Trusted Types must adhere to.

<div class="example" id="sanitizing-policy">
Authors may define a
policy that will sanitize an HTML string, allowing only a subset of
tags and attributes that are known not to cause JavaScript
execution. Any {{TrustedHTML}} object created through this policy can then
be safely used in the application, and e.g. passed to `innerHTML`
setter - even if the input value was controlled by the attacker, the
policy rules neutralized it to adhere to policy-specific
contract.
<xmp highlight=js>
const sanitizingPolicy = trustedTypes.createPolicy('sanitize-html', {
  createHTML: (input) => myTrustedSanitizer(input, { superSafe: 'ok'}),
});

myDiv.innerHTML = sanitizingPolicy.createHTML(untrustedValue);
</xmp>
</div>

Note: [=Trusted Type=] objects wrap values that are explicitly trusted by
the author. As such, creating a Trusted Type object instance becomes a de
facto [=injection sink=], and hence code that creates a Trusted Type
instances is security-critical. To allow for strict control over Trusted Type
object creation we don't expose the constructors of those
directly, but require authors to create them via [=policies=].

Multiple policies can be created in a given [=Realm=], allowing the
applications to define different rules for different parts of the
codebase.

<div class="example" id="policy-reference">
Library initialized with a policy allowing it to load additional scripts from
a given host.
<xmp highlight=js>

const cdnScriptsPolicy = trustedTypes.createPolicy('cdn-scripts', {
  createScriptURL(url) {
    const parsed = new URL(url, document.baseURI);
    if (parsed.origin == 'https://mycdn.example') {
      return url;
    }
    throw new TypeError('invalid URL');
  },
});

myLibrary.init({policy: cdnScriptsPolicy});
</xmp>
</div>

Note: Trusted Type objects can only be created via policies. If
[=enforcement=] is enabled, only the policy code can trigger an action
of an [=injection sink=] and hence call-sites of the policies' `create*`
functions are the *only* security-sensitive code in the entire program
with regards to the actions of the [=injection sinks=].
Only this typically small subset of the entire code base needs to be
security-reviewed - there's no need to monitor or review
the [=injection sinks=] themselves, as User Agents [=enforcement|enforce=] that
those sinks will only accept matching Trusted Type objects, and these in turn
can only be created via policies.

The {{TrustedTypePolicyFactory/createPolicy()|createPolicy}} function returns a policy object which `create*` functions
will create Trusted Type objects after applying the policy
rules.

Note: While it's safe to freely use a policy that sanitizes its input anywhere in the application,
there might be a need to create lax policies to be used internally, and only to be
called with author-controlled input. For example, a client-side HTML
templating library, an HTML sanitizer library, or a JS asynchronous
code plugin loading subsystem each will likely need full control over
HTML or URLs. The API design facilitates that - each policy may only
be used if the callsite can obtain a reference to the policy (a return
value from {{TrustedTypePolicyFactory/createPolicy()}}). As such, policy
references can be treated as
<a href="https://en.wikipedia.org/wiki/Object-capability_model">capabilities</a>,
access to which can be controlled using JavaScript techniques
(e.g. via closures, internal function variables, or modules).

<div class="example" id="policy-capability">
Unsafe no-op policy reachable only from within a single code block to ascertain
that it's called only with no attacker-controlled values.
<xmp highlight=js>
(function renderFootnote() {
  const unsafePolicy = trustedTypes.createPolicy('html', {
    createHTML: input => input,
  });
  const footnote = await fetch('/footnote.html').then(r => r.text());
  footNote.innerHTML = unsafePolicy.createHTML(footnote);
})();
</xmp>
</div>

### <dfn interface>TrustedTypePolicyFactory</dfn> ### {#trusted-type-policy-factory}

TrustedTypePolicyFactory creates
{{TrustedTypePolicy|policies}} and verifies that Trusted Type object instances
were created via one of the policies.

Note: This factory object is exposed to JavaScript through `trustedTypes` property
on the global object - see [[#extensions-to-the-windoworworkerglobalscope-interface]].

<pre class="idl">
[Exposed=(Window,Worker)] interface TrustedTypePolicyFactory {
    TrustedTypePolicy createPolicy(
        DOMString policyName, optional TrustedTypePolicyOptions policyOptions = {});
    boolean isHTML(any value);
    boolean isScript(any value);
    boolean isScriptURL(any value);
    readonly attribute TrustedHTML emptyHTML;
    readonly attribute TrustedScript emptyScript;
    DOMString? getAttributeType(
        DOMString tagName,
        DOMString attribute,
        optional DOMString elementNs = "",
        optional DOMString attrNs = "");
    DOMString? getPropertyType(
        DOMString tagName,
        DOMString property,
        optional DOMString elementNs = "");
    readonly attribute TrustedTypePolicy? defaultPolicy;
};
</pre>

Internal slot `[[DefaultPolicy]]` may contain a {{TrustedTypePolicy}} object,
and is initially empty.

Internal slot `[[CreatedPolicyNames]]` is an <a>ordered set</a> of strings,
initially empty.

<div dfn-type="method" dfn-for="TrustedTypePolicyFactory">

:   <dfn>createPolicy(policyName, policyOptions)</dfn>
::  Creates a policy object that will implement the rules
    passed in the {{TrustedTypePolicyOptions}} |policyOptions| object.
    The allowed policy names may be restricted by [[#content-security-policy-hdr|Content Security Policy]].
    If the policy name is not on the allowlist defined in the [=trusted-types-directive|trusted-types=] CSP directive,
    the policy creation fails with a TypeError.
    Also, if unique policy names are enforced (i.e. `'allow-duplicates'` is not used),
    and `createPolicy` is called more than once with any given `policyName`,
    policy creation fails with a TypeError.

    <div class="example" id="create-policy-example">
    <xmp highlight=js>
    // HTTP Response header: Content-Security-Policy: trusted-types foo
    trustedTypes.createPolicy("foo", {}); // ok.
    trustedTypes.createPolicy("bar", {}); // throws - name not on the allowlist.
    trustedTypes.createPolicy("foo", {}); // throws - duplicate name.
    </xmp>
    </div>

    Returns the result of executing a [$Create a Trusted Type Policy$] algorithm,
    with the following arguments:
    <dl>
    <dt>factory</dt>
    <dd>[=this=] value</dd>
    <dt>policyName</dt>
    <dd>|policyName|</dt>
    <dt>options</dt>
    <dd>|policyOptions|</dd>
    <dt>global</dt>
    <dd>[=this=] value's [=relevant global object=]</dd>
    </dl>

    <div class="example" id="create-and-used-unexposed-policy">
    <xmp highlight="js">
    const myPolicy = trustedTypes.createPolicy('myPolicy', {
      // This security-critical code needs a security review;
      // a flaw in this code could cause DOM XSS.
      createHTML(input) { return aSanitizer.sanitize(input) },
      createScriptURL(input) {
        const u = new URL(dirty, document.baseURI);
        if (APPLICATION_CONFIG.scriptOrigins.includes(u.origin)) {
          return u.href;
        }
        throw new Error('Cannot load scripts from this origin');
      },
    });

    document.querySelector("#foo").innerHTML = myPolicy.createHTML(aValue);
    scriptElement.src = myPolicy.createScriptURL(
        'https://scripts.myapp.example/script.js');
    </xmp>
    </div>


: <dfn>isHTML(value)</dfn>
:: Returns true if value is an instance of {{TrustedHTML}} and has its `[[Data]]`  internal slot set, false otherwise.

    Note: `is*` functions are used to check if a given object is truly a legitimate
    [=Trusted Type=] object (i.e. it was created via one of the configured
    policies). This is to be able to detect a forgery of the objects via
    e.g. [[ECMASCRIPT#sec-object.create|Object.create]]
    or prototype chains manipulation.

    <div class="example" id="is-html-example">
    <xmp highlight=js>
    const html = policy.createHTML('<div>');
    trustedTypes.isHTML(html); // true

    const fake = Object.create(TrustedHTML.prototype);
    trustedTypes.isHTML(fake); // false

    trustedTypes.isHTML("<div>plain string</div>"); // false
    </xmp>
    </div>


: <dfn>isScript(value)</dfn>
:: Returns true if value is an instance of {{TrustedScript}} and has its `[[Data]]` internal slot set, false otherwise.

: <dfn>isScriptURL(value)</dfn>
:: Returns true if value is an instance of {{TrustedScriptURL}} and has its `[[Data]]` internal slot set, false otherwise.

: <dfn>getPropertyType(tagName, property, elementNs)</dfn>
:: Allows the authors to check if a Trusted Type is required for a given {{Element}}'s
    property (IDL attribute).

    This function returns the result of the following algorithm:

    1. Set |localName| to |tagName| in [=ASCII lowercase=].
    1. If |elementNs| is an empty string, set |elementNs| to [=HTML namespace=].
    1. Let |interface| be the [=element interface=] for |localName| and |elementNs|.
    1. If |interface| has an IDL <a spec="webidl">attribute</a> member which identifier is |attribute|, and
        {{StringContext}} IDL extended attribute appears on that attribute, return
        stringified {{StringContext}}'s identifier and abort further steps.

        Note: This also takes into account all members of [=interface mixins=] that
        |interface| [=includes=].

    1. Return null.

    <div class="example" id="get-property-type-example">
    <xmp highlight="js">
    trustedTypes.getPropertyType('div', 'innerHTML'); // "TrustedHTML"
    trustedTypes.getPropertyType('foo', 'bar'); // null
    </xmp>
    </div>


: <dfn>getAttributeType(tagName, attribute, elementNs, attrNs)</dfn>
:: Allows the authors to check if, (and if so, which) Trusted Type is required
    for a given {{Element}}'s content attribute, such that later on the call
    to `Element.setAttribute` passes the correct argument type.

    This function returns the result of the following algorithm:

    1. Set |localName| to |tagName| in [=ASCII lowercase=].
    1. Set |attribute| to |attribute| in [=ASCII lowercase=].
    1. If |elementNs| is an empty string, set |elementNs| to [=HTML namespace=].
    1. If |attrNs| is an empty string, set |attrNs| to null.
    1. Let |interface| be the [=element interface=] for |localName| and |elementNs|.
    1. If |interface| does not have an IDL <a spec="webidl">attribute</a> that [=reflects=] a content attribute with
        |localName| local name and |attrNs| namespace,
        return undefined and abort further steps. Otherwise, let |idlAttribute| be that IDL <a spec="webidl">attribute</a>.
    1. If {{StringContext}} IDL extended attribute appears on |idlAttribute|, return
        stringified {{StringContext}}'s identifier and abort further steps.
    1. Return null.

    <div class="example" id="get-attribute-type-example">
    <xmp highlight="js">
    trustedTypes.getAttributeType('script', 'src'); // "TrustedScriptURL"
    trustedTypes.getAttributeType('foo', 'bar'); // null
    </xmp>
    </div>

</div>

<div dfn-type="attribute" dfn-for="TrustedTypePolicyFactory">

: <dfn>emptyHTML</dfn>
:: is a {{TrustedHTML}} object with its `[[Data]]` internal slot value set to an empty string.

<div class="example" id="empty-html-example">
<xmp highlight="js">
anElement.innerHTML = trustedTypes.emptyHTML; // no need to create a policy
</xmp>
</div>

: <dfn>emptyScript</dfn>
:: is a {{TrustedScript}} object with its `[[Data]]` internal slot value set to an empty string.

Note: This object can be used to detect if the runtime environment has [[#csp-eval]]. While native Trusted Types implementation can
support `eval(TrustedScript)`, it is impossible for a polyfill to  emulate that, as
eval(TrustedScript) will return its input without unwrapping and evaluating the code.

<div class="example" id="empty-script-example">
<xmp highlight="js">
// With native Trusted Types support eval(trustedTypes.emptyScript) will execute and return falsy undefined.
// Without it, eval(trustedTypes.emptyScript) will return a truthy Object.
const supportsTS = !eval(trustedTypes.emptyScript);

eval(supportsTS ? myTrustedScriptObj : myTrustedScriptObj.toString());
</xmp>
</div>

: <dfn>defaultPolicy</dfn>
:: Returns the value of `[[DefaultPolicy]]` internal slot, or null if the slot is empty.

<div class="example" id="defaultpolicy-example">
<xmp highlight="js">
trustedTypes.defaultPolicy === null;  // true
const dp = trustedTypes.createPolicy('default', {});
trustedTypes.defaultPolicy === dp;  // true
</xmp>
</div>

</div>

### <dfn interface>TrustedTypePolicy</dfn> ### {#trusted-type-policy}

Policy objects implement a TrustedTypePolicy interface and define a
group of functions creating Trusted Type objects.
Each of the `create*` functions converts a string value to a given Trusted Type variant, or
throws a TypeError if a conversion of a given value is disallowed.

<pre class="idl">
[Exposed=(Window,Worker)]
interface TrustedTypePolicy {
  readonly attribute DOMString name;
  TrustedHTML createHTML(DOMString input, any... arguments);
  TrustedScript createScript(DOMString input, any... arguments);
  TrustedScriptURL createScriptURL(DOMString input, any... arguments);
};
</pre>

Each policy has a <dfn dfn-for="TrustedTypePolicy">name</dfn>.

Each TrustedTypePolicy object has an `[[options]]` internal slot, holding the {{TrustedTypePolicyOptions}} object describing the actual behavior of the policy.

<div dfn-type="method" dfn-for="TrustedTypePolicy">

: <dfn>createHTML(input, ...arguments)</dfn>
::  Returns the
    result of executing the [$Create a Trusted Type$] algorithm, with the
    following arguments:
    <dl>
      <dt>policy</dt>
      <dd>[=this=] value</dt>
      <dt>trustedTypeName</dt>
      <dd>`"TrustedHTML"`</dd>
      <dt>value</dt>
      <dd>input</dd>
      <dt>arguments</dt>
      <dd>arguments</dd>
    </dl>

: <dfn>createScript(input, ...arguments)</dfn>
::  Returns the
    result of executing the [$Create a Trusted Type$] algorithm, with the
    following arguments:
    <dl>
      <dt>policy</dt>
      <dd>[=this=] value</dt>
      <dt>trustedTypeName</dt>
      <dd>`"TrustedScript"`</dd>
      <dt>value</dt>
      <dd>input</dd>
      <dt>arguments</dt>
      <dd>arguments</dd>
    </dl>


: <dfn>createScriptURL(input, ...arguments)</dfn>
::  Returns the
    result of executing the [$Create a Trusted Type$] algorithm, with the
    following arguments:
    <dl>
      <dt>policy</dt>
      <dd>[=this=] value</dt>
      <dt>trustedTypeName</dt>
      <dd>`"TrustedScriptURL"`</dd>
      <dt>value</dt>
      <dd>input</dd>
      <dt>arguments</dt>
      <dd>arguments</dd>
    </dl>

</div>

### <dfn dictionary>TrustedTypePolicyOptions</dfn> ### {#trusted-type-policy-options}

This dictionary holds author-defined functions for converting string
values into trusted values. These functions do not create [=Trusted Type=]
object instances directly - this behavior is provided by
{{TrustedTypePolicy}}.

<pre class="idl">
dictionary TrustedTypePolicyOptions {
   CreateHTMLCallback? createHTML;
   CreateScriptCallback? createScript;
   CreateScriptURLCallback? createScriptURL;
};
callback CreateHTMLCallback = DOMString (DOMString input, any... arguments);
callback CreateScriptCallback = DOMString (DOMString input, any... arguments);
callback CreateScriptURLCallback = USVString (DOMString input, any... arguments);
</pre>

### <dfn>Default policy</dfn> ### {#default-policy-hdr}

*This section is not normative.*

One of the policies, the policy with a [=TrustedTypePolicy/name=] `"default"`, is special;
When an [=injection sink=] is passed a string (instead of a
Trusted Type object), this policy will be implicitly called by
the user agent with the non trusted string value, Trusted Type of the sink and
the sink type, respectively.

This allows the application to define a fallback behavior to use instead of
causing a violation. The intention is to allow the applications to recover from
an unexpected data flow, and sanitize the
potentially attacker-controlled string "as a last resort", or reject a value
if a safe value cannot be created. Errors thrown from within a policy are
propagated to the application.

If the default policy doesn't exist, or if its appropriate `create*` function
returns *null* or *undefined*, it will cause a CSP violation. In the
enforcing mode, an error will be thrown, but in report-only the original value
passed to the default policy will be used.

Note: This optional behavior allows for introducing Trusted Type [=enforcement=]
to applications that are still using legacy code that uses injection sinks.
Needless to say, this policy should
necessarily be defined with very strict rules not to bypass the security
restrictions in unknown parts of the application. In an extreme
case, a lax, no-op default policy defeats all the benefits of using Trusted Types
to protect access to [=injection sinks=]. If possible,
authors should resort to a default policy in a transitional period
only, use it to detect and rewrite their dependencies that use injection
sinks unsafely and eventually phase out the usage of the default policy entirely.

Note: See [[#get-trusted-type-compliant-string-algorithm]] for details on how
the default policy is applied.

<div class="example" id="default-policy-example">
<xmp highlight="js">
// Content-Security-Policy: trusted-types default; require-trusted-types-for 'script'

trustedTypes.createPolicy('default', {
  createScriptURL: (value, type, sink) => {
    console.log("Please refactor.");
    return value + '?default-policy-used&type=' + encodeURIComponent(type) +
          '&sink=' + encodeURIComponent(sink);
  }
});

aScriptElement.src = "https://cdn.example/script.js";
// Please refactor.
console.log(aScriptElement.src);
// https://cdn.example/script.js?default-policy-used&type=TrustedScriptURL&sink=HTMLScriptElement%20src
</xmp>
</div>


## <dfn>Enforcement</dfn> ## {#enforcement-hdr}

Note: Enforcement is the process of checking that a value
has an appropriate type before it reaches an [=injection sink=].

The JavaScript API that allows authors to create policies and Trusted Types objects from them is always
available (via {{WindowOrWorkerGlobalScope/trustedTypes}}). Since [=injection sinks=] stringify their security sensitive
arguments, and [=Trusted Type=] objects stringify to their inner string values, this allows the authors
to use Trusted Types in place of strings.

To secure the access to [=injection sinks=], on top of the JavaScript code using the Trusted Types,
the user agent needs to enforce them i.e. assert that the injection sinks from a given group are *never*
called with string values, and Trusted Type values are used instead. This section describes how authors
may control this enforcing behavior.

Authors may also control their [=policies=] by specifying rules around policy creation.

### Content Security Policy ### {#content-security-policy-hdr}

Applications may control Trusted Type enforcement via [[CSP#policy-delivery|configuring a Content Security Policy]]. This document defines new directives that correspond to Trusted Types rules.
The [=require-trusted-types-for-directive|require-trusted-types-for=] directive specifies the [=injection sinks=] groups, for which the types should be required. The [[#trusted-types-csp-directive|trusted-types]] directive controls how [=policies=] can be created.

Note: Using CSP mechanisms allows the authors to prepare their application for enforcing Trusted Types
via using the <a http-header>Content-Security-Policy-Report-Only</a> HTTP Response header.

Note: Most of the enforcement rules are defined as modifications of the
algorithms in other specifications, see [[#integrations]].

# Algorithms # {#algorithms}

## <dfn abstract-op>Create a Trusted Type Policy</dfn> ## {#create-trusted-type-policy-algorithm}

To create a {{TrustedTypePolicy}}, given a {{TrustedTypePolicyFactory}} (|factory|),
a string (|policyName|), {{TrustedTypePolicyOptions}} dictionary (|options|), and a
[=Realm/global object=] (|global|) run these steps:

1.  Let |allowedByCSP| be the result of executing [$Should Trusted Type policy
    creation be blocked by Content Security Policy?$] algorithm with |global|,
    |policyName| and |factory|'s `[[CreatedPolicyNames]]` slot value.
1.  If |allowedByCSP| is `"Blocked"`, throw a TypeError and abort further steps.
1.  If |policyName| is `default` and the |factory|'s `[[DefaultPolicy]]` slot
    value is not empty, throw a TypeError and abort further steps.
1.  Let |policy| be a new {{TrustedTypePolicy}} object.
1.  Set |policy|'s `name` property value to |policyName|.
1.  Let |policyOptions| be a new {{TrustedTypePolicyOptions}} object.
1.  Set |policyOptions|
    {{TrustedTypePolicy/createHTML()|createHTML}} property to |option|'s
    {{TrustedTypePolicyOptions/createHTML|createHTML}} property value.
1.  Set |policyOptions| {{TrustedTypePolicy/createScript()|createScript}}
    property to |option|'s
    {{TrustedTypePolicyOptions/createScript|createScript}} property value.
1.  Set |policyOptions| {{TrustedTypePolicy/createScriptURL()|createScriptURL}}
    property to |option|'s
    {{TrustedTypePolicyOptions/createScriptURL|createScriptURL}} property value.
1.  Set |policy|'s `[[options]]` internal slot value to *policyOptions*.
1.  If the |policyName| is `default`, set the |factory|'s `[[DefaultPolicy]]` slot value to |policy|.
1.  Append |policyName| to |factory|'s `[[CreatedPolicyNames]]`.
1.  Return |policy|.

## <dfn abstract-op>Create a Trusted Type</dfn> ## {#create-a-trusted-type-algorithm}

Given a {{TrustedTypePolicy}} |policy|, a type name |trustedTypeName|,
a string |value| and a list |arguments|, execute the following steps:

1.  Let |functionName| be a function name for the given |trustedTypeName|,
    based on the following table:

    <table>
      <tr>
        <th>Function name</th>
        <th>Trusted Type name </th>
      </tr>
      <tr>
        <td>"createHTML"</td>
        <td>"TrustedHTML"</td>
      </tr>
      <tr>
        <td>"createScript"</td>
        <td>"TrustedScript"</td>
      </tr>
      <tr>
        <td>"createScriptURL"</td>
        <td>"TrustedScriptURL"</td>
      </tr>
    </table>

1.  Let |options| be the value of |policy|'s `[[options]]` slot.
1.  Let |function| be the value of the property in |options| named |functionName|.
1.  If |function| is `null`, throw a TypeError.
1.  Let |policyValue| be the result of invoking |function| with
    |value| as a first argument, items of |arguments| as subsequent arguments,
    and [[ECMASCRIPT#sec-method|callback **this** value]] set to `null`.
1.  If |policyValue| is an error, return |policyValue| and abort the following steps.
1.  If |policy|'s [=TrustedTypePolicy/name=] is `"default"` and the |policyValue|
    is null or undefined, return |policyValue|.

    Note: This is used in a [$Get Trusted Type compliant string$] algorithm to signal that
    a value was rejected.
1.  Let |dataString| be the result of stringifying |policyValue|.
1.  Let |trustedObject| be a new instance of an interface with a type
    name |trustedTypeName|, with its `[[Data]]` internal slot value
    set to |dataString|.
1.  If |trustedObject| is a {{TrustedScript}}, set its `[[HostDefinedCodeLike]]` internal slot value to the value in its `[[Data]]` slot.

    Note: This adds an integration point with [dynamic-code-brand-checks proposal](https://tc39.es/proposal-dynamic-code-brand-checks/).
1.  Return |trustedObject|.

## <dfn abstract-op>Create a Trusted Type from literal</dfn> ## {#create-a-trusted-type-from-literal-algorithm}

Given a {{TrustedType}} type |type| and an object |template|, execute the following steps:

1.  If [$check templatedness$] of |template| returns false, throw a {{TypeError}}.
1.  If [$Get$](|template|, "length") is not equal to 1, throw a {{TypeError}}.
1.  Let |templatedValue| be the result of [$Get$](|template|, 0).
1.  If |type| is {{TrustedHTML}}, perform the following steps:
    1.  Let |templateNode| be the results of [=create an element|creating an element=] given "template", the [=HTML namespace=] and [=current global object=]'s [=associated Document=].
    1.  Assert: |templateNode| is {{HTMLTemplateElement}}.
    1.  Let |fragment| be the result of invoking [$fragment parsing algorithm$], with |templatedValue| as <var ignore>markup</var>, and |templateNode| as a <var ignore>context element</var>.
    1.  Set |templatedValue| to be the result of invoking [=HTML fragment serialization algorithm=], with |fragment| as <var ignore>the node</var>.

1. Return a new instance of an interface |type|, with its `[[Data]]` internal slot value set to |templatedValue|.

## Check templatedness of an object ## {#check-templatedness-algorithm}

To <dfn abstract-op>check templatedness</dfn> of an object |value|, perform the following steps. They return a boolean value:

1. Let |realm| be the <a>current Realm Record</a>.
1. For each |item| of |realm|.\[[TemplateMap]], if |item|.\[[Array]] is |value|, return true.
1. Return false.

## <dfn abstract-op>Get Trusted Type compliant string</dfn> ## {#get-trusted-type-compliant-string-algorithm}

This algorithm will return a string that can be used with an
[=injection sink=], optionally unwrapping it from a matching [=Trusted Type=].
It will ensure that the Trusted Type [=enforcement=] rules were respected.

Given a {{TrustedType}} type (|expectedType|), a [=Realm/global object=] (|global|),
{{TrustedType}} or a string (|input|), a string (|sink|) and a string (|sinkGroup|), run these steps:

1.  Let |cspList| be the |global|'s <a>CSP list</a>.
1.  If |cspList| is `null` or does not contain a [=content security policy object|policy=]
    which [=directive set=] containing a [=directive=] with a name `"require-trusted-types-for"`,
    or that directive does not contain a <a>trusted-types-sink-group</a> which is a match for a value |sinkGroup|,
    return stringified |input| and abort these steps.
1.  If |input| has type |expectedType|, return stringified
    |input| and abort these steps.
1.  Let |convertedInput| be the result of executing [$Process value with a default policy$] with the same arguments as this algorithm.
1.  If the algorithm threw an error, rethrow the error and abort the following steps.
1.  If |convertedInput| is `null` or `undefined`, execute the following steps:
    1.  Let |disposition| be the result of executing [$Should sink type mismatch violation be blocked by Content Security Policy?$] algorithm,
        passing |global|, |input| as |source|, |sinkGroup| and |sink|.
    1.  If |disposition| is `“Allowed”`, return stringified |input| and abort further steps.

        Note: This step assures that the default policy rejection will be reported, but ignored in a report-only mode.
    1. Throw a TypeError and abort further steps.
1. Assert: |convertedInput| has type |expectedType|.
1. Return stringified |convertedInput|.

## <dfn abstract-op>Process value with a default policy</dfn> ## {#process-value-with-a-default-policy-algorithm}

This algorithm routes a value to be assigned to an [=injection sink=]  through a default policy, should one exist.

Given a {{TrustedType}} type (|expectedType|), a [=Realm/global object=] (|global|),
{{TrustedType}} or a string (|input|), and a string (|sink|), run these steps:

1.  Let |defaultPolicy| be the value of |global|'s [=Window/trusted type policy factory=]'s `[[DefaultPolicy]]` slot. If the slot is empty, return `null`.
1.  Let |convertedInput| be the result of executing [$Create a
    Trusted Type$] algorithm, with the following arguments:
    *  |defaultPolicy| as |policy|
    *  |input| as |value|
    *  |expectedType|’s type name as |trustedTypeName|
    *  &laquo; |trustedTypeName|, |sink| &raquo; as |arguments|
1. If the algorithm threw an error, rethrow it. Otherwise, return |convertedInput|.

## <dfn abstract-op>Prepare the script URL and text</dfn> ## {#prepare-script-url-and-text}

Given an {{HTMLScriptElement}} (|script|), this algorithm performs the following steps:

1.  If |script| does not have a <{script/src}> content attribute, set its {{HTMLScriptElement/[[ScriptURL]]}} internal slot value to `null`.

1.  Otherwise, if |script|'s {{HTMLScriptElement/[[ScriptURL]]}} internal slot value is not equal to its <{script/src}> attribute value,
    set |script|'s {{HTMLScriptElement/[[ScriptURL]]}} to the result of executing [$Get Trusted Type compliant string$], with the following arguments:
      * {{TrustedScriptURL}} as |expectedType|,
      * |script|'s {{Document}}'s [=relevant global object=] as |global|,
      * |script|'s <{script/src}> attribute value as |input|,
      * `HTMLScriptElement src` as |sink|,
      * `'script'` as |sinkGroup|.

    If the algorithm threw an error, rethrow the error and abort further steps.

1.  If |script|'s {{HTMLScriptElement/[[ScriptText]]}} internal slot value is not equal to its [=child text content=],
    set |script|'s {{HTMLScriptElement/[[ScriptText]]}} to the result of executing [$Get Trusted Type compliant string$], with the following arguments:
      * {{TrustedScriptURL}} as |expectedType|,
      * |script|'s {{Document}}'s [=relevant global object=] as |global|,
      * |script|'s [=child text content=] attribute value,
      * `HTMLScriptElement text` as |sink|,
      * `'script'` as |sinkGroup|.

    If the algorithm threw an error, rethrow the error.

# Integrations # {#integrations}

<pre class="idl">
typedef [StringContext=TrustedHTML] DOMString HTMLString;
typedef [StringContext=TrustedScript] DOMString ScriptString;
typedef [StringContext=TrustedScriptURL] USVString ScriptURLString;
typedef (TrustedHTML or TrustedScript or TrustedScriptURL) TrustedType;
</pre>

## Integration with WebIDL ## {#webidl-integration}

Issue: Keep in sync with https://github.com/heycam/webidl/pull/841.

<h3 id="StringContext" extended-attribute lt="StringContext">[StringContext]</h3>

This specification defines a new [{{StringContext}}] [=extended attribute=].

If the [{{StringContext}}] [=extended attribute=] appears on {{DOMString}} or {{USVString}}, it
modifies how the value is converted to the IDL type, causing additional value validation to
adhere to the context the string is used in.

The [{{StringContext}}] extended attribute must [=takes an identifier|take an identifier=]. The [=identifier=]
must be one of {{TrustedHTML}}, {{TrustedScript}} and {{TrustedScriptURL}}.

Issue: Make sure this is OK, otherwise use strings and convert them to TrustedXYZ in this spec only.

[{{StringContext}}] extended attribute may only annotate a type of a [=regular attribute=] or
a [=regular operation=] argument. A type annotated with the [{{StringContext}}]
extended attribute must not appear in a [=read only=] attribute. The [=regular attribute=] or
a [=regular operation=] argument that the type annotated with the [{{StringContext}}] extended
attribute appears in is its <dfn>related construct</dfn>.

A type that is not {{DOMString}} or {{USVString}} must not be associated with the [{{StringContext}}] extended attribute.

See the rules for converting ECMAScript values to the IDL types in [[webidl#es-DOMString]]
for the specific requirements that the use of [{{StringContext}}] entails.

<div class="example" id="webidl-stringcontext-example">

    In the following [=IDL fragment=],
    a [=variadic=] [=operation=] is declared
    that uses the [{{StringContext}}] [=extended attribute=]
    on all its arguments:

    <pre highlight="webidl">
        interface Document {
          undefined write([StringContext=html] DOMString... text);
        };
    </pre>
</div>

### Extended attributes applicable to types ### {#webidl-applicable-to-types}

The following extended attributes are <dfn for="extended attributes" noexport>applicable to types</dfn>:
 [{{AllowShared}}],
 [{{Clamp}}],
 [{{EnforceRange}}]<ins>,
 [{{StringContext}}]</ins> and
 [{{LegacyNullToEmptyString}}].

### Type conversion ### {#webidl-type-conversion}

This specification modifies the algorithm implementing the conversion to DOMString in [[webidl#es-DOMString]]:

An ECMAScript value |V| is [=converted to an IDL value|converted=]
to an IDL {{DOMString}} value by running the following algorithm:

  1.  <ins>If the conversion is to an IDL type associated with the
      [{{StringContext}}] extended attribute, then set |V| to the result of [=validate the string in context=], passing
      [=this=], |V|, the {{StringContext}} extended attribute [=identifier=], and the [=identifier=]
      of the [{{StringContext}}] extended attribute [=related construct=].

      Note: That algorithm may throw a TypeError.
      </ins>
  1.  If |V| is <emu-val>null</emu-val> and the conversion is to an IDL type
      associated with the [{{LegacyNullToEmptyString}}] extended
      attribute, then return the {{DOMString}} value that represents the empty string.
  1.  Let |x| be <a abstract-op>ToString</a>(|V|).
  1.  Return the IDL {{DOMString}} value that represents the same sequence of code units as the one the ECMAScript String value |x| represents.

### Validate the string in context ### {#webidl-validate-the-string-in-context}

This specification adds a following section to [[webidl#es-security]].

Certain algorithms in [[webidl#es-type-mapping]] are defined to
<dfn id="dfn-validate-the-string-in-context" export>validate the string in context</dfn> on a given
value. This check is used to determine whether a given value
is appropriate for its {{StringContext}}. This validation takes the following four inputs:

1.  the [=platform object=] on
    which the operation invocation or attribute access is being done,
1.  the value to validate,
1.  the {{StringContext}} [=identifier=], and
1.  the [=identifier=] of the operation or attribute.

The algorithm returns an ECMAScript String value, or throws a TypeError.

Note: The HTML Standard defines how the validation is performed. [[!HTML]]

## Integration with HTML ## {#integration-with-html}

{{Window}} and {{Worker}} objects have a <dfn for="Window">trusted type policy factory</dfn>,
which is a {{TrustedTypePolicyFactory}} object.

### Extensions to the WindowOrWorkerGlobalScope interface ### {#extensions-to-the-windoworworkerglobalscope-interface}

This document extends the {{WindowOrWorkerGlobalScope}} interface defined by [[HTML5|HTML]]:

<pre class="idl">
partial interface mixin WindowOrWorkerGlobalScope {
  readonly attribute TrustedTypePolicyFactory trustedTypes;
};
</pre>

The {{WindowOrWorkerGlobalScope/trustedTypes}} getter steps are to return [=this=]'s [=relevant global object=]'s [[#integration-with-html|trusted
type policy factory]].

### Extensions to the Document interface ### {#extensions-to-the-document-interface}

This document modifies the {{Document}} interface defined by [[HTML5|HTML]]:

<pre class="idl exclude">
partial interface Document {
  [CEReactions] undefined write(HTMLString... text);
  [CEReactions] undefined writeln(HTMLString... text);
};
</pre>

### Enforcement for scripts ### {#enforcement-in-scripts}

#### Slots with trusted values #### {#slots-with-trusted-values}

Issue: Figure out if we can drop {{HTMLScriptElement/[[ScriptURL]]}} slot after IDL + DOM changes.

This document modifies {{HTMLScriptElement}}s. Each script has:

: <dfn for="HTMLScriptElement" lt="[[ScriptURL]]" attribute>`[[ScriptURL]]`</dfn> internal slot.
::  A string, containing the URL to execute the script from
    that was set through a {{StringContext}} compliant sink. Equivalent to
    {{HTMLScriptElement/src}} attribute value. Initially null.

: <dfn for="HTMLScriptElement" lt="[[ScriptText]]" attribute>`[[ScriptText]]`</dfn> internal slot.
::  A string, containing the body of the script to execute that was set
    through a {{StringContext}} compliant sink. Equivalent to script's
    [=child text content=]. Initially null.

#### Setting slot values #### {#setting-slot-values}

This document modifies how {{HTMLScriptElement}} [=child text content=] can be set to allow applications to control dynamically created scripts. It does so by
adding the {{HTMLElement/innerText}} and {{Node/textContent}} attributes directly on {{HTMLScriptElement}}. The behavior of the attributes remains the same
as in their original counterparts, apart from additional behavior triggered by the {{StringContext}} extended attribute presence.

Note: Using these IDL attributes is the recommended way of dynamically setting URL or a text of a script. Manipulating attribute nodes or text nodes directly will call a default policy on the final value when the script is prepared.

Issue: Figure out what to do with script.setAttribute('src'). See [DOM#789](https://github.com/whatwg/dom/issues/789).

<pre class="idl exclude">
partial interface HTMLScriptElement {
 [CEReactions] attribute [LegacyNullToEmptyString] ScriptString innerText;
 [CEReactions] attribute ScriptString? textContent;
 [CEReactions] attribute ScriptURLString src;
 [CEReactions] attribute ScriptString text;
};
</pre>

On setting the {{HTMLElement/innerText}}, {{Node/textContent}} and {{HTMLScriptElement/text}} IDL attributes execute the following algorithm:

1. Set {{HTMLScriptElement/[[ScriptText]]}} internal slot value to the stringified attribute value.
1. Perform the usual attribute setter steps.


On setting the {{HTMLScriptElement/src}} IDL attribute, execute the following algorithm:

1. Set {{HTMLScriptElement/[[ScriptURL]]}} internal slot value to the stringified attribute value.
1. Perform the usual attribute setter steps.

#### Slot value verification #### {#slot-value-verification}

The first few steps of the [=prepare the script element=] algorithm are modified as follows:

  <ol>
  <li><p>If <var>el</var>'s <a href=https://html.spec.whatwg.org/#already-started id=script-processing-model:already-started-3>already started</a> is true, then return.
  <li><p>Let <var>parser document</var> be <var>el</var>'s <a href=https://html.spec.whatwg.org/#parser-document id=script-processing-model:parser-document-2>parser document</a>.
  <li>
    <p>Set <var>el</var>'s <a href=https://html.spec.whatwg.org/#parser-document id=script-processing-model:parser-document-3>parser document</a> to null.</p>

    <p class=note>This is done so that if parser-inserted <code id=script-processing-model:the-script-element-27><a href=https://html.spec.whatwg.org/#the-script-element>script</a></code> elements fail to run
    when the parser tries to run them, e.g. because they are empty or specify an unsupported
    scripting language, another script can later mutate them and cause them to run again.</p>
  <li>
    <p>If <var>parser document</var> is non-null and <var>el</var> does not have an <code id=script-processing-model:attr-script-async-4><a href=https://html.spec.whatwg.org/#attr-script-async>async</a></code> attribute, then set <var>el</var>'s <a href=https://html.spec.whatwg.org/#script-force-async id=script-processing-model:script-force-async-2>force async</a> to true.</p>

    <p class=note>This is done so that if a parser-inserted <code id=script-processing-model:the-script-element-28><a href=https://html.spec.whatwg.org/#the-script-element>script</a></code> element fails to
    run when the parser tries to run it, but it is later executed after a script dynamically
    updates it, it will execute in an async fashion even if the <code id=script-processing-model:attr-script-async-5><a href=https://html.spec.whatwg.org/#attr-script-async>async</a></code> attribute isn't set.</p>
  <li><ins><p>Execute the [$Prepare the script URL and text$] algorithm on <var>el</var>. If that algorithm threw an error, then return.</p></ins></li>
  <li><p>Let <var>source text</var> be <var>el</var>'s <del><a id=script-processing-model:child-text-content href=https://dom.spec.whatwg.org/#concept-child-text-content data-x-internal=child-text-content>child text content</a>.</del> <ins>`[[ScriptText]]` internal slot value.</ins>
  <li>...
  </ol>
  <p>In all subsequent steps, replace checks for <code>src</code> attribute existence with checks for non-null `[[ScriptURL]]` internal slot value, and replace references of <code>src</code> content attribute value with `[[ScriptURL]]` internal slot value. For example:
  <ul>
  <li>If <del><var>el</var> does not have a <code>src</a></code> content attribute</del><ins><var>el</var>'s `[[ScriptURL]]` internal slot value is null</ins>, and the <a id="script-processing-model:should-element's-inline-behavior-be-blocked-by-content-security-policy" href=https://w3c.github.io/webappsec-csp/#should-block-inline data-x-internal="should-element's-inline-behavior-be-blocked-by-content-security-policy">Should element's inline
   behavior be blocked by Content Security Policy?</a> algorithm returns "<code>Blocked</code>" when given <var>el</var>, "<code>script</code>", and
   <var>source text</var>, then return.
   <li>If <var>el</var><ins>'s</ins> <del>has a <code>src</code> content attribute</del><ins>`[[ScriptURL]]` internal slot value is not null</ins>, then:
  <li><p>Let <var ignore="">src</var> be the value of <var>el</var>'s <del><code>src</a></code> attribute</del><ins>`[[ScriptURL]]` internal slot</ins>.
  </ul>

### Enforcement in element attributes ### {#enforcement-in-sinks}

This document modifies following IDL attributes of various DOM elements:

<pre class="idl exclude">
partial interface HTMLIFrameElement {
  [CEReactions] attribute HTMLString srcdoc;
};

partial interface HTMLEmbedElement {
  [CEReactions] attribute ScriptURLString src;
};

partial interface HTMLObjectElement {
  [CEReactions] attribute ScriptURLString data;
  [CEReactions] attribute ScriptURLString codeBase; // obsolete
};
</pre>

### Enforcement in timer functions ### {#enforcement-in-timer-functions}

This document modifies the {{WindowOrWorkerGlobalScope}} interface mixin:

<pre class="idl exclude">
typedef (ScriptString or Function) TrustedTimerHandler;

partial interface mixin WindowOrWorkerGlobalScope {
  long setTimeout(TrustedTimerHandler handler, optional long timeout = 0, any... arguments);
  long setInterval(TrustedTimerHandler handler, optional long timeout = 0, any... arguments);
};
</pre>

To the [[HTML5#timer-initialisation-steps|timer initialization steps algorithm]],
add this step between 7.1 and 7.2:

1.  If the first operation argument is not a {{Function}}, or if the first operation argument is a {{TrustedType}}, set the first operation argument to the result of executing
    the [$Get Trusted Type compliant string$] algorithm, with
    *   |global| set to the [=this=] value's [=relevant global object=].
    *   |input| set to the first method argument, and
    *   |expectedType| set to {{TrustedScript}}.
    *   |sink| set to `Window setInterval` if <var ignore>repeat</var> is true, `Window setTimeout` otherwise.
    *   |sinkGroup| set to `'script'`.

        Note: This matches the logic that the extended attribute would apply.

Note: This makes sure that a {{TrustedScript}} is passed to timer
functions in place of a string when Trusted Types are enforced, but
also unconditionally accepts any {{Function}} object.

### Enforcement in event handler content attributes ### {#enforcement-in-event-handler-content-attributes}

This document modifies the
[=attribute change steps=] for an [[HTML5#event-handler-content-attributes|event handler content attribute]].

At the beginning of step 5, insert the following steps:

1.  Let |value| be the result of executing the
    [$Get Trusted Type compliant string$] algorithm, with the following arguments:
    *   |value| as |input|,
    *   {{TrustedScript}} as |expectedType|,
    *   `'script'` as |sinkGroup|
    *   |sink| being the result of [=concatenating=] the list &laquo; <var ignore>element</var>'s [=Element/local name=], |localName| &raquo; with `"."` as a |separator|.

        Note: For example, `document.createElement('div').onclick = value` will result in |sink| being `'div.onclick'`.

    *   <var ignore>eventTarget</var>'s [=relevant global object=] as |global|,

1.  If the algorithm throws an error, abort these steps.

Note: This also applies to events in [[SVG2#EventAttributes]].

<div class="example" id="event-handlers-example">
  <pre highlight=js>
  // Content-Security-Policy: require-trusted-types-for 'script'

  const img = document.createElement('img');
  img.setAttribute('onerror', 'alert(1)'); // TypeError
  </pre>
</div>

### Validate the string in context ### {#html-validate-the-string-in-context}

This specification defines the <a>validate the string in context</a> algorithm in [[html#integration-with-idl]].

When <a>validate the string in context</a> is invoked, with |platformObject|, |value|, |stringContext|, and |identifier| run these steps:

 1. If |platformObject|'s [=relevant global object=] has a [=Window/trusted type policy factory=]:

    1. Set |sink| to the result of [=concatenating=] the list &laquo; |platformObject|'s <a spec=webidl>identifier</a>, |identifier| &raquo; with `" "` as |separator|.
        <div class="example" id="validate-string-example">
        For example, the following annotation and JavaScript code:
        <pre highlight=idl>
        typedef [StringContext=TrustedHTML] DOMString HTMLString;
        [ Exposed=Window, HTMLConstructor] interface HTMLIFrameElement : HTMLElement {
            attribute HTMLString srcdoc;
        };
        </pre>
        <pre highlight=js>
        document.createElement('iframe').srcdoc = foo;
        document.createElement('iframe').setAttribute('SRCdoc', foo);
        </pre>
        causes the |sink| value to be `"HTMLIFrameElement srcdoc"`.
        </div>
    1. Set |value| to the result of running the [$Get Trusted Type compliant string$] algorithm, passing the following arguments:
        * |value| as |input|,
        * |stringContext| as |expectedType|,
        * |sink| as |sink|,
        * `'script'` as |sinkGroup|,
        * |platformObject|'s [=relevant global object=] as |global|.

        Issue: Remove hardcoding 'script' when new sink groups are specified.

    1. If an exception was thrown, rethrow exception and abort further steps.
 1. Return |value|.

### Web Workers ###  {#html-workers}

This specification modifies the Worker constuctors and {{importScripts}} function to require {{ScriptURLString}}.

<pre class="idl exclude">
[Exposed=(Window,Worker)]
partial interface Worker : EventTarget {
    constructor(ScriptURLString scriptURL, optional WorkerOptions options = {});
};

[Exposed=(Window,Worker)]
partial interface SharedWorker : EventTarget {
  constructor(ScriptURLString scriptURL, optional (DOMString or WorkerOptions) options = {});
};

[Exposed=Worker]
partial interface WorkerGlobalScope : EventTarget {
  undefined importScripts(ScriptURLString... urls);
};
</pre>

## Integration with Service Workers ## {#sw-integration}

This document modifies the IDL for registering service workers, requiring {{ScriptURLString}}:

<pre class="idl exclude">
[SecureContext, Exposed=(Window,Worker)]
partial interface ServiceWorkerContainer : EventTarget {
   [NewObject] Promise&lt;ServiceWorkerRegistration> register(ScriptURLString scriptURL, optional RegistrationOptions options = {});
};
</pre>

## Integration with SVG ## {#integration-with-svg}

This document modifies the {{SVGAnimatedString}} interface to enforce Trusted Types:

<pre class="idl exclude">
[Exposed=Window]
partial interface mixin SVGAnimatedString {
           attribute (DOMString or TrustedScriptURL) baseVal;
};
</pre>

On setting {{SVGAnimatedString/baseVal}}, the following steps are run:

1. <ins>If the reflected <a spec="dom">attribute</a>'s element is a {{SVGScriptElement}}, set |value| to the result of executing [$Get Trusted Type compliant string$] algorithm, with the following arguments:</ins>

      * <ins>{{TrustedScriptURL}} as |expectedType|,</ins>
      * <ins>reflected attribute's {{Document}}'s [=relevant global object=] as |global|,</ins>
      * <ins>specified value as |input|,</ins>
      * <ins>`SVGScriptElement href` as |sink|,</ins>
      * <ins>'script' as |sinkGroup|.</ins>

    <ins>Otherwise, set |value| to the specified value.</ins>

1. If the reflected attribute is not present, the {{SVGAnimatedString}} object is defined to additionally reflect a second, deprecated attribute, and that deprecated attribute is present, then set that deprecated attribute to <del>the specified value</del> <ins>|value|</ins>. Otherwise, set the reflected attribute to <ins>|value|</ins> <del>the specified value</del>.

Note: SVG does not have a complete script processing model <a href="https://github.com/w3c/svgwg/issues/196">yet</a>. Trusted Types assumes that the attribute and text body modification protections behave similarly to ones for HTML scripts outlined in [[#enforcement-in-scripts]].

## Integration with DOM ## {#integration-with-dom}

This document modifies the {{Element}} interface, adding <a>attribute validation steps</a>:

<p><ins>This and <a lt="other applicable specifications">other specifications</a> may define
<dfn export id=concept-element-attributes-validation-ext>attribute validation steps</dfn> for
<a for=/>elements</a>. The algorithm is passed <var>element</var>, <var>localName</var>,
<var>value</var>, and <var ignore>namespace</var>.</ins>

This document changes the  <a spec="dom">handle attribute changes</a> algorithm, adding the following step at the beginning:
<ol>
 <li><ins><p>Run the <a>attribute validation steps</a> with <var>element</var>,
 <var>attribute</var>'s <a for=Attr>local name</a>, <var ignore>newValue</var> and
 <var>attribute</var>'s <a for=Attr>namespace</a>. If this throws an exception, then
 rethrow the exception and abort further steps.</ins>
</ol>

Additionally, this document changes the <a spec=dom>append</a> an attribute algorithm:

<p>To <dfn export id=concept-element-attributes-append lt="append an attribute">append</dfn> an
<a spec=dom>attribute</a> <var>attribute</var> to an <a for="/">element</a> <var>element</var>
<ins>with a <var>value</var></ins>, run these steps:

<ol>
 <li><p><a spec="dom">Handle attribute changes</a> for <var>attribute</var> with <var>element</var>, null, and
 <del><var>attribute</var>'s <a for=Attr>value</a></del><ins><var>value</var></ins>.

 <li><ins><p>Set <var>attribute</var>'s <a for=Attr>value</a> to <var>value</var>.</ins>

 <li><p><a for=list>Append</a> <var>attribute</var> to <var>element</var>'s
 <a for=Element>attribute list</a>.
 <li><p>Set <var>attribute</var>'s <a for=Attr>element</a> to <var>element</var>.
</ol>

Callers of this algorithm are changed accordingly.

Issue: Remove when <a href="https://github.com/whatwg/dom/pull/809">DOM #809</a> is merged.


## Integration with DOM Parsing ## {#integration-with-dom-parsing}

This document modifies the following interfaces defined by [[DOM-Parsing]]:

<pre class="idl exclude">
partial interface Element {
  [CEReactions, LegacyNullToEmptyString] attribute HTMLString outerHTML;
  [CEReactions] undefined insertAdjacentHTML(DOMString position, HTMLString text);
};

partial interface mixin InnerHTML { // specified in a draft version at https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin
  [CEReactions] attribute [LegacyNullToEmptyString] HTMLString innerHTML;
};

partial interface Range {
  [CEReactions, NewObject] DocumentFragment createContextualFragment(HTMLString fragment);
};

[Exposed=Window]
interface DOMParser {
  constructor();
  [NewObject] Document parseFromString(HTMLString str, SupportedType type);
};
</pre>

## Integration with execCommand ## {#integration-with-exec-command}

This document modifies the following interfaces defined by the unofficial <a href="https://w3c.github.io/editing/docs/execCommand/">execCommand</a> document:

<pre class="idl exclude">
partial interface Document {
    [CEReactions, RaisesException] boolean execCommand(DOMString commandId, optional boolean showUI = false, optional (DOMString or TrustedHTML) value = "");
};
</pre>

The implementation of the <a href="https://w3c.github.io/editing/docs/execCommand/#the-inserthtml-command">insertHTML</a> execCommand passes the unmodified value from its third argument
instance to the  {{Range/createContextualFragment()}} algorithm.

## Integration with Content Security Policy ## {#integration-with-content-security-policy}

### <dfn lt="require-trusted-types-for-directive">require-trusted-types-for</dfn> directive ### {#require-trusted-types-for-csp-directive}

This document defines *require-trusted-types-for* - a new [=directive|Content Security Policy directive=].

[=require-trusted-types-for-directive|require-trusted-types-for=] directive configures the Trusted
Types framework for all the [=injection sinks=] of certain groups in a current [=Realm|realm=].
Specifically, it defines what should be the behavior when a string value is passed to an [=injection sink=]
of a given group (i.e. should the type-based enforcement be enabled for such sinks).

Note: Currently, only the enforcement for [[#dom-xss-injection-sinks]] is specified.

The syntax for the directive's [=directive/name=] and [=directive/value=] is described by the following
ABNF:

<pre>
directive-name = "require-trusted-types-for"
directive-value = <a>trusted-types-sink-group</a> *( <a href="https://w3c.github.io/webappsec-csp/#grammardef-required-ascii-whitespace">required-ascii-whitespace</a> <a>trusted-types-sink-group</a>)
<dfn>trusted-types-sink-group</dfn> = "'script'"
</pre>

<div class="example" id="require-tt-for-script-header">
Enforce Trusted Types at the DOM XSS injection sinks.

<pre class="http">
Content-Security-Policy: require-trusted-types-for 'script'
</pre>
</div>

#### `require-trusted-types-for` Pre-Navigation check #### {#require-trusted-types-for-pre-navigation-check}

Given a [=request=] (|request|), a string <var ignore>navigation type</var> and a [=content security policy object|policy=] (|policy|), this algorithm returns `"Blocked"`
if a navigation violates the [=require-trusted-types-for-directive|require-trusted-types-for=] directive's constraints and `"Allowed"`
otherwise. This constitutes the [=require-trusted-types-for-directive|require-trusted-types-for=] directive's [=pre-navigation check=]:

Note: This algorithm assures that the code to be executed by a navigation to a `javascript:` URL will have to pass through a
<a>default policy</a>'s `createScript` function, in addition to all other restrictions imposed by other CSP directives.

1. If |request|'s [=request/url=]'s [=url/scheme=] is not `"javascript"`, return `"Allowed"` and abort further steps.
1. Let |urlString| be the result of running the [=URL serializer=] on |request|'s [=request/url=].
1. Let |encodedScriptSource| be the result of removing the leading `"javascript:"` from |urlString|.
1. Let |convertedScriptSource| be the result of executing [$Process value with a default policy$] algorithm, with the following arguments:

    * {{TrustedScript}} as |expectedType|
    * |request|'s [=request/clients=]'s [=environment settings object/global object=] as |global|
    * |encodedScriptSource| as |input|
    * `"Location href"` as |sink|

    If that algorithm threw an error or |convertedScriptSource| is not a {{TrustedScript}} object, return "Blocked" and abort further steps.
1. Set |urlString| to be the result of prepending `"javascript:"` to stringified |convertedScriptSource|.
1. Let |newURL| be the result of running the [=URL parser=] on |urlString|. If the parser returns a failure, return `"Blocked"` and abort further steps.
1. Set |request|'s [=request/url=] to |newURL|.

     Note: No other CSP directives operate on `javascript:` URLs in a pre-navigation check. Other directives that check javascript: URLs
           will operate on the modified URL later, in the [=inline check=].
1. Return `"Allowed"`.


### <dfn lt="trusted-types-directive">trusted-types</dfn> directive ### {#trusted-types-csp-directive}

This document defines *trusted-types* - a new [=directive|Content Security Policy directive=]. The [=trusted-types-directive|trusted-types=] directive controls the creation of Trusted Type [=policies=].

The syntax for the directive's [=directive/name=] and [=directive/value=] is described by the following
ABNF:

<pre>
directive-name = "trusted-types"
directive-value = <a>serialized-tt-configuration</a>
<dfn>serialized-tt-configuration</dfn> = ( <a>tt-expression</a> *( <a href="https://w3c.github.io/webappsec-csp/#grammardef-required-ascii-whitespace">required-ascii-whitespace</a> <a>tt-expression</a> ) )
<dfn>tt-expression</dfn> = <a>tt-policy-name</a>  / <a>tt-keyword</a> / <a>tt-wildcard</a>
<dfn>tt-wildcard</dfn> = "*"
<dfn>tt-policy-name</dfn> = 1*( <a href="https://tools.ietf.org/html/rfc5234#appendix-B.1">ALPHA</a> / <a href="https://tools.ietf.org/html/rfc5234#appendix-B.1">DIGIT</a> / "-" / "#" / "=" / "_" / "/" / "@" / "." / "%")
<dfn>tt-keyword</dfn> = "'allow-duplicates'" / "'none'"
</pre>

<div class="example" id="allowlist-of-policy-names-in-header">
Types are enforced at sinks, and only two policies may be created: “one” and “two”.

<pre class="http">
Content-Security-Policy: require-trusted-types-for 'script'; trusted-types one two
</pre>
</div>

<div class="example" id="header-that-allows-no-policy-names">
An empty [=directive=] [=directive/value=] indicates policies may not be created,
and sinks expect Trusted Type values, i.e. no DOM XSS [=injection sinks=] can be used
at all.

<pre class="http">
Content-Security-Policy: trusted-types; require-trusted-types-for 'script'
</pre>
</div>

Keyword `'allow-duplicates'` allows for creating policies with a name that was already used.

<div class="example" id="allow-duplicates-in-header">
<pre class="http">
Content-Security-Policy: trusted-types foo bar 'allow-duplicates'
</pre>
</div>

If the policy named `default` is present in the list, it refers to the
[=default policy=]. All strings passed to [=injection sinks=] will be passed through it instead
of being rejected outright.

<div class="example" id="default-in-header">
<pre class="http">
Content-Security-Policy: trusted-types one two default
</pre>
</div>


### <dfn abstract-op>Should sink type mismatch violation be blocked by Content Security Policy?</dfn> ### {#should-block-sink-type-mismatch}

Given a [=Realm/global object=] (|global|), a string (|sink|), a string (|sinkGroup|) and a string (|source|) this algorithm
returns `"Blocked"` if the [=injection sink=] requires a [=Trusted Type=], and
`"Allowed"` otherwise.

1.  Let |result| be `"Allowed"`.
1.  For each |policy| in |global|'s <a>CSP list</a>:
    1.  If |policy|'s <a>directive set</a> does not contain a <a>directive</a>
        which [=directive/name=] is `"require-trusted-types-for"`, skip to the next |policy|.
    1.  Let |directive| be the |policy|'s |directive set|'s [=directive=] which name
        is `"require-trusted-types-for"`
    1.  If |directive|'s [=directive/value=] does not contain a <a>trusted-types-sink-group</a> which is a match
        for a value |sinkGroup|, skip to the next |policy|.
    1.  Let |violation| be the result of executing
        [[CSP#create-violation-for-global|Create a violation object for global, policy, and directive]]
        on |global|, |policy| and `"require-trusted-types-for"`
    1. Set |violation|'s [=violation/resource=] to `"trusted-types-sink"`.
    1. Let |trimmedSource| be the substring of |source|, containing its first 40 characters.
    1. Set |violation|'s [=violation/sample=] to be the result of [=concatenating=] the list &laquo; |sink|, |trimmedSource| &laquo; using `"|"` as a |separator|.
    1.  Execute [[CSP#report-violation|Report a violation]] on |violation|.
    1.  If |policy|'s [=policy/disposition=] is `"enforce"`, then set |result| to
        `"Blocked"`.
1. Return |result|.

### <dfn abstract-op>Should Trusted Type policy creation be blocked by Content Security Policy?</dfn> ### {#should-block-create-policy}

Given a [=Realm/global object=] (|global|), a string (|policyName|) and a list of
strings (|createdPolicyNames|), this algorithm returns `"Blocked"` if the
{{TrustedTypePolicy}} should not be created, and `"Allowed"` otherwise.

1.  Let |result| be `"Allowed"`.
1.  For each |policy| in |global|'s <a>CSP list</a>:
    1.  Let |createViolation| be false.
    1.  If |policy|'s <a>directive set</a> does not contain a <a>directive</a>
        which name is `"trusted-types"`, skip to the next |policy|.
    1.  Let |directive| be the |policy|'s |directive set|'s [=directive=] which name
        is `"trusted-types"`
    1.  If |directive|'s [=directive/value=] only contains a <a>tt-keyword</a> which
        is a match for a value `'none'`, set |createViolation| to true.

        Note: Like in other CSP directives, 'none' keyword will be ignored if other keywords or policy names are present.

    1.  If |createdPolicyNames| contains |policyName| and |directive|'s [=directive/value=] does not contain a <a>tt-keyword</a> which is a match
        for a value `'allow-duplicates'`, set |createViolation| to true.

        Note: `trusted-types policyA policyB 'allow-duplicates'` allows authors to create policies with
        duplicated names.
    1.  If |directive|'s [=directive/value=] does not contain a <a>tt-policy-name</a>,
        which value is |policyName|, and |directive|'s [=directive/value=] does not contain a <a>tt-wildcard</a>, set |createViolation| to true.

        Note: `trusted-types *` allows authors to create policies with any unique names. To allow for multiple policies with the same name, use
        `trusted-types * 'allow-duplicates'` or don't set the `trusted-types` directive at all.
    1.  If |createViolation| is false, skip to the next |policy|.
    1.  Let |violation| be the result of executing
        [[CSP#create-violation-for-global|Create a violation object for global, policy, and directive]] on |global|, |policy| and
        `"trusted-types"`
    1. Set |violation|'s [=violation/resource=] to `"trusted-types-policy"`.
    1. Set |violation|'s [=violation/sample=] to the substring of |policyName|, containing its first 40 characters.
    1.  Execute [[CSP#report-violation|Report a violation]] on |violation|.
    1.  If |policy|'s [=policy/disposition=] is `"enforce"`, then set |result| to
        `"Blocked"`.
1. Return |result|.

### Violation object changes ### {#csp-violation-object-hdr}

[=violation|Violation=] object [=violation/resource=] also allows `"trusted-types-policy"`
and `"trusted-types-sink"` as values.

### Support for dynamic code compilation ### {#csp-eval}

This document modifies the [[CSP3#can-compile-strings|EnsureCSPDoesNotBlockStringCompilation]]
which is reproduced in its entirety below with additions and deletions.

Note: This is based on [dynamic-code-brand-checks](https://tc39.es/proposal-dynamic-code-brand-checks/) and
assumes additional arguments are passed to this algorithm from ECMAScript.
See also <a href="https://github.com/tc39/ecma262/issues/938">TC39/ecma262 issue #938</a>.

<div class="note">Note: EcmaScript code may call `Function()` and `eval` cross realm.
<pre highlight="js">
  let f = new self.top.Function(source);
</pre>
In this case, the |callerRealm|'s Window is `self` and the |calleeRealm|'s Window is `self.top`.
The Trusted Types portion of this algorithm uses |calleeRealm| and its CSP setting for consistency with other sinks.
<pre highlight="js">
  // Assigning a string to another Realm's DOM sink uses that Realm's default policy.
  self.top.body.innerHTML = 'Hello, World!';
  // Using another Realm's builtin Function constructor should analogously use that
  // Realm's default policy.
  new self.top.Function('alert(1)')()
</pre>
</div>

Given a [[ECMASCRIPT#realm|realm]] (|calleeRealm|), a string
(|source|) <ins>, a boolean |wasCodeLike| and a string |compilationSink|</ins>, this algorithm returns <del>normally</del><ins>the
source string to compile</ins> if compilation is allowed, and
throws an "`EvalError`" if not:

1.  <ins>If |wasCodeLike| is true, let |sourceToValidate| be a new instance of
    the {{TrustedScript}} interface, with its `[[Data]]` internal slot value
    set to |source|. Otherwise, let |sourceToValidate| be |source|.</ins>

1. <ins>Let |sourceString| be the result of executing the
    [$Get Trusted Type compliant string$] algorithm, with:
    *   |calleeRealm| as |global|,
    *   |sourceToValidate| as |input|,
    *   |compilationSink| as |sink|,
    *   `'script'` as |sinkGroup|,
    *   {{TrustedScript}} as |expectedType|.</ins>

2.  <ins>If the algorithm throws an error, throw an {{EvalError}}.</ins>

3.  Let |global| be a |calleeRealm|'s [=Realm/global object=].

4.  Let |result| be "`Allowed`".

5.  For each |policy| in |global|'s <a for="global object" spec="CSP3">CSP list</a>:

    1.  Let |source-list| be `null`.

    2.  If |policy| contains a [=directive=] whose [=directive/name=] is "`script-src`", then
        set |source-list| to that [=directive=]'s [=directive/value=].

        Otherwise if |policy| contains a [=directive=] whose [=directive/name=] is
        "`default-src`", then set |source-list| to that directive's [=directive/value=].

    3.  If |source-list| is not `null`, and does not contain a [=source expression=] which is
        an [=ASCII case-insensitive=] match for the string "<a grammar>`'unsafe-eval'`</a>" then:

        1.  Let |violation| be the result of executing [[CSP3#create-violation-for-global]] on
            |global|, |policy|, and "`script-src`".

        2.  Set |violation|'s [=violation/resource=] to "`inline`".

        3.  If |source-list| [=list/contains=] the expression
            "<a grammar>`'report-sample'`</a>", then set |violation|'s [=violation/sample=] to
            the substring of <del>|source|</del> <ins>|sourceString|</ins> containing its first
            40 characters.

        4.  Execute [[CSP3#report-violation]] on |violation|.

        5.  If |policy|'s [=policy/disposition=] is "`enforce`", then set |result| to
            "`Blocked`".

6.  If |result| is "`Blocked`", throw an `EvalError` exception.

7. <ins>Return |sourceString|.</ins>

Note: returning |sourceString| means that the string that gets
compiled is that returned by any [=default policy=] in the course of
executing [$Get Trusted Type compliant string$].

# Security Considerations # {#security-considerations}

Trusted Types are not intended to protect access to [=injection sinks=] in an
actively malicious execution environment. It's assumed that the application is
written by non-malicious authors; the intent is to prevent developer mistakes
that could result in security bugs, and not to defend against first-party
malicious code actively trying to bypass policy restrictions. Below we enumerate
already identified vectors that remain risky even in environments with enforced
Trusted Types.

## Cross-document vectors ## {#cross-document-vectors}

While the code running in a window in which Trusted Types are enforced cannot
dynamically create nodes that would bypass the policy restrictions, it is
possible that such nodes can be imported or adopted from documents in other
windows, that don't have the same set of restrictions. In essence - it is
possible to bypass Trusted Types if a malicious author creates a setup in which
a restricted document colludes with an unrestricted one. In an extreme case, the
restricted document might create a {{Blob}} from strings and navigate to it.

CSP propagation rules (see [[CSP3#security-inherit-csp]] partially address this
issue, as new [=local scheme=] documents will inherit the same set of restrictions,
so - for example -  `script-src` restrictions could be used to make sure injections
into {{Blob}} contents would not execute scripts. To address this issue
comprehensively, other mechanisms like <a href="https://wicg.github.io/origin-policy/">Origin Policy</a>
should be used to ensure that baseline security rules are applied for the whole
origin.

## Deprecated features ## {#deprecated-features}

Some long-deprecated and rarely used platform features are not subject to Trusted
Types, and could potentially be used by malicious authors to overcome the
restrictions:

* <a href="https://w3c.github.io/webcomponents/spec/imports/">HTML imports</a>

## Plugin navigation ## {#plugins}

Plugin content may have access to the document that embeds it (or; more broadly,
to the origin it was served from), often giving it the same capabilities
as DOM XSS. That's why Trusted Types limit {{HTMLEmbedElement}}'s <{embed/src}> to
{{TrustedScriptURL}}.

However, it is also possible to navigate an existing object / embed to an
arbitrary location, bypassing the {{TrustedScriptURL}} restriction.

Since plugin content in the web in general is being phased out for other
security reasons, and their navigation model is in flux, we recommend authors
to prevent that bypass vector by limiting the plugins altogether with
[=object-src=]. For example: `Content-Security-Policy: object-src: none`.

## Script gadgets ## {#script-gadgets}

While Trusted Types logic is called on many operations that results in creating
DOM trees from string, it should not be treated as a mechanism for guarding all
DOM tree creation in a document. This is important especially in the presence of
[script gadgets](https://github.com/google/security-research-pocs/tree/master/script-gadgets),
where an application reacts to contents of usually benign DOM elements or attributes.
Developers using DOM API directly can trigger such gadgets without using
Trusted Types. However, in order for the gadget to trigger DOM XSS, it needs to
obtain a Trusted Type value via a policy. Authors need to ascertain that the data
passed to Trusted Type policies is indeed trustworthy, if the policy rules don't
enforce constraints or validate the data themselves.

## Best practices for policy design ## {#best-practices-for-policy-design}

Trusted Types limit the scope of the code that can introduce
vulnerabilities via [=injection sinks=] to the implementation of [=policies=].
In this design, insecure policies can still expose [=injection sinks=] to untrusted data.
Special emphasis needs to be taken by use policies that are either secure for all
possible inputs, or limit the access to insecure policies, such that they are only
called with non-attacker controlled inputs.

As policies are custom JavaScript code, they may be written in a way that heavily
depends on a global state. We advise against this. The policies should
be self-contained as much as possible. All objects that may alter security decisions
a policy makes effectively *become* the policy, and should be guarded & reviewed
together.

Issue: Refer to the external document on secure policy design.

# Privacy Considerations # {#privacy-considerations}

The specification may partially observe and alter the behavior of scripts running
within the application, e.g. causing certain operations on [=injection sinks=]
to fail, or monitoring and changing their effect with a [=default policy=].
However, early-running scripts already have this capability by overriding
appropriate property descriptors.

It is possible for the application to report violations of Trusted Types
restrictions. Violation reports would include the trimmed-down payload passed to
the injection sink (40 characters, including the sink name). These feature is
reusing the Content Security Policy reporting mechanisms.

# Implementation Considerations # {#implementation-considerations}

## Vendor-specific Extensions and Addons ## {#vendor-specific-extensions-and-addons}

Restriction imposed by Trusted Types SHOULD
NOT interfere with the operation of user-agent features like addons,
extensions, or bookmarklets. These kinds of features generally advance
the user’s priority over page authors, as espoused in
[[html-design-principles]]. Specifically, extensions SHOULD be able to pass strings
to the [=injection sinks=] without triggering [=default policy=]
execution, violation generation, or the rejection of the value.
