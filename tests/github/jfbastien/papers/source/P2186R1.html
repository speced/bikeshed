<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>P2186R1: Removing Garbage Collection Support</title>
<style data-fill-with="stylesheet">
  </style>
<style>
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      vertical-align: top;
    }
    th, td {
      border-left: none;
      border-right: none;
      padding: 0px 10px;
    }
    th {
      text-align: center;
    }

    del { background: #fcc; color: #000; text-decoration: line-through; }
    ins { background: #cfc; color: #000; }
    blockquote .highlight:not(.idl) { background: initial; margin: initial; padding: 0.5em }
    blockquote ul { background: inherit; }
    blockquote code.highlight:not(.idl) { padding: initial; }
    blockquote c-[a] { color: inherit; } /* Keyword.Declaration */
    blockquote c-[b] { color: inherit; } /* Keyword.Type */
    blockquote c-[c] { color: inherit; } /* Comment */
    blockquote c-[d] { color: inherit; } /* Comment.Multiline */
    blockquote c-[e] { color: inherit; } /* Name.Attribute */
    blockquote c-[f] { color: inherit; } /* Name.Tag */
    blockquote c-[g] { color: inherit; } /* Name.Variable */
    blockquote c-[k] { color: inherit; } /* Keyword */
    blockquote c-[l] { color: inherit; } /* Literal */
    blockquote c-[m] { color: inherit; } /* Literal.Number */
    blockquote c-[n] { color: inherit; } /* Name */
    blockquote c-[o] { color: inherit; } /* Operator */
    blockquote c-[p] { color: inherit; } /* Punctuation */
    blockquote c-[s] { color: inherit; } /* Literal.String */
    blockquote c-[t] { color: inherit; } /* Literal.String.Single */
    blockquote c-[u] { color: inherit; } /* Literal.String.Double */
    blockquote c-[cp] { color: inherit; } /* Comment.Preproc */
    blockquote c-[c1] { color: inherit; } /* Comment.Single */
    blockquote c-[cs] { color: inherit; } /* Comment.Special */
    blockquote c-[kc] { color: inherit; } /* Keyword.Constant */
    blockquote c-[kn] { color: inherit; } /* Keyword.Namespace */
    blockquote c-[kp] { color: inherit; } /* Keyword.Pseudo */
    blockquote c-[kr] { color: inherit; } /* Keyword.Reserved */
    blockquote c-[ld] { color: inherit; } /* Literal.Date */
    blockquote c-[nc] { color: inherit; } /* Name.Class */
    blockquote c-[no] { color: inherit; } /* Name.Constant */
    blockquote c-[nd] { color: inherit; } /* Name.Decorator */
    blockquote c-[ni] { color: inherit; } /* Name.Entity */
    blockquote c-[ne] { color: inherit; } /* Name.Exception */
    blockquote c-[nf] { color: inherit; } /* Name.Function */
    blockquote c-[nl] { color: inherit; } /* Name.Label */
    blockquote c-[nn] { color: inherit; } /* Name.Namespace */
    blockquote c-[py] { color: inherit; } /* Name.Property */
    blockquote c-[ow] { color: inherit; } /* Operator.Word */
    blockquote c-[mb] { color: inherit; } /* Literal.Number.Bin */
    blockquote c-[mf] { color: inherit; } /* Literal.Number.Float */
    blockquote c-[mh] { color: inherit; } /* Literal.Number.Hex */
    blockquote c-[mi] { color: inherit; } /* Literal.Number.Integer */
    blockquote c-[mo] { color: inherit; } /* Literal.Number.Oct */
    blockquote c-[sb] { color: inherit; } /* Literal.String.Backtick */
    blockquote c-[sc] { color: inherit; } /* Literal.String.Char */
    blockquote c-[sd] { color: inherit; } /* Literal.String.Doc */
    blockquote c-[se] { color: inherit; } /* Literal.String.Escape */
    blockquote c-[sh] { color: inherit; } /* Literal.String.Heredoc */
    blockquote c-[si] { color: inherit; } /* Literal.String.Interpol */
    blockquote c-[sx] { color: inherit; } /* Literal.String.Other */
    blockquote c-[sr] { color: inherit; } /* Literal.String.Regex */
    blockquote c-[ss] { color: inherit; } /* Literal.String.Symbol */
    blockquote c-[vc] { color: inherit; } /* Name.Variable.Class */
    blockquote c-[vg] { color: inherit; } /* Name.Variable.Global */
    blockquote c-[vi] { color: inherit; } /* Name.Variable.Instance */
    blockquote c-[il] { color: inherit; } /* Literal.Number.Integer.Long */
  </style>
  <link href="http://wg21.link/P2186R1" rel="canonical">
  <link href="https://isocpp.org/favicon.ico" rel="icon">
  <meta content="dark light" name="color-scheme">
<style>/* Boilerplate: style-autolinks */
.css.css, .property.property, .descriptor.descriptor {
    color: var(--a-normal-text);
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}

@media (prefers-color-scheme: dark) {
    :root {
        --selflink-text: black;
        --selflink-bg: silver;
        --selflink-hover-text: white;
    }
}
</style>
<style>/* Boilerplate: style-colors */
/* Any --*-text not paired with a --*-bg is assumed to have a transparent bg */
:root {
    color-scheme: light dark;

    --text: black;
    --bg: white;

    --unofficial-watermark: url(https://www.w3.org/StyleSheets/TR/2016/logos/UD-watermark);

    --logo-bg: #1a5e9a;
    --logo-active-bg: #c00;
    --logo-text: white;

    --tocnav-normal-text: #707070;
    --tocnav-normal-bg: var(--bg);
    --tocnav-hover-text: var(--tocnav-normal-text);
    --tocnav-hover-bg: #f8f8f8;
    --tocnav-active-text: #c00;
    --tocnav-active-bg: var(--tocnav-normal-bg);

    --tocsidebar-text: var(--text);
    --tocsidebar-bg: #f7f8f9;
    --tocsidebar-shadow: rgba(0,0,0,.1);
    --tocsidebar-heading-text: hsla(203,20%,40%,.7);

    --toclink-text: var(--text);
    --toclink-underline: #3980b5;
    --toclink-visited-text: var(--toclink-text);
    --toclink-visited-underline: #054572;

    --heading-text: #005a9c;

    --hr-text: var(--text);

    --algo-border: #def;

    --del-text: red;
    --del-bg: transparent;
    --ins-text: #080;
    --ins-bg: transparent;

    --a-normal-text: #034575;
    --a-normal-underline: #bbb;
    --a-visited-text: var(--a-normal-text);
    --a-visited-underline: #707070;
    --a-hover-bg: rgba(75%, 75%, 75%, .25);
    --a-active-text: #c00;
    --a-active-underline: #c00;

    --blockquote-border: silver;
    --blockquote-bg: transparent;
    --blockquote-text: currentcolor;

    --issue-border: #e05252;
    --issue-bg: #fbe9e9;
    --issue-text: var(--text);
    --issueheading-text: #831616;

    --example-border: #e0cb52;
    --example-bg: #fcfaee;
    --example-text: var(--text);
    --exampleheading-text: #574b0f;

    --note-border: #52e052;
    --note-bg: #e9fbe9;
    --note-text: var(--text);
    --noteheading-text: hsl(120, 70%, 30%);
    --notesummary-underline: silver;

    --assertion-border: #aaa;
    --assertion-bg: #eee;
    --assertion-text: black;

    --advisement-border: orange;
    --advisement-bg: #fec;
    --advisement-text: var(--text);
    --advisementheading-text: #b35f00;

    --warning-border: red;
    --warning-bg: hsla(40,100%,50%,0.95);
    --warning-text: var(--text);

    --amendment-border: #330099;
    --amendment-bg: #F5F0FF;
    --amendment-text: var(--text);
    --amendmentheading-text: #220066;

    --def-border: #8ccbf2;
    --def-bg: #def;
    --def-text: var(--text);
    --defrow-border: #bbd7e9;

    --datacell-border: silver;

    --indexinfo-text: #707070;

    --indextable-hover-text: black;
    --indextable-hover-bg: #f7f8f9;

    --outdatedspec-bg: rgba(0, 0, 0, .5);
    --outdatedspec-text: black;
    --outdated-bg: maroon;
    --outdated-text: white;
    --outdated-shadow: red;

    --editedrec-bg: darkorange;
}

@media (prefers-color-scheme: dark) {
    :root {
        --text: #ddd;
        --bg: black;

        --unofficial-watermark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Cg fill='%23100808' transform='translate(200 200) rotate(-45) translate(-200 -200)' stroke='%23100808' stroke-width='3'%3E%3Ctext x='50%25' y='220' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EUNOFFICIAL%3C/text%3E%3Ctext x='50%25' y='305' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EDRAFT%3C/text%3E%3C/g%3E%3C/svg%3E");

        --logo-bg: #1a5e9a;
        --logo-active-bg: #c00;
        --logo-text: white;

        --tocnav-normal-text: #999;
        --tocnav-normal-bg: var(--bg);
        --tocnav-hover-text: var(--tocnav-normal-text);
        --tocnav-hover-bg: #080808;
        --tocnav-active-text: #f44;
        --tocnav-active-bg: var(--tocnav-normal-bg);

        --tocsidebar-text: var(--text);
        --tocsidebar-bg: #080808;
        --tocsidebar-shadow: rgba(255,255,255,.1);
        --tocsidebar-heading-text: hsla(203,20%,40%,.7);

        --toclink-text: var(--text);
        --toclink-underline: #6af;
        --toclink-visited-text: var(--toclink-text);
        --toclink-visited-underline: #054572;

        --heading-text: #8af;

        --hr-text: var(--text);

        --algo-border: #456;

        --del-text: #f44;
        --del-bg: transparent;
        --ins-text: #4a4;
        --ins-bg: transparent;

        --a-normal-text: #6af;
        --a-normal-underline: #555;
        --a-visited-text: var(--a-normal-text);
        --a-visited-underline: var(--a-normal-underline);
        --a-hover-bg: rgba(25%, 25%, 25%, .2);
        --a-active-text: #f44;
        --a-active-underline: var(--a-active-text);

        --borderedblock-bg: rgba(255, 255, 255, .05);

        --blockquote-border: silver;
        --blockquote-bg: var(--borderedblock-bg);
        --blockquote-text: currentcolor;

        --issue-border: #e05252;
        --issue-bg: var(--borderedblock-bg);
        --issue-text: var(--text);
        --issueheading-text: hsl(0deg, 70%, 70%);

        --example-border: hsl(50deg, 90%, 60%);
        --example-bg: var(--borderedblock-bg);
        --example-text: var(--text);
        --exampleheading-text: hsl(50deg, 70%, 70%);

        --note-border: hsl(120deg, 100%, 35%);
        --note-bg: var(--borderedblock-bg);
        --note-text: var(--text);
        --noteheading-text: hsl(120, 70%, 70%);
        --notesummary-underline: silver;

        --assertion-border: #444;
        --assertion-bg: var(--borderedblock-bg);
        --assertion-text: var(--text);

        --advisement-border: orange;
        --advisement-bg: #222218;
        --advisement-text: var(--text);
        --advisementheading-text: #f84;

        --warning-border: red;
        --warning-bg: hsla(40,100%,20%,0.95);
        --warning-text: var(--text);

        --amendment-border: #330099;
        --amendment-bg: #080010;
        --amendment-text: var(--text);
        --amendmentheading-text: #cc00ff;

        --def-border: #8ccbf2;
        --def-bg: #080818;
        --def-text: var(--text);
        --defrow-border: #136;

        --datacell-border: silver;

        --indexinfo-text: #aaa;

        --indextable-hover-text: var(--text);
        --indextable-hover-bg: #181818;

        --outdatedspec-bg: rgba(255, 255, 255, .5);
        --outdatedspec-text: black;
        --outdated-bg: maroon;
        --outdated-text: white;
        --outdated-shadow: red;

        --editedrec-bg: darkorange;
    }
    /* In case a transparent-bg image doesn't expect to be on a dark bg,
       which is quite common in practice... */
    img { background: white; }
}
</style>
<style>/* Boilerplate: style-counters */
body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}
</style>
<style>/* Boilerplate: style-issues */
a[href].issue-return {
    float: right;
    float: inline-end;
    color: var(--issueheading-text);
    font-weight: bold;
    text-decoration: none;
}
</style>
<style>/* Boilerplate: style-md-lists */
/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}
</style>
<style>/* Boilerplate: style-selflinks */
:root {
    --selflink-text: white;
    --selflink-bg: gray;
    --selflink-hover-text: black;
}
.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
.example > a.self-link,
.note > a.self-link,
.issue > a.self-link {
    /* These blocks are overflow:auto, so positioning outside
       doesn't work. */
    left: auto;
    right: 0;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: var(--selflink-bg);
    color: var(--selflink-text);
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: var(--selflink-hover-text);
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }
</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"></p>
   <h1 class="p-name no-ref" id="title">P2186R1<br>Removing Garbage Collection Support</h1>
   <h2 class="no-num no-toc no-ref heading settled" id="profile-and-date"><span class="content">Published Proposal, <time class="dt-updated" datetime="1970-01-01">1970-01-01</time></span></h2>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt>This version:
     <dd><a class="u-url" href="http://wg21.link/P2186R1">http://wg21.link/P2186R1</a>
     <dt class="editor">Authors:
     <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:cxx@jfbastien.com">JF Bastien</a> (<span class="p-org org">Toyota Research Institute—Advanced Development (Woven Planet)</span>)
     <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:ameredith1@bloomberg.net">Alisdair Meredith</a> (<span class="p-org org">Bloomberg</span>)
     <dt>Audience:
     <dd>CWG, LWG
     <dt>Project:
     <dd>ISO/IEC 14882 Programming Languages — C++, ISO/IEC JTC1/SC22/WG21
     <dt>Source:
     <dd><a href="https://github.com/jfbastien/papers/blob/master/source/P2186R1.bs">github.com/jfbastien/papers/blob/master/source/P2186R1.bs</a>
    </dl>
   </div>
   <div data-fill-with="warning"></div>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract"></div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref heading settled" id="contents"><span class="content">Table of Contents</span></h2>
   <ol class="toc" role="directory">
    <li><a href="#abstract"><span class="secno">1</span> <span class="content">Abstract</span></a>
    <li>
     <a href="#rev"><span class="secno">2</span> <span class="content">Revision History</span></a>
     <ol class="toc">
      <li><a href="#r0r1"><span class="secno">2.1</span> <span class="content">r0 ➡ r1</span></a>
     </ol>
    <li><a href="#history"><span class="secno">3</span> <span class="content">History</span></a>
    <li>
     <a href="#oops"><span class="secno">4</span> <span class="content">Issues with the Current Specification</span></a>
     <ol class="toc">
      <li><a href="#safe"><span class="secno">4.1</span> <span class="content">Safely Derived Pointers</span></a>
      <li><a href="#alloc"><span class="secno">4.2</span> <span class="content">Allocators</span></a>
      <li><a href="#new"><span class="secno">4.3</span> <span class="content">Replacement <code class="highlight"><c- k>operator</c-> <c- k>new</c-></code></span></a>
      <li><a href="#constexpr"><span class="secno">4.4</span> <span class="content"><code class="highlight"><c- k>constexpr</c-></code> Allocation</span></a>
      <li><a href="#corelib"><span class="secno">4.5</span> <span class="content">Core versus Library Wording</span></a>
      <li><a href="#CHAR_BIT"><span class="secno">4.6</span> <span class="content"><code class="highlight"><c- b>signed</c-> <c- b>char</c-></code> and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>byte</c-></code></span></a>
      <li><a href="#prefer"><span class="secno">4.7</span> <span class="content">Preferred Pointer Safety</span></a>
      <li><a href="#c"><span class="secno">4.8</span> <span class="content">C Compatibility</span></a>
      <li><a href="#malloc"><span class="secno">4.9</span> <span class="content"><code class="highlight"><c- n>malloc</c-></code> and Related Functions</span></a>
     </ol>
    <li><a href="#rationale"><span class="secno">5</span> <span class="content">Rationale</span></a>
    <li><a href="#other"><span class="secno">6</span> <span class="content">Other Concerns</span></a>
    <li><a href="#proposal"><span class="secno">7</span> <span class="content">Proposal</span></a>
    <li>
     <a href="#references"><span class="secno"></span> <span class="content">References</span></a>
     <ol class="toc">
      <li><a href="#informative"><span class="secno"></span> <span class="content">Informative References</span></a>
     </ol>
   </ol>
  </nav>
  <main>
   <h2 class="heading settled" data-level="1" id="abstract"><span class="secno">1. </span><span class="content">Abstract</span><a class="self-link" href="#abstract"></a></h2>
   <p>We propose removing (<em>not</em> deprecating) C++'s Garbage Collection support. Specifically, these five library functions:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>declare_reachable</c-></code></p>
    <li data-md>
     <p><code class="highlight"><c- n>undeclare_reachable</c-></code></p>
    <li data-md>
     <p><code class="highlight"><c- n>declare_no_pointers</c-></code></p>
    <li data-md>
     <p><code class="highlight"><c- n>undeclare_no_pointers</c-></code></p>
    <li data-md>
     <p><code class="highlight"><c- n>get_pointer_safety</c-></code></p>
   </ul>
   <p>As well as the <code class="highlight"><c- n>pointer_safety</c-></code> enum, the <code class="highlight"><c- n>__STDCPP_STRICT_POINTER_SAFETY__</c-></code> macro, and the Core Language wording.</p>
   <h2 class="heading settled" data-level="2" id="rev"><span class="secno">2. </span><span class="content">Revision History</span><a class="self-link" href="#rev"></a></h2>
   <h3 class="heading settled" data-level="2.1" id="r0r1"><span class="secno">2.1. </span><span class="content">r0 ➡ r1</span><a class="self-link" href="#r0r1"></a></h3>
   <p>EWG discussed this paper in a telecon on July 30th 2020, and LEWG discussed this
paper in a telecon on December 14th 2020. The following polls were taken:</p>
   <table class="def">
    <tbody>
     <tr>
      <th style="width: 70%;">
      <th><strong>SF</strong>
      <th><strong>F</strong>
      <th><strong>N</strong>
      <th><strong>A</strong>
      <th><strong>SA</strong>
     <tr>
      <th><small>EWG: Remove (not deprecate) garbage collection support in C++23.</small>
      <th>3
      <th>9
      <th>4
      <th>0
      <th>1
     <tr>
      <th><small>LEWG: Remove (not deprecate) pointer safety in C++23, after moving names to zombie names.</small>
      <th>10
      <th>4
      <th>3
      <th>0
      <th>0
   </table>
   <p>The library names were added to the zombie names section.</p>
   <h2 class="heading settled" data-level="3" id="history"><span class="secno">3. </span><span class="content">History</span><a class="self-link" href="#history"></a></h2>
   <p>Minimal support for Garbage Collection was added to C++0x in 2008 by <a data-link-type="biblio" href="#biblio-n2670" title="Minimal Support for Garbage Collection and Reachability-Based Leak Detection (revised)">[N2670]</a>. The main addition was the concept of "strict pointer safety", as well as library support for this pointer safety. Most of the rationale leading to the wording in this paper is captured in the two preceding proposals that merged to form this minimal paper, <a data-link-type="biblio" href="#biblio-n2310" title="Transparent Programmer-Directed Garbage Collection for C++">[N2310]</a> and <a data-link-type="biblio" href="#biblio-n2585" title="Minimal Support for Garbage Collection and Reachability-Based Leak Detection">[N2585]</a>.</p>
   <p>There have been successful garbage collectors for C++, for example the <a href="https://www.hboehm.info/gc/">Boehm GC</a> as well as Garbage Collectors in language virtual machines where the VM is implemented in C++, to support a garbage-collected language. This allows the implementation language to reference objects in the garbage collected language, and lets them interface very closely. You’re likely reading this paper in such a virtual machine, implemented in C++, with support for garbage collection: JavaScript VMs do this. Similarly, you’ve probably played games which mix C++ and C# using the Unity game engine, which <a href="https://docs.unity3d.com/Manual/UnderstandingAutomaticMemoryManagement.html">relies on the Boehm GC</a>.</p>
   <p>Example of virtual machines written in C++ with support for garbage collection include:</p>
   <ul>
    <li data-md>
     <p>WebKit’s JavaScriptCore use a garbage collector called <a href="https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/">Riptide</a>.</p>
    <li data-md>
     <p>Chromium’s <a href="https://chromium.googlesource.com/chromium/src/+/master/third_party/blink/renderer/platform/heap/BlinkGCAPIReference.md">Blink GC called Oilpan</a>. The V8 blog has <a href="https://v8.dev/blog/high-performance-cpp-gc">a good overview of Oilpan</a>. The V8 JavaScript engine used by Chromium also has its own garbage collector called <a href="https://v8.dev/blog/trash-talk">Orinoco</a>.</p>
    <li data-md>
     <p>Firefox’s SpiderMonkey JavaScript engine also <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Internals/Garbage_collection">has a garbage collector</a>.</p>
    <li data-md>
     <p>Lua and LuaJIT <a href="http://wiki.luajit.org/New-Garbage-Collector">use garbage collection</a>.</p>
   </ul>
   <p>As you can see from their documentation, each garbage collector has its own set of design criteria which influence how the language itself is implemented, and how the C++ runtime is written to obey the chosen design. These languages use similar ideas, but the design is different in each case, and the constraints on C++ code are different.</p>
   <h2 class="heading settled" data-level="4" id="oops"><span class="secno">4. </span><span class="content">Issues with the Current Specification</span><a class="self-link" href="#oops"></a></h2>
   <p>We illustrate a few problems with the current specification as it stands, in some cases where the current specification is overly restrictive, and in others where it falls short.</p>
   <h3 class="heading settled" data-level="4.1" id="safe"><span class="secno">4.1. </span><span class="content">Safely Derived Pointers</span><a class="self-link" href="#safe"></a></h3>
   <p>The complete list of ways to create a safely-derived pointer is itemized in <strong>[basic.stc.dynamic.safety]</strong> ❡2. The list is mostly manipulation of existing safely-derived pointers, where the only way to create the initial safely-derived pointer is through a call to one of two specified overloads of global <code class="highlight"><c- o>::</c-><c- k>operator</c-> <c- k>new</c-></code>. It does not have an escape hatch for implementation-defined behavior adding additional ways to create a safely derived pointer. In particular, calls to global array-<code class="highlight"><c- k>new</c-></code>, or no-throw <code class="highlight"><c- k>new</c-></code>, do not produce safely-derived pointers unless defined to call one of the two specified overloads.</p>
   <p>However, the most troubling example is using in-place new to create object in local arrays, a common strategy to avoid unnecessary heap usage:</p>
<pre class="highlight"><code><c- cp>#include</c-> &lt;new>

<c- b>int</c-> <c- nf>main</c-><c- p>()</c-> <c- p>{</c->
   <c- b>char</c-> <c- n>buffer</c-><c- p>[</c-><c- k>sizeof</c-><c- p>(</c-><c- b>int</c-><c- p>)]</c-> <c- k>alignas</c-><c- p>(</c-><c- b>int</c-><c- p>);</c-> <c- c1>// automatic storage duration</c->
   <c- b>void</c-> <c- o>*</c-><c- n>ptr</c-> <c- o>=</c-> <c- n>buffer</c-><c- p>;</c->
   <c- b>int</c-> <c- o>*</c-><c- n>pint</c-> <c- o>=</c-> <c- k>new</c-><c- p>(</c-><c- n>ptr</c-><c- p>)</c-> <c- b>int</c-><c- p>(</c-><c- mi>0</c-><c- p>);</c->           <c- c1>// dynamic storage duration</c->
   <c- k>return</c-> <c- o>*</c-><c- n>pint</c-><c- p>;</c->                          <c- c1>// UB with strict pointer safety</c->
<c- p>}</c->
</code></pre>
   <p>Instinctively, we might reach for <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>declare_reachable</c-></code> to solve such matters ourselves, at the expense of complicating portable code for the befit of well-defined behavior on strict pointer safety systems. Alas! This does not work, as the precondition on <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>declare_reachable</c-></code> is that the supplied pointer be safely-derived—the very problem we are trying to solve by using this function! Even if that precondition were relaxed, there would be a problem calling <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>undeclare_reachable</c-></code> before the function returns.</p>
   <h3 class="heading settled" data-level="4.2" id="alloc"><span class="secno">4.2. </span><span class="content">Allocators</span><a class="self-link" href="#alloc"></a></h3>
   <p>Safely derived pointers to dynamic memory cannot be provided other than by calls to <code class="highlight"><c- o>::</c-><c- k>operator</c-> <c- k>new</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- b>size_t</c-><c- p>)</c-></code> or <code class="highlight"><c- o>::</c-><c- k>operator</c-> <c- k>new</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- b>size_t</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>align_val_t</c-><c- p>)</c-></code>, see <strong>[basic.stc.dynamic.safety]</strong> ❡1. This means we have no support for OS memory allocation functions, such as <code class="highlight"><c- n>VirtualAlloc</c-></code> or <code class="highlight"><c- n>HeapAlloc</c-></code> on Windows, or use of memory mapped files for interprocess communication.</p>
   <p>Custom memory allocation, as might be supplied by a type that meets the allocator requirements, or implements the <code class="highlight"><c- n>prm</c-><c- o>::</c-><c- n>memory_resource</c-></code> interface, typically rely on such allocation subsystems, and would need some as yet unspecified scheme to indicate that they hold valid memory that could hold pointers to live objects. Note that simply calling <code class="highlight"><c- n>declare_reachable</c-></code> on every attempt to construct an object through such an allocator is not sufficient, as that function has a precondition that the pointer argument is safely-derived—exactly the problem we are trying to solve.</p>
   <h3 class="heading settled" data-level="4.3" id="new"><span class="secno">4.3. </span><span class="content">Replacement <code class="highlight"><c- k>operator</c-> <c- k>new</c-></code></span><a class="self-link" href="#new"></a></h3>
   <p>The only two library functions guaranteed to return a safely-derived pointer are <em>replaceable</em>, but there is no mention in the library specification of what it means to replace these functions on an implementation with strict pointer safety, or whether the replacement might in turn might introduce strict pointer safety into the program.</p>
   <p>Further, according to <strong>[expr.new]</strong> ❡12, "An implementation is allowed to omit a call to a replaceable global allocation function. When it does so, the storage is instead provided by the implementation or provided by extending the allocation of another new-expression." If this is intended that these extended allocations be constrained to return a safely pointer on implementations with strict pointer safety, a note (if not normative text) would be helpful.</p>
   <h3 class="heading settled" data-level="4.4" id="constexpr"><span class="secno">4.4. </span><span class="content"><code class="highlight"><c- k>constexpr</c-></code> Allocation</span><a class="self-link" href="#constexpr"></a></h3>
   <p>Does compile-time (<code class="highlight"><c- k>constexpr</c-></code>) allocation by the language have strict, relaxed, or preferred memory safety? In practice, the current answer is largely irrelevant, as the only supported compile-time allocators call the global <code class="highlight"><c- o>::</c-><c- k>operator</c-> <c- k>new</c-></code> function, which by definition returns safely-derived pointers. Similarly, the masking and unmasking operations that might produce non-safely-derived pointers are not supported during constant evaluation. However, do note that the library facilities for handling pointer safety are not marked as <code class="highlight"><c- k>constexpr</c-></code>, so any library containers that make an effort to tune for performance on a garbage collected implementation must also guard such calls with a check for if (<code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>is_constant_evaluated</c-><c- p>()</c-></code>), genuinely avoid pointer masking tricks, and prepare for <a data-link-type="biblio" href="#biblio-p1974r0" title="Non-transient constexpr allocation using propconst">[P1974R0]</a> Non-transient <code class="highlight"><c- k>constexpr</c-></code> allocation using <code class="highlight"><c- n>propconst</c-></code> providing support for <code class="highlight"><c- k>constinit</c-></code> objects allocated at compile-time, but used and extended at runtime.</p>
   <h3 class="heading settled" data-level="4.5" id="corelib"><span class="secno">4.5. </span><span class="content">Core versus Library Wording</span><a class="self-link" href="#corelib"></a></h3>
   <p>The core language talks about traceable pointer <em>objects</em> while the library uses the term traceable pointer <em>location</em>. This latter term is never defined, although the inference from cross-references is that they may be intended to mean the same thing. We should use the core term throughout the library as well, or more clearly define their relationship if distinct terms are intended.</p>
   <p>Our current best guess is that the two terms are intended to be distinct. From the usage in <strong>[util.dynamic.safety]</strong> ❡11, it seems that a traceable pointer location is a possible property of the value stored in a traceable pointer object, such that all traceable pointer objects assume the traceable pointer location property unless <code class="highlight"><c- n>declare_no_pointers</c-></code> is called.</p>
   <h3 class="heading settled" data-level="4.6" id="CHAR_BIT"><span class="secno">4.6. </span><span class="content"><code class="highlight"><c- b>signed</c-> <c- b>char</c-></code> and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>byte</c-></code></span><a class="self-link" href="#CHAR_BIT"></a></h3>
   <p>According to <strong>[basic.stc.dynamic.safety]</strong> ❡3, a <em>traceable pointer object</em> may be "a sequence of elements in an array of narrow character type, where the size and alignment of the sequence match those of some object pointer type." This seems reasonable for types <code class="highlight"><c- b>char</c-></code> and <code class="highlight"><c- b>unsigned</c-> <c- b>char</c-></code>, which have special dispensation to be trafficked as raw memory. However, it may be more surprising to find this applies to arrays of <code class="highlight"><c- b>signed</c-> <c- b>char</c-></code> and <code class="highlight"><c- b>char8_t</c-></code> as well, which other than in this one paragraph, have no such memory aliasing properties. Similarly, it is surprising that arrays of <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>byte</c-></code>, a type deliberately introduced to describe raw memory, do not have this property.</p>
   <h3 class="heading settled" data-level="4.7" id="prefer"><span class="secno">4.7. </span><span class="content">Preferred Pointer Safety</span><a class="self-link" href="#prefer"></a></h3>
   <p>A call to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>get_pointer_safety</c-></code> can return a value indicating <code class="highlight"><c- n>strict</c-></code>, <code class="highlight"><c- n>relaxed</c-></code>, or <code class="highlight"><c- n>preferred</c-></code>. It is not clear what the difference between <code class="highlight"><c- n>preferred</c-></code> and <code class="highlight"><c- n>relaxed</c-></code> memory safety is. From a core wording perspective, there is no difference, so the domain of well-defined behavior does not change. Other than this one mention on the specification for the <code class="highlight"><c- n>get_pointer_safety</c-></code> there is no description of what it means, and how programs should behave differently when informed of this. It appears to raise confusion, for no clear benefit. For example, should a program with concerns about <code class="highlight"><c- n>strict</c-></code> pointer safety check that an implementation has <code class="highlight"><c- n>relaxed</c-></code> pointer safety, or merely that it does not have <code class="highlight"><c- n>strict</c-></code> pointer safety? While these two questions are equivalent according to the core language specification, they can produce different results when querying the library API intended for this purpose.</p>
   <h3 class="heading settled" data-level="4.8" id="c"><span class="secno">4.8. </span><span class="content">C Compatibility</span><a class="self-link" href="#c"></a></h3>
   <p>Despite a decade of standards since C++11 (C11, C18, and the pending C2X), there has been no enthusiasm in WG14 to add similar garbage collection support to the C language.</p>
   <h3 class="heading settled" data-level="4.9" id="malloc"><span class="secno">4.9. </span><span class="content"><code class="highlight"><c- n>malloc</c-></code> and Related Functions</span><a class="self-link" href="#malloc"></a></h3>
   <p>In order to achieve binary compatibility with C code, an implementation must assume that all memory returned from a call to a C allocation function is implicitly declared reachable. It is not clear how this differs from being a safely-derived pointer, as a pointer to an object that has been declared reachable is never treated as invalid due to not being safely-derived. We suspect the intent is that such memory is to be treated similarly to that for automatic, static, and thread-local storage duration objects, other than the obscure normative text that says such pointers can be passed to <code class="highlight"><c- n>declare_unreachable</c-></code> which must somehow contrive to support this, and most likely ignore that pointer in such cases. This seems an obscurely specific way to permit a subset of pointers to be validly passed to a function that has no business seeing them. It would be much simpler to make the precondition on <code class="highlight"><c- n>declare_unreachable</c-></code> that there be a matching call to <code class="highlight"><c- n>declare_reachable</c-></code>, or to use another term to describe the reachability that comes from a call to the C allocation APIs.</p>
   <h2 class="heading settled" data-level="5" id="rationale"><span class="secno">5. </span><span class="content">Rationale</span><a class="self-link" href="#rationale"></a></h2>
   <p>Based on the above history, Garbage Collection in C++ is clearly useful for particular applications.</p>
   <p>However, Garbage Collection as specified by the Standard is not useful for those applications. In fact, the authors are not aware of any implementations of the strict pointer safety facility. Unsurprisingly, the authors are not aware of any uses either. Indeed, <a href="https://codesearch.isocpp.org/">ISOCpp code search only finds hits in GCC and LLVM</a>. Similarly, <a href="https://en.cppreference.com/w/cpp/compiler_support#cpp11">CppReference tells us</a> that implementations all offer no support for this feature. Finally, the specification falls short in many ways as outlined above.</p>
   <p>It’s unclear whether the Standard should make Garbage Collection an (optional?) first-class feature, because the aforementioned language VMs function differently from each other. What is clear is that the current specification isn’t helpful for any of them. The library facilities are clearly unused. The Core wording intends to offer minimal guarantees for garbage collectors, but doesn’t actually provide any actionable guidance to implementations, even if "strict" pointer safety were offered. Even then, libc++, libstdc++, and Microsoft’s Standard Library <a href="https://godbolt.org/z/ANaGAH">all offer relaxed pointer safety and not strict pointer safety</a>. In other words, the Core wording currently provides no restrictions on implementations, and the implementations nonetheless decided to go for the weaker "relaxed" option. Further, garbage collectors rely on other quality-of-implementations factors which Core wording is silent on.</p>
   <p>Finally, existing Standard Library implementations would need to be significantly changed were they to attempt supporting strict pointer safety, for example by marking regions memory pointer-free with <code class="highlight"><c- n>declare_no_pointers</c-></code> in containers such as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-></code>. Asking a Standard Library implementation to provide good support for strict pointer safety is tantamount to doubling the number of dialects that should be supported (including existing unofficial dialects such as without exceptions and type information).</p>
   <p>This status-quo hasn’t changed in 12 years. The maintenance burden on the Standard is near minimal, and we hope the Committee spends almost no time agreeing to remove this unused and unimplemented feature, despite its origins being well-intended and the target use-case still being relevant. Indeed, the current specification simply missed the mark, and will not be missed.</p>
   <p>We therefore propose outright removal instead of deprecation because lack of implementation and usage makes deprecation moot.</p>
   <h2 class="heading settled" data-level="6" id="other"><span class="secno">6. </span><span class="content">Other Concerns</span><a class="self-link" href="#other"></a></h2>
   <p>There are several other features in C++ that deal with the validity of pointers, or allocating memory. After some consideration, the following features were reviewed, but determined to have no impact on the strict pointer safety model. They are listed here so that the reader is aware that they were not overlooked.</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>launder</c-></code></p>
    <li data-md>
     <p>allocation for coroutines</p>
    <li data-md>
     <p>allocation for exception objects</p>
   </ul>
   <h2 class="heading settled" data-level="7" id="proposal"><span class="secno">7. </span><span class="content">Proposal</span><a class="self-link" href="#proposal"></a></h2>
   <p>Remove all of <strong>[basic.stc.dynamic.safety]</strong> as follows:</p>
   <blockquote>
    <del>
      A <em>traceable pointer object</em> is 
     <ul>
      <li data-md>
       <p>an object of an object pointer type, or</p>
      <li data-md>
       <p>an object of an integral type that is at least as large as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- b>intptr_t</c-></code>, or</p>
      <li data-md>
       <p>a sequence of elements in an array of narrow character type, where the size and alignment of the sequence match those of some object pointer type.</p>
     </ul>
    </del>
    <del>
     A pointer value is a <em>safely-derived pointer</em> to an object with dynamic storage duration only if the pointer value has an object pointer type and is one of the following: 
     <ul>
      <li data-md>
       <p>the value returned by a call to the C++ standard library implementation of <code class="highlight"><c- o>::</c-><c- k>operator</c-> <c- k>new</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- b>size_t</c-><c- p>)</c-></code> or <code class="highlight"><c- o>::</c-><c- k>operator</c-> <c- k>new</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- b>size_t</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>align_val_t</c-><c- p>)</c-></code></p>
      <li data-md>
       <p>the result of taking the address of an object (or one of its subobjects) designated by an lvalue resulting from indirection through a safely-derived pointer value;</p>
      <li data-md>
       <p>the result of well-defined pointer arithmetic using a safely-derived pointer value;</p>
      <li data-md>
       <p>the result of a well-defined pointer conversion of a safely-derived pointer value;</p>
      <li data-md>
       <p>the result of a <code class="highlight"><c- k>reinterpret_cast</c-></code> of a safely-derived pointer value;</p>
      <li data-md>
       <p>the result of a <code class="highlight"><c- k>reinterpret_cast</c-></code> of an integer representation of a safely-derived pointer value;</p>
      <li data-md>
       <p>the value of an object whose value was copied from a traceable pointer object, where at the time of the copy the source object contained a copy of a safely-derived pointer value.</p>
     </ul>
    </del>
    <del>
      An integer value is an <em>integer representation of a safely-derived pointer</em> only if its type is at least as large as <code class="highlight"><c- n>std</c-><c- o>::</c-><c- b>intptr_t</c-></code> and it is one of the following: 
     <ul>
      <li data-md>
       <p>the result of a <code class="highlight"><c- k>reinterpret_cast</c-></code> of a safely-derived pointer value;</p>
      <li data-md>
       <p>the result of a valid conversion of an integer representation of a safely-derived pointer value;</p>
      <li data-md>
       <p>the value of an object whose value was copied from a traceable pointer object, where at the time of the copy the source object contained an integer representation of a safely-derived pointer value;</p>
      <li data-md>
       <p>the result of an additive or bitwise operation, one of whose operands is an integer representation of a safely-derived pointer value <code class="highlight"><c- n>P</c-></code>, if that result converted by <code class="highlight"><c- k>reinterpret_cast</c-><c- o>&lt;</c-><c- b>void</c-><c- o>*></c-></code> would compare equal to a safely-derived pointer computable from <code class="highlight"><c- k>reinterpret_cast</c-><c- o>&lt;</c-><c- b>void</c-><c- o>*></c-><c- p>(</c-><c- n>P</c-><c- p>)</c-></code>.</p>
     </ul>
    </del>
    <del> An implementation may have <code class="highlight"><c- n>relaxed</c-> <c- n>pointer</c-> <c- n>safety</c-></code>, in which case the validity of a pointer value does not depend on whether it is a safely-derived pointer value. Alternatively, an implementation may have <code class="highlight"><c- n>strict</c-> <c- n>pointer</c-> <c- n>safety</c-></code>, in which case a pointer value referring to an object with dynamic storage duration that is not a safely-derived pointer value is an invalid pointer value unless the referenced complete object has previously been declared reachable. [<em>Note:</em> The effect of using an invalid pointer value (including passing it to a deallocation function) is undefined. This is true even if the unsafely-derived pointer value might compare equal to some safely-derived pointer value. — <em>end note</em> ] It is implementation defined whether an implementation has relaxed or strict pointer safety. </del>
   </blockquote>
   <p>In <strong>[expr.reinterpret.cast]</strong>, remove the note as follows:</p>
   <blockquote>
     A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type will have its original value; mappings between pointers and integers are otherwise implementation-defined. 
    <del>[<em>Note:</em> Except as described in <strong>[basic.stc.dynamic.safety]</strong>, the result of such a conversion will not be a safely-derived pointer value.
— <em>end note</em> ]</del>
   </blockquote>
   <p>In <strong>[new.delete]</strong>, remove the six instances of the pointer safety precondition on <code class="highlight"><c- k>operator</c-> <c- k>delete</c-></code> overloads as follows:</p>
   <blockquote>
<pre class="highlight"><code><c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->
<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- b>size_t</c-> <c- n>size</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->
<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>align_val_t</c-> <c- n>alignment</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->
<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- b>size_t</c-> <c- n>size</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>align_val_t</c-> <c- n>alignment</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->

<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- k>const</c-> <c- n>std</c-><c- o>::</c-><c- n>nothrow_t</c-><c- o>&amp;</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->
<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>align_val_t</c-> <c- n>alignment</c-><c- p>,</c-> <c- k>const</c-> <c- n>std</c-><c- o>::</c-><c- n>nothrow_t</c-><c- o>&amp;</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->

<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>[](</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->
<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>[](</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- b>size_t</c-> <c- n>size</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->
<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>[](</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>align_val_t</c-> <c- n>alignment</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->
<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>[](</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- b>size_t</c-> <c- n>size</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>align_val_t</c-> <c- n>alignment</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->

<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>[](</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- k>const</c-> <c- n>std</c-><c- o>::</c-><c- n>nothrow_t</c-><c- o>&amp;</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->
<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>[](</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>align_val_t</c-> <c- n>alignment</c-><c- p>,</c-> <c- k>const</c-> <c- n>std</c-><c- o>::</c-><c- n>nothrow_t</c-><c- o>&amp;</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->

<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->

<c- b>void</c-> <c- k>operator</c-> <c- k>delete</c-><c- p>[](</c-><c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->
</code></pre>
    <del><em>Preconditions:</em> If an implementation has strict pointer safety <strong>[basic.stc.dynamic.safety]</strong> then ptr is a safely-derived pointer.</del>
   </blockquote>
   <p>In <strong>[memory.syn]</strong>, remove as follows:</p>
   <blockquote>
<pre class="highlight"><code><del><c- c1>// 20.10.5, pointer safety</c->
<c- k>enum</c-> <c- k>class</c-> <c- nc>pointer_safety</c-> <c- p>{</c-> <c- n>relaxed</c-><c- p>,</c-> <c- n>preferred</c-><c- p>,</c-> <c- n>strict</c-> <c- p>};</c->
<c- b>void</c-> <c- nf>declare_reachable</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>p</c-><c- p>);</c->
<c- k>template</c-><class t>
<c- n>T</c-><c- o>*</c-> <c- nf>undeclare_reachable</c-><c- p>(</c-><c- n>T</c-><c- o>*</c-> <c- n>p</c-><c- p>);</c->
<c- b>void</c-> <c- nf>declare_no_pointers</c-><c- p>(</c-><c- b>char</c-><c- o>*</c-> <c- n>p</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>n</c-><c- p>);</c->
<c- b>void</c-> <c- nf>undeclare_no_pointers</c-><c- p>(</c-><c- b>char</c-><c- o>*</c-> <c- n>p</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>n</c-><c- p>);</c->
<c- n>pointer_safety</c-> <c- nf>get_pointer_safety</c-><c- p>()</c-> <c- k>noexcept</c-><c- p>;</c->
</class></del></code></pre>
   </blockquote>
   <p>Remove all of <strong>[util.dynamic.safety]</strong>, and associated implementation-defined behavior in the annex.</p>
   <p>In <strong>[cpp.predefined]</strong>, remove as follows:</p>
   <blockquote>
    <del><code class="highlight"><c- n>__STDCPP_STRICT_POINTER_SAFETY__</c-></code></del>
     <br> 
    <del>Defined, and has the value integer literal <code class="highlight"><c- mi>1</c-></code>, if and only if the implementation has strict pointer safety.</del>
   </blockquote>
   <p>In <strong>[c.malloc]</strong>, remove as follows:</p>
   <blockquote>
    <del> Storage allocated directly with these functions is implicitly declared reachable on allocation, ceases to be declared reachable on deallocation, and need not cease to be declared reachable as the result of an <code class="highlight"><c- n>undeclare_reachable</c-><c- p>()</c-></code> call. [ <em>Note:</em> This allows existing C libraries to remain unaffected by restrictions on pointers that are not safely derived, at the expense of providing far fewer garbage collection and leak detection options for <code class="highlight"><c- n>malloc</c-><c- p>()</c-></code>-allocated objects. It also allows <code class="highlight"><c- n>malloc</c-><c- p>()</c-></code> to be implemented with a separate allocation arena, bypassing the normal <code class="highlight"><c- n>declare_reachable</c-><c- p>()</c-></code> implementation. The above functions should never intentionally be used as a replacement for <code class="highlight"><c- n>declare_reachable</c-><c- p>()</c-></code>, and newly written code is strongly encouraged to treat memory allocated with these functions as though it were allocated with <code class="highlight"><c- k>operator</c-> <c- k>new</c-></code>. — <em>end note</em> ] </del>
   </blockquote>
   <p>In <strong>[zombie.names]</strong>, add the following names:</p>
   <blockquote>
    <ins>
     <ul>
      <li data-md>
       <p><code class="highlight"><c- n>declare_reachable</c-></code></p>
      <li data-md>
       <p><code class="highlight"><c- n>undeclare_reachable</c-></code></p>
      <li data-md>
       <p><code class="highlight"><c- n>declare_no_pointers</c-></code></p>
      <li data-md>
       <p><code class="highlight"><c- n>undeclare_no_pointers</c-></code></p>
      <li data-md>
       <p><code class="highlight"><c- n>get_pointer_safety</c-></code></p>
      <li data-md>
       <p><code class="highlight"><c- n>pointer_safety</c-></code></p>
     </ul>
    </ins>
   </blockquote>
  </main>
<script>
(function() {
  "use strict";
  var collapseSidebarText = '<span aria-hidden="true">←</span> '
                          + '<span>Collapse Sidebar</span>';
  var expandSidebarText   = '<span aria-hidden="true">→</span> '
                          + '<span>Pop Out Sidebar</span>';
  var tocJumpText         = '<span aria-hidden="true">↑</span> '
                          + '<span>Jump to Table of Contents</span>';

  var sidebarMedia = window.matchMedia('screen and (min-width: 78em)');
  var autoToggle   = function(e){ toggleSidebar(e.matches) };
  if(sidebarMedia.addListener) {
    sidebarMedia.addListener(autoToggle);
  }

  function toggleSidebar(on) {
    if (on == undefined) {
      on = !document.body.classList.contains('toc-sidebar');
    }

    /* Don't scroll to compensate for the ToC if we're above it already. */
    var headY = 0;
    var head = document.querySelector('.head');
    if (head) {
      // terrible approx of "top of ToC"
      headY += head.offsetTop + head.offsetHeight;
    }
    var skipScroll = window.scrollY < headY;

    var toggle = document.getElementById('toc-toggle');
    var tocNav = document.getElementById('toc');
    if (on) {
      var tocHeight = tocNav.offsetHeight;
      document.body.classList.add('toc-sidebar');
      document.body.classList.remove('toc-inline');
      toggle.innerHTML = collapseSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, 0 - tocHeight);
      }
      tocNav.focus();
      sidebarMedia.addListener(autoToggle); // auto-collapse when out of room
    }
    else {
      document.body.classList.add('toc-inline');
      document.body.classList.remove('toc-sidebar');
      toggle.innerHTML = expandSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, tocNav.offsetHeight);
      }
      if (toggle.matches(':hover')) {
        /* Unfocus button when not using keyboard navigation,
           because I don't know where else to send the focus. */
        toggle.blur();
      }
    }
  }

  function createSidebarToggle() {
    /* Create the sidebar toggle in JS; it shouldn't exist when JS is off. */
    var toggle = document.createElement('a');
      /* This should probably be a button, but appearance isn't standards-track.*/
    toggle.id = 'toc-toggle';
    toggle.class = 'toc-toggle';
    toggle.href = '#toc';
    toggle.innerHTML = collapseSidebarText;

    sidebarMedia.addListener(autoToggle);
    var toggler = function(e) {
      e.preventDefault();
      sidebarMedia.removeListener(autoToggle); // persist explicit off states
      toggleSidebar();
      return false;
    }
    toggle.addEventListener('click', toggler, false);


    /* Get <nav id=toc-nav>, or make it if we don't have one. */
    var tocNav = document.getElementById('toc-nav');
    if (!tocNav) {
      tocNav = document.createElement('p');
      tocNav.id = 'toc-nav';
      /* Prepend for better keyboard navigation */
      document.body.insertBefore(tocNav, document.body.firstChild);
    }
    /* While we're at it, make sure we have a Jump to Toc link. */
    var tocJump = document.getElementById('toc-jump');
    if (!tocJump) {
      tocJump = document.createElement('a');
      tocJump.id = 'toc-jump';
      tocJump.href = '#toc';
      tocJump.innerHTML = tocJumpText;
      tocNav.appendChild(tocJump);
    }

    tocNav.appendChild(toggle);
  }

  var toc = document.getElementById('toc');
  if (toc) {
    createSidebarToggle();
    toggleSidebar(sidebarMedia.matches);

    /* If the sidebar has been manually opened and is currently overlaying the text
       (window too small for the MQ to add the margin to body),
       then auto-close the sidebar once you click on something in there. */
    toc.addEventListener('click', function(e) {
      if(e.target.tagName.toLowerCase() == "a" && document.body.classList.contains('toc-sidebar') && !sidebarMedia.matches) {
        toggleSidebar(false);
      }
    }, false);
  }
  else {
    console.warn("Can't find Table of Contents. Please use <nav id='toc'> around the ToC.");
  }

  /* Wrap tables in case they overflow */
  var tables = document.querySelectorAll(':not(.overlarge) > table.data, :not(.overlarge) > table.index');
  var numTables = tables.length;
  for (var i = 0; i < numTables; i++) {
    var table = tables[i];
    var wrapper = document.createElement('div');
    wrapper.className = 'overlarge';
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);
  }

})();
</script>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
  <h3 class="no-num no-ref heading settled" id="informative"><span class="content">Informative References</span><a class="self-link" href="#informative"></a></h3>
  <dl>
   <dt id="biblio-n2310">[N2310]
   <dd>H.-J. Boehm, M. Spertus. <a href="https://wg21.link/n2310"><cite>Transparent Programmer-Directed Garbage Collection for C++</cite></a>. 20 June 2007. URL: <a href="https://wg21.link/n2310">https://wg21.link/n2310</a>
   <dt id="biblio-n2585">[N2585]
   <dd>H. Boehm, M. Spertus. <a href="https://wg21.link/n2585"><cite>Minimal Support for Garbage Collection and Reachability-Based Leak Detection</cite></a>. 16 March 2008. URL: <a href="https://wg21.link/n2585">https://wg21.link/n2585</a>
   <dt id="biblio-n2670">[N2670]
   <dd>H.-J. Boehm, M. Spertus, C. Nelson. <a href="https://wg21.link/n2670"><cite>Minimal Support for Garbage Collection and Reachability-Based Leak Detection (revised)</cite></a>. 13 June 2008. URL: <a href="https://wg21.link/n2670">https://wg21.link/n2670</a>
   <dt id="biblio-p1974r0">[P1974R0]
   <dd>Jeff Snyder, Louis Dionne, Daveed Vandevoorde. <a href="https://wg21.link/p1974r0"><cite>Non-transient constexpr allocation using propconst</cite></a>. 15 May 2020. URL: <a href="https://wg21.link/p1974r0">https://wg21.link/p1974r0</a>
  </dl>