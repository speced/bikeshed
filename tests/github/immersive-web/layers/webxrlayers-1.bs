<pre class="metadata">
Shortname: webxrlayers
Title: WebXR Layers API Level 1
Group: immersivewebwg
Status: ED
TR: https://www.w3.org/TR/webxrlayers-1/
ED: https://immersive-web.github.io/layers/
Previous Version: https://www.w3.org/TR/2020/WD-webxrlayers-1-20201203/
Repository: immersive-web/layers
Level: 1
Mailing List Archives: https://lists.w3.org/Archives/Public/public-immersive-web/

Editor: Rik Cabanier 106988, Facebook https://oculus.com, cabanier@fb.com

Abstract: This specification describes support for various layer types used in a WebXR session.
</pre>

<pre class="link-defaults">
spec:infra;
    type: dfn; text:string
spec: permissions-request-1;
    type: dfn; text: request(permissionDesc); for: Permissions
spec: webxr;
    type: dfn; text: immersive xr device; for: XR
    type: dfn; text: xr device; for: /
    type: dfn; text: active; for: XRFrame
    type: dfn; text: eye; for: XRView
    type: dfn; text: initialize the render state
    type: dfn; text: active render state
    type: dfn; text: pending render state
    type: dfn; text: apply the pending render state
    type: dfn; text: viewer reference space
    type: dfn; text: xr animation frame
    type: dfn; text: immersive xr device
    type: dfn; text: list of views; for: XRSession
    type: dfn; text: list of viewports
    type: dfn; text: opaque framebuffer
    type: dfn; text: feature descriptor
    type: dfn; text: feature requirement
    type: dfn; text: active immersive session
    type: dfn; text: type; for: XRReferenceSpace
    type: dfn; text: session; for: XRSpace
    type: dfn; text: view
    type: dfn; text: XRLayer
    type: dfn; text: XRReferenceSpace
    type: dfn; text: type; for: XRReferenceSpace
    type: dfn; text: updateRenderState; for: XRSession
    type: dfn; text: session; for: XRWebGLLayer
    type: dfn; text: layers; for: XRRenderStateInit
    type: dfn; text: secondary-views; for: secondary view
    type: dfn; text: primary view
    type: dfn; text: secondary view
    type: dfn; text: active; for: view
spec: html;
    type: dfn; text: check the usability of the image argument
    type: dfn; text: request the xr permission
spec:webidl;
    type:dfn; text:new
</pre>

<pre class="anchors">
spec: webxr; urlPrefix: https://www.w3.org/TR/webxr/
    type: dfn; text: feature descriptor
    type: dfn; text: xr compositor
    type: dfn; text: recommended WebGL framebuffer resolution
    type: dfn; text: native WebGL framebuffer resolution
    type: dfn; text: immersive session
    type: dfn; text: xr compatible
    type: dfn; text: ended
    type: dfn; text: context
    type: dfn; text: XRFrame/active
    type: dfn; text: XRView/active
    type: dfn; text: eye; for: XRView
    type: dfn; text: frame
    type: dfn; text: animationFrame; for: XRFrame
    type: dfn; text: XRSession/requestAnimationFrame()
spec: WebGL; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/1.0/
    type: interface; text: WebGLFramebuffer; url: WebGLFramebuffer
    type: interface; text: WebGLTexture; url: WebGLTexture
    type: interface; text: WebGLShader; url: 5.8
    type: interface; text: WebGLRenderingContext; url: WebGLRenderingContext
    type: interface; text: WebGLRenderingContextBase; url: WebGLRenderingContextBase
    type: typedef; text: INVALID_OPERATION; url: WebGLRenderingContextBase
    type: typedef; text: TEXTURE_2D; url: 5.14
    type: typedef; text: TEXTURE_CUBE_MAP; url: 5.14
    type: method; text: clear; url: 5.14.11
    type: method; text: deleteTexture;  url: 5.14.8
    type: method; text: drawArrays; url: 5.14.11
    type: method; text: drawElements; url: 5.14.11
    type: dfn; text: WebGL viewport; url:#5.14.4
    type: typedef; text: GLenum; url: #5.1
    type: typedef; text: RGBA; url: #5.14
    type: typedef; text: RGB; url: #5.14
    type: dfn; text: extension; url:#5.14.14
spec: ; urlPrefix: https://www.khronos.org/registry/webgl/extensions/EXT_sRGB/
    type: typedef; text: SRGB_EXT
    type: typedef; text: SRGB_ALPHA_EXT
    type: typedef; text: EXT_sRGB
spec: ; urlPrefix: https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/
    type: typedef; text: DEPTH_COMPONENT
    type: typedef; text: DEPTH_STENCIL
    type: typedef; text: WEBGL_depth_texture
spec: ; urlPrefix: https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/
    type: typedef; text: COMPRESSED_RGB8_ETC2
    type: typedef; text: COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
    type: typedef; text: COMPRESSED_RGBA8_ETC2_EAC
    type: typedef; text: COMPRESSED_SRGB8_ETC2
    type: typedef; text: COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
    type: typedef; text: COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
    type: typedef; text: WEBGL_compressed_texture_etc
spec: ; urlPrefix: https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/
    type: typedef; text: WEBGL_compressed_texture_astc
spec: WebGL 2.0; urlPrefix: https://www.khronos.org/registry/webgl/specs/latest/2.0/
    type: interface; text: WebGL2RenderingContext; url: WebGL2RenderingContext
    type: typedef; text: TEXTURE_2D_ARRAY; url: 3.7
    type: dfn; text: texStorage2D; url: 3.7.6
    type: dfn; text: texStorage3D; url: 3.7.6
    type: typedef; text: RGB8; url: #5.14
    type: typedef; text: RGBA8; url: #5.14
    type: typedef; text: SRGB8; url: #5.14
    type: typedef; text: SRGB8_ALPHA8; url: #5.14
    type: typedef; text: DEPTH_COMPONENT24; url: #5.14
    type: typedef; text: DEPTH24_STENCIL8; url: #5.14
    type: typedef; text: STENCIL_INDEX8; url: #5.14
spec: WEBGL_depth_texture; urlPrefix: https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/
    type: typedef; text: WEBGL_depth_texture
    type: typedef; text: UNSIGNED_INT_24_8_WEBGL
spec:html; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: dfn; text: current realm; url: webappapis.html#current
spec: ECMAScript; urlPrefix: https://tc39.github.io/ecma262/#
    type: dfn; text: Realm; url: realm
spec: compositing-1; urlPrefix: https://www.w3.org/TR/compositing-1/
    type: dfn; text: source-over; url: porterduffcompositingoperators_srcover
</pre>


<pre class=link-defaults>
    spec:webxr-ar-module-1; type:enum-value; text:"immersive-ar"
</pre>

<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">

<style>
  .unstable::before {
    content: "This section is not stable";
    display: block;
    font-weight: bold;
    text-align: right;
    color: red;
  }
  .unstable {
    border: thin solid pink;
    border-radius: .5em;
    padding: .5em;
    margin: .5em calc(-0.5em - 1px);
    background-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='300' height='290'><text transform='rotate(-45)' text-anchor='middle' font-family='sans-serif' font-weight='bold' font-size='70' y='210' opacity='.1'>Unstable</text></svg>");
    background-repeat: repeat;
    background-color: #FFF4F4;
  }
  .unstable h3:first-of-type {
    margin-top: 0.5rem;
  }

  .unstable.example:not(.no-marker)::before {
    content: "Example " counter(example) " (Unstable)";
    float: none;
  }

  .non-normative::before {
    content: "This section is non-normative.";
    font-style: italic;
  }
  .tg {
    border-collapse: collapse;
    border-spacing: 0;
  }
  .tg th {
    border-style: solid;
    border-width: 1px;
    background: #90b8de;
    color: #fff;
    font-family: sans-serif;
    font-weight: bold;
    border-color: grey;
  }
  .tg td {
    padding: 4px 5px;
    background-color: rgb(221, 238, 255);
    font-family: monospace;
    border-style: solid;
    border-width: 1px;
    border-color: grey;
    overflow: hidden;
    word-break: normal;
  }
</style>

Introduction {#intro}
============

<section class="non-normative">

The spec adds support of `composition` layers to the WebXR spec. The benefits of layers are as follows:

 * <b>Performance and judder</b> Composition layers are presented at the frame rate of the compositor (i.e. native refresh rate of HMD) rather than at the application frame rate.
    Even when the application is not updating the layer's rendering at the native refresh rate of the compositor, the compositor might be able to re-project the existing
    rendering to the proper pose. This results in smoother rendering and less judder. Another feature of layers is that each of them can have different resolution. This allows the
    application to scale down the main eye buffer resolution on low performance systems, but keeping essential information, such as text or a map, in its own layer at a higher
    resolution.

 * <b>Legibility/visual fidelity</b> The resolution for eye-buffers for 3D world rendering can be set to relatively low values especially on low performance systems. It would
    be impossible to render high fidelity content, such as text, in this case. Each layer may have its own resolution and it will be re-sampled only once by the compositor (in contrary
    to the traditional approach with rendering layers via WebGL where the layer's content got re-sampled at least twice: once when rendering into WebGL
    eye-buffer (and losing a lot of details due to limited eye-buffer resolution) and the second time by the compositor).

 * <b>Power consumption / battery life</b> Due to reduced rendering pipeline, the lack of double sampling and no need to update the layer's rendering each frame, the power
    consumption is expected to be improved.

 * <b>Latency</b> Pose sampling for composition layers may occur at the very end of the frame and then certain reprojection techniques could be used to update the layer's pose to
    match it with the most recent HMD pose. This may significantly reduce the effective latency for the layers' rendering and as a result improve overall experience.

ISSUE: how to do hit testing? Should it be done by the UA?

</section>


Terminology {#terminology}
-----------

Application flow {#applicationflow}
----------------

<section class="non-normative">

If an author wants to use GL layers, they have to go through these steps:
 1. For any layer type other than {{XRProjectionLayer}} request support through {{XRPermissionDescriptor/requiredFeatures}} or {{XRPermissionDescriptor/optionalFeatures}} in {{XRSystem/requestSession()}}.
 1. Create an {{XRWebGLBinding}} or {{XRMediaBinding}}.
 1. Create layers with these objects.
 1. Add the layers to {{XRRenderStateInit}} and call {{XRSession/updateRenderState()}}.
 1. During {{XRSession/requestAnimationFrame()}} for webgl layers, draw content each WebGL layer.

</section>

Initialization {#initialization}
==============

If an application wants to create layers other than of type {{XRProjectionLayer}} during a session,
the session MUST be requested with an appropriate [=feature descriptor=]. The string "<dfn for="feature descriptor">layers</dfn>" is introduced
by this module as a new valid [=feature descriptor=] for the WebXR Layers feature.

Layers of type {{XRProjectionLayer}} MUST always be supported, regardless if the [=feature descriptor=] was requested.


<div class="example">
The following code requests layers as an optional feature.

<pre highlight="js">
navigator.xr.requestSession('immersive-vr', {
    optionalFeatures: ['layers']
  }
</pre>
</div>

Layers are only supported for XRSessions created with XRSessionMode of {{XRSessionMode/"immersive-vr"}}
or {{XRSessionMode/"immersive-ar"}}. {{XRSessionMode/"inline"}} sessions MUST not support layers.

The "[=feature descriptor/layers=]" [=feature descriptor=] has a [=feature requirement=] that it cannot be enabled when there is an [=active immersive session=].

NOTE: This means that executing the {{Permissions/request(permissionDesc)}} API with "[=feature descriptor/layers=]" will
not enable layers support for the current active session.

Layer types {#xrlayertypes}
===========

Mono and stereo layers {#monovsstereo}
----------------------
A stereo layer MUST supply an {{XRSubImage}} to render to for each view.

A mono layer MUST supply a single {{XRSubImage}} which is shown to each view.

The [=XR Compositor=] MUST ensure that layers are presented correctly in stereo to the observer.

XRLayerLayout {#xrlayerlayouttype}
-------------
The {{XRLayerLayout}} enum defines the layout of the layer.

<pre class="idl">
enum XRLayerLayout {
  "default",
  "mono",
  "stereo",
  "stereo-left-right",
  "stereo-top-bottom"
};
</pre>

 - A layout of <dfn enum-value for="XRLayerLayout">default</dfn> indicates that the layer can accomodate all the views of session’s [=list of views=].
 - A layout of <dfn enum-value for="XRLayerLayout">mono</dfn> indicates that the layer is mono.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo</dfn> indicates that the layer is stereo.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo-left-right</dfn> indicates that the layer is stereo and divided left to right.
 - A layout of <dfn enum-value for="XRLayerLayout">stereo-top-bottom</dfn> indicates that the layer is stereo and divided top to bottom.

NOTE: If an {{XRCompositionLayer}} is created with a {{XRLayerLayout/"default"}} or {{XRLayerLayout/"stereo"}} {{XRLayerLayout}}, it is highly recommended
that it is allocated with an {{XRTextureType/"texture-array"}} texture type.

Note: The {{XRLayerLayout/"stereo-left-right"}} and {{XRLayerLayout/"stereo-top-bottom"}} layouts are designed to minimize draw
calls for content that is already in stereo (for example stereo videos or images). Experiences that don't require such assets types
should use the {{XRLayerLayout/"default"}} or {{XRLayerLayout/"stereo"}} layout.

XRCompositionLayer {#xrcompositionlayertype}
--------------
XRCompositionLayer defines a set of common attributes and behaviors across certain layer types.

<pre class="idl">
[Exposed=Window] interface XRCompositionLayer : XRLayer {
  readonly attribute XRLayerLayout layout;

  attribute boolean blendTextureSourceAlpha;
  attribute boolean? chromaticAberrationCorrection;
  attribute float? fixedFoveation;
  readonly attribute unsigned long mipLevels;

  readonly attribute boolean needsRedraw;

  undefined destroy();
};
</pre>

The <dfn attribute for="XRCompositionLayer">layout</dfn> attribute returns the layout of the layer.

The <dfn attribute for="XRCompositionLayer">blendTextureSourceAlpha</dfn> attribute enables the layer’s texture alpha channel.

The <dfn attribute for="XRCompositionLayer">chromaticAberrationCorrection</dfn> attribute is a hint for the [=XR Compositor=] to
enable optical chromatic aberration correction for the layer. If the user agent or device does not support this attribute, they
should return <code>null</code> on getting, and setting should be a <code>no-op</code>.

The <dfn attribute for="XRCompositionLayer">fixedFoveation</dfn> attribute controls the amount of foveation used by the
[=XR Compositor=]. If the user agent or device does not support this attribute, they
should return <code>null</code> on getting, and setting should be a <code>no-op</code>.
Setting {{XRCompositionLayer/fixedFoveation}} to a value less than <code>0</code> will set it to <code>0</code> and setting it to
a value higher than <code>1</code> will set it to <code>1</code>. <code>0</code> sets the minimum amount of foveation while
<code>1</code> set the maximum. It is up to the user agent how the [=XR Compositor=] interprets these values.

The <dfn attribute for="XRCompositionLayer">needsRedraw</dfn> attribute signals that the {{XRCompositionLayer}} should be
rerendered in the next [=XR animation frame=]. It MAY be set when [=the underlying resources of a layer are lost=] or
when the [=XR Compositor=] can no longer reproject the layer. Failing to redraw the content in the next [=XR animation frame=]
might cause flickering or other side effects.

The <dfn attribute for="XRCompositionLayer">mipLevels</dfn> attribute returns the depth of the mip chain. This MUST be equal
or smaller than the value requested in {{XRLayerInit/mipLevels}}.

NOTE: some platforms don't support mip levels. Authors should query {{XRCompositionLayer/mipLevels}} to determine if they can
target a certain mip level and not rely on the value they passed in {{XRLayerInit/mipLevels}}.

<div class="algorithm" data-algorithm="redrawLayerAlgo">
When <dfn>the underlying resources of a layer are lost</dfn> for an {{XRCompositionLayer}} |layer|,
the user agent MUST run the following steps:
  1. Set |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. If |layer| is not an {{XRProjectionLayer}}, [=queue a task=] to [=fire an event=] named {{redraw}} on |layer|.

</div>

{{destroy()}} will delete the underlying attachments. If there are no attachments, this function does nothing.

<div class="algorithm" data-algorithm="intialization of a composition layer">

To <dfn>intialize a composition layer</dfn> with a {{XRSession}} |session| and an optional instance of a {{WebGLRenderingContext}}
or a {{WebGL2RenderingContext}} |context|, the user agent MUST run the following steps:
  1. Set [=this=] [=XRCompositionLayer/session=] to |session|.
  1. If |context| is defined, set [=this=] [=XRCompositionLayer/context=] to |context|.
  1. Set [=this=] {{XRCompositionLayer/blendTextureSourceAlpha}} to <code>true</code>.
  1. Initialize [=this=] {{XRCompositionLayer/chromaticAberrationCorrection}} as follows:
    <dl class="switch">
      <dt class="switch">If the user agent supports chromatic aberration correction
      <dd> Set [=this=] {{XRCompositionLayer/chromaticAberrationCorrection}} to <code>true</code> or <code>false</code> depending on the user agent's preference.
      <dt> Otherwise
      <dd> Set [=this=] {{XRCompositionLayer/chromaticAberrationCorrection}} to <code>null</code>.
    </dl>
  1. Initialize [=this=] {{XRCompositionLayer/fixedFoveation}} as follows:
    <dl class="switch">
      <dt class="switch">If the user agent supports fixed foveation
      <dd> Set [=this=] {{XRCompositionLayer/fixedFoveation}} to a value between <code>0</code> and <code>1</code> depending on the user agent's preference.
      <dt> Otherwise
      <dd> Set [=this=] {{XRCompositionLayer/fixedFoveation}} to <code>null</code>.
    </dl>

</div>

<div class="algorithm" data-algorithm="calling destroy on a layer">

When calling {{destroy()}}, the user agent MUST run the following steps:
  1. Set [=this=] [=colorTextures=] array to an empty array.
  1. Set [=this=] [=depthStencilTextures=] array to an empty array.
  1. Destroy the underlying GL attachments.

</div>

Each {{XRCompositionLayer}} has a <dfn for="XRCompositionLayer">context</dfn> object which is an instance
of either null or a {{WebGLRenderingContext}} or a {{WebGL2RenderingContext}} and a <dfn for="XRCompositionLayer">media</dfn>
object which is an instance of null or a {{HTMLVideoElement}}.

Each {{XRCompositionLayer}} has an associated <dfn for="XRCompositionLayer">session</dfn>, which is the
{{XRSession}} it was created with.

<!--
# we might need this at a later stage.

If the {{XRCompositionLayer}} was created by {{XRWebGLBinding}}, it MUST have a <dfn>list of viewports</dfn> which is a
[=/list=] containing one [=WebGL viewport=] for each {{XRView}} the {{XRSession}} currently exposes. The viewports MUST
have a {{XRViewport/width}} and {{XRViewport/height}} greater than <code>0</code> and MUST describe a rectangle that does
not exceed the bounds of the {{XRCompositionLayer}}.
-->

<div class="algorithm" data-algorithm="setting the space on a layer">

When <dfn>setting the space on a layer</dfn> with {{XRSpace}} |space| and {{XRCompositionLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |space| is <code>null</code>, throw {{TypeError}} and abort these steps.
  1. If |space|'s [=XRSpace/session=] is not equal to the |layer|'s [=XRCompositionLayer/session=], throw {{TypeError}} and abort these steps.

</div>

{{XRCompositionLayer}} has an internal boolean <dfn for="XRCompositionLayer">isStatic</dfn> that indicates that the author can only draw
to this layer when {{XRCompositionLayer/needsRedraw}} is <code>true</code>.

NOTE: if [=XRCompositionLayer/isStatic=] is <code>true</code> the author can only draw into the layer once after creation or once after
a redraw event. This allows the UA to only allocate a single GPU buffer.

When a writeable attribute is set on an {{XRCompositionLayer}} or any of its derived classes,
reading that attribute MUST return that value.
At the end of the {{XRSession/requestAnimationFrame()}} callback, the value MUST be sent to
the underlying [=XR Compositor=]. The [=XR Compositor=] MUST apply the value next time it presents
the {{XRFrame}} that was passed to the {{XRSession/requestAnimationFrame()}} callback.

NOTE: this means that the values must be applied when the [=XR Compositor=] redraws the scene using
the new {{XRFrame}}, even if there was no change in the {{XRWebGLSubImage/colorTexture}} associated
with the {{XRCompositionLayer}} or the videoframe associated with a media layer. If the
[=XR Compositor=] redraws the scene with the previous {{XRFrame}}'s state, it must not use the new
values.

XRProjectionLayer {#xrprojectionlayertype}
-----------------
An {{XRProjectionLayer}} is a layer that fills the entire view of the observer.
Projection layers should be refreshed close to the device's native frame rate.

<img alt="representation of a projection layer" src="images/projection-layer.jpg" style="width:50%; border-style: ridge;"/>

<pre class="idl">
[Exposed=Window] interface XRProjectionLayer : XRCompositionLayer {
  readonly attribute unsigned long textureWidth;
  readonly attribute unsigned long textureHeight;
  readonly attribute unsigned long textureArrayLength;

  readonly attribute boolean ignoreDepthValues;
};
</pre>

The <dfn attribute for="XRProjectionLayer">textureWidth</dfn> attribute returns the width in pixels of
the [=colorTextures=] textures of this layer.

The <dfn attribute for="XRProjectionLayer">textureHeight</dfn> attribute returns the height in pixels of
the [=colorTextures=] textures of this layer.

The <dfn attribute for="XRProjectionLayer">textureArrayLength</dfn> attribute returns the number of layers of
the [=colorTextures=] textures of this layer if the {{XRProjectionLayer}} was initialized with a
{{XRProjectionLayerInit/textureType}} of {{"texture-array"}}. Otherwise it will return <code>1</code>.


The <dfn attribute for="XRProjectionLayer">ignoreDepthValues</dfn> attribute, if <code>true</code>, indicates that the
[=XR Compositor=] MUST NOT make use of values in the depth buffer attachment when rendering. When the attribute
is <code>false</code> it indicates that the content of the depth buffer attachment will be used by the
[=XR Compositor=] and is expected to be representative of the scene rendered into the layer.

XRQuadLayer {#xrquadlayertype}
-----------
An {{XRQuadLayer}} renders a layer that takes up a flat rectangular space in the virtual environment.
Only the front of the layer MUST be visible; the back face MUST not be drawn by the [=XR Compositor=].

A XRQuadLayer has no thicknes. It is a two-dimensional object positioned and oriented in 3D space. The position
of a quad refers to the center of the quad.

<img alt="representation of a quad layer" src="images/quad-layer.jpg" style="width:50%; border-style: ridge;"/>

<pre class="idl">
[Exposed=Window] interface XRQuadLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float width;
  attribute float height;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XRQuadLayer">transform</dfn> attributes sets and returns the offset and orientation relative to the
<dfn attribute for="XRQuadLayer">space</dfn> attribute. The {{XRQuadLayer/transform}} and {{XRQuadLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When setting the {{XRQuadLayer/space}}, first run the steps for [=setting the space on a layer=].

The <dfn attribute for="XRQuadLayer">width</dfn> and <dfn attribute for="XRQuadLayer">height</dfn> attributes
set and return the width and height of the layer in meters.

<div class="algorithm" data-algorithm="initQuadLayerAlgo">
When <dfn lt="initialize a quad layer">initializing an {{XRQuadLayer}} |layer| with an {{XRQuadLayerInit}} |init|</dfn>, the user agent MUST run the following steps:
  1. Initialize |layer|'s {{XRQuadLayer/width}} to |init|'s {{XRQuadLayerInit/width}}.
  1. Initialize |layer|'s {{XRQuadLayer/height}} to |init|'s {{XRQuadLayerInit/height}}.
  1. Let |layer|'s {{XRQuadLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XRQuadLayer/transform}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XRQuadLayerInit/transform}} is set
      <dd> Let |layer|'s {{XRQuadLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with {{XRRigidTransform/position}} and {{XRRigidTransform/orientation}} of |init|'s {{XRQuadLayerInit/transform}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XRQuadLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with a {{DOMPointInit}} position of <code>{ x: 0.0, y: 0.0, z: 0.0, w: 1.0 }</code>.
    </dl>
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to |init|'s {{XRLayerInit/isStatic}}

</div>

The <dfn attribute for="XRQuadLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

XRCylinderLayer {#xrcylinderayertype}
---------------
An {{XRCylinderLayer}} renders a layer that takes up a curved rectangular space in the virtual environment.
Only the front of the layer MUST be visible; the back face MUST not be drawn by the [=XR Compositor=].

<img alt="representation of a cylinder layer" src="images/cylinder-layer.png" style="width:50%; border-style: ridge;"/>

A XRCylinderLayer has no thicknes. It is a two-dimensional object positioned and oriented in 3D space. The position
of the cylinder refers to the center of the quad.

<pre class="idl">
[Exposed=Window] interface XRCylinderLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float radius;
  attribute float centralAngle;
  attribute float aspectRatio;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XRCylinderLayer">transform</dfn> attribute sets and returns the offset and orientation relative to the
<dfn attribute for="XRCylinderLayer">space</dfn> attribute. The {{XRCylinderLayer/transform}} and {{XRCylinderLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When setting the {{XRCylinderLayer/space}}, first run the steps for [=setting the space on a layer=].

The <dfn attribute for="XRCylinderLayer">radius</dfn> attribute controls the radius in meters of the cylinder.

The <dfn attribute for="XRCylinderLayer">centralAngle</dfn> attribute controls the angle in radians of the visible section of the cylinder.
It grows symmetrically around the 0 angle.

The <dfn attribute for="XRCylinderLayer">aspectRatio</dfn> attribute controls the ratio of the visible cylinder section.

<img alt="description of the parameters of a cylinder layer"src="images/cylinder_layer_params.png" style="width:80%"/>

<div class="algorithm" data-algorithm="initCylinderLayerAlgo">
When <dfn lt="initialize a cylinder layer">initializing an {{XRCylinderLayer}} |layer| with an {{XRCylinderLayerInit}} |init|</dfn>, the user agent MUST run the following steps:
  1. Initialize |layer|'s {{XRCylinderLayer/radius}} to |init|'s {{XRCylinderLayerInit/radius}}.
  1. Initialize |layer|'s {{XRCylinderLayer/centralAngle}} to |init|'s {{XRCylinderLayerInit/centralAngle}}.
  1. Initialize |layer|'s {{XRCylinderLayer/aspectRatio}} to |init|'s {{XRCylinderLayerInit/aspectRatio}}.
  1. Let |layer|'s {{XRCylinderLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XRCylinderLayer/transform}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XRCylinderLayerInit/transform}} is set
      <dd> Let |layer|'s {{XRCylinderLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with {{XRRigidTransform/position}} and {{XRRigidTransform/orientation}} of |init|'s {{XRCylinderLayerInit/transform}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XRCylinderLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with a {{DOMPointInit}} position of <code>{ x: 0.0, y: 0.0, z: 0.0, w: 1.0 }</code>.
    </dl>
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to |init|'s {{XRLayerInit/isStatic}}

</div>

The <dfn attribute for="XRCylinderLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

XREquirectLayer {#xrequirectlayertype}
---------------
An {{XREquirectLayer}} renders a layer where the [=XR Compositor=] MUST map an equirectangular coded data onto the inside of a sphere.

<img alt="representation of an equirect layer" src="images/equirect-layer.png" style="width:50%; border-style: ridge;"/>

ISSUE: this section needs clarification

<pre class="idl">
[Exposed=Window] interface XREquirectLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute XRRigidTransform transform;

  attribute float radius;
  attribute float centralHorizontalAngle;
  attribute float upperVerticalAngle;
  attribute float lowerVerticalAngle;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XREquirectLayer">transform</dfn> attribute sets and returns the offset and orientation relative to
{{XREquirectLayer/space}}. The {{XREquirectLayer/transform}} attribute and the {{XREquirectLayer/space}}
establish the spatial relationship of the layer within the user’s physical environment.

The <dfn attribute for="XREquirectLayer">radius</dfn> attribute is the non-negative radius in meters of the sphere. Values of <code>zero</code> or <code>infinity</code> are treated as an infinite sphere.

Setting {{XREquirectLayer/radius}} to a value less than <code>0</code> will set it to <code>0</code>.

The <dfn attribute for="XREquirectLayer">centralHorizontalAngle</dfn>, <dfn attribute for="XREquirectLayer">upperVerticalAngle</dfn>
and <dfn attribute for="XREquirectLayer">lowerVerticalAngle</dfn> attributes set and return how the texture is mapped to the sphere.

Setting {{XREquirectLayer/centralHorizontalAngle}} to a value less than 0 will set it to 0 and setting it to
a value higher than 2π will set it to 2π.

Setting {{XREquirectLayer/upperVerticalAngle}} or {{XREquirectLayer/lowerVerticalAngle}} to a value less than -π/2 will set it
to -π/2 and setting it to a value higher than π/2 will set it to π/2.

<img alt="description of the parameters of an equirect layer" src="images/equirect.png" style="width:50%"/>

When assigning an {{XRSpace}} to the {{XREquirectLayer/space}} attribute, first run the following steps.

<div class="algorithm" data-algorithm="setting the space on an equirect layer">

When <var ignore>setting the space on an equirect layer</var> with {{XRSpace}} |space| and {{XREquirectLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{TypeError}} and abort these steps.
  1. Run [=setting the space on a layer=] with |space| and |layer|.

</div>

<div class="algorithm" data-algorithm="initEquirectLayerAlgo">
When <dfn lt="initialize a equirect layer">initializing an {{XREquirectLayer}} |layer| with an {{XREquirectLayerInit}} |init|</dfn>, the user agent MUST run the following steps:
  1. Initialize |layer|'s {{XREquirectLayer/radius}} to |init|'s {{XREquirectLayerInit/radius}}.
  1. Initialize |layer|'s {{XREquirectLayer/centralHorizontalAngle}} to |init|'s {{XREquirectLayerInit/centralHorizontalAngle}}.
  1. Initialize |layer|'s {{XREquirectLayer/upperVerticalAngle}} to |init|'s {{XREquirectLayerInit/upperVerticalAngle}}.
  1. Initialize |layer|'s {{XREquirectLayer/lowerVerticalAngle}} to |init|'s {{XREquirectLayerInit/lowerVerticalAngle}}.
  1. Let |layer|'s {{XREquirectLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s {{XREquirectLayer/transform}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XREquirectLayerInit/transform}} is set
      <dd> Let |layer|'s {{XREquirectLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer| initialized with {{XRRigidTransform/position}} and {{XRRigidTransform/orientation}} of |init|'s {{XREquirectLayerInit/transform}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XREquirectLayer/transform}} be a [=new=] {{XRRigidTransform}} in the [=relevant realm=] of |layer|.
    </dl>
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to |init|'s {{XRLayerInit/isStatic}}

</div>

The <dfn attribute for="XREquirectLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

XRCubeLayer {#xcubelayertype}
-----------
A {{XRCubeLayer}} renders a layer where the [=XR Compositor=] renders directly from a cubemap.

<img alt="representation of a cube layer" src="images/cube-layer.jpg" style="width:50%; border-style: ridge;"/>

ISSUE: this section needs clarification

<pre class="idl">
[Exposed=Window] interface XRCubeLayer : XRCompositionLayer {
  attribute XRSpace space;
  attribute DOMPointReadOnly orientation;

  // Events
  attribute EventHandler onredraw;
};
</pre>

The <dfn attribute for="XRCubeLayer">orientation</dfn> attribute sets and returns the orientation relative to the
<dfn attribute for="XRCubeLayer">space</dfn> attribute. The {{XRCubeLayer/orientation}} and {{XRCubeLayer/space}} attributes
establish the spatial relationship of the layer within the user’s physical environment.
When placing the {{XRCubeLayer}} only the orientation of the {{XRCubeLayer/space}} is considered. The cube layer will always be rendered
with the view point at the center.

When assigning an {{XRSpace}} to the {{XRCubeLayer/space}} attribute, first run the following steps.

<div class="algorithm" data-algorithm="setting the space on a cube layer">

When <var ignore>setting the space on an cube layer</var> with {{XRSpace}} |space| and {{XRCubeLayer}} |layer|, the user agent MUST run the following steps to validate if the |space| is valid:
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{TypeError}} and abort these steps.
  1. Run [=setting the space on a layer=] with |space| and |layer|.

</div>

The <dfn attribute for="XRCubeLayer">onredraw</dfn> attribute is an Event handler IDL attribute for the {{redraw}} event type.

Spaces {#spaces}
======

{{XRProjectionLayer}} and {{XRWebGLLayer}} don't have associated an {{XRSpace}} because they render to the full frame.

{{XRCubeLayer}} and {{XREquirectLayer}} MUST only support {{XRReferenceSpace|XRReferenceSpaces}} that are not of type {{"viewer"}}.

{{XRQuadLayer}} and {{XRCylinderLayer}} MUST support all {{XRSpace}} types.

<section class="non-normative">

Generally, developers should not use of {{"viewer"}} space to stabilize layers, as this will almost always defeat positional or
rotational reprojection and result in a loss in stability of the rendered content relative to the world. The exception being small UI elements
like a gaze cursor or targeting reticle.

Following are some best practices of spaces to use with a layer type:
  - {{XRQuadLayer}} with {{"viewer"}} space: Head-locked constant-size reticle in center of screen.
  - {{XRQuadLayer}} or {{XRCylinderLayer}} in {{"local"}}, {{"unbounded"}} space: springy body-locked UI.
  - {{XRQuadLayer}} or {{XRCylinderLayer}} in {{"local"}}, {{"local-floor"}}, {{"unbounded"}}, {{"bounded-floor"}} or anchor space: world-locked video, placed by the user.
  - {{XREquirectLayer}} or {{XRCubeLayer}} in {{"local"}} space: 360-degree video or skybox.

</section>

Rendering {#rendering}
=========

XRSubImage {#xrsubimagetype}
----------
The {{XRSubImage}} object represents what viewport of the GPU texture to use.

<pre class="idl">
[Exposed=Window] interface XRSubImage {
  [SameObject] readonly attribute XRViewport viewport;
};
</pre>

NOTE: this class is designed to accomodate future extensions

The <dfn attribute for="XRSubImage">viewport</dfn> attribute returns the {{XRViewport}} to use when rendering the sub image.

XRWebGLSubImage {#xrwebglsubimagetype}
---------------
The {{XRWebGLSubImage}} object is used during rendering of the layer.

<pre class="idl">
[Exposed=Window] interface XRWebGLSubImage : XRSubImage {
  [SameObject] readonly attribute WebGLTexture colorTexture;
  [SameObject] readonly attribute WebGLTexture? depthStencilTexture;
  readonly attribute unsigned long? imageIndex;
  readonly attribute unsigned long textureWidth;
  readonly attribute unsigned long textureHeight;
};
</pre>

The <dfn attribute for="XRWebGLSubImage">colorTexture</dfn> attribute returns the color [=opaque texture=] for the {{XRCompositionLayer}}.

The <dfn attribute for="XRWebGLSubImage">depthStencilTexture</dfn> attribute returns the depth/stencil [=opaque texture=] for the {{XRCompositionLayer}}.
If the layer was created without depth/stencil, this attribute returns null.

The <dfn attribute for="XRWebGLSubImage">imageIndex</dfn> attribute returns the offset into the texture array. Valid only for layers
that were requested with {{texture-array}}.

The <dfn attribute for="XRWebGLSubImage">textureWidth</dfn> and <dfn attribute for="XRWebGLSubImage">textureHeight</dfn> attributes
return the width and height in pixels of the GL attachments, respectively.

XRTextureType {#xrtexturetype}
-------------
The {{XRTextureType}} enum defines what type of texture is allocated.

<pre class="idl">
enum XRTextureType {
  "texture",
  "texture-array"
};
</pre>

- A texture type of <dfn enum-value for="XRTextureType">texture</dfn> indicates that the textures of {{XRWebGLSubImage}} MUST be of type {{TEXTURE_2D}}
- A texture type of <dfn enum-value for="XRTextureType">texture-array</dfn> indicates that the textures of {{XRWebGLSubImage}} MUST be of type {{TEXTURE_2D_ARRAY}}

GPU layer and view creation {#gpulayer}
===========================

Overview {#xrgpulayeroverview}
--------
<section class="non-normative">

When a layer is created it is backed by a GPU resource, typically a texture, provided by one of the Web platform's graphics APIs. In order to
specify which API is providing the layer's GPU resources an {{XRWebGLBinding}} for the API in question must be created.
Each graphics API may have unique requirements that must be satisfied before a context can be used in the creation of a layer. For example,
a {{WebGLRenderingContext}} must have its xrCompatible flag set prior to being passed to the constructor of the {{XRWebGLBinding}} instance.

Any interaction between the {{XRSession}} the graphics API, such as allocating or retrieving textures, will go through this {{XRWebGLBinding}} instance, and the exact mechanics
of the interaction will typically be API specific. This allows the rest of the WebXR API to be
graphics API agnostic and more easily adapt to future advances in rendering techniques.

Once an {{XRWebGLBinding}} instance has been acquired, it can be used to create a variety of {{XRCompositionLayer}}. Any layers created by that instance will then be able
to query the associated GPU resources each frame, generally expected to be the native API's texture interface.

The various layer types are created with the create____Layer series of methods on the {{XRWebGLBinding}} instance. Information about the graphics resources required,
such as whether or not to allocate a depth buffer or alpha channel, are passed in at layer creation time and will be immutable for the lifetime of the layer.
The method will return the associated XRCompositionLayer type.

Some layer types may not be supported by the {{XRSession}}. If a layer type isn't supported the method will throw an exception. {{XRProjectionLayer}} MUST be supported by all {{XRSession}}s.
</section>

Opaque textures {#xropaquetextures}
---------------
When using WebXR GPU layers, the {{XRWebGLBinding}} object will return instances of an <dfn>opaque texture</dfn> for the color and depth/stencil attachments.

An [=opaque texture=] functions identically to a standard {{WebGLTexture}} with the following changes:
- An [=opaque texture=] is considered invalid outside of a {{XRSession/requestAnimationFrame()}} callback for its session.
- An [=opaque texture=] is invalid until it is returned by the {{XRWebGLBinding/getSubImage()}} or {{XRWebGLBinding/getViewSubImage()}} calls.
- The [=XR Compositor=] MUST assume that the [=opaque texture=] for the color attachment contains colors with premultiplied alpha.
- At the end of the {{XRSession/requestAnimationFrame()}} callback the texture MUST be unbounded and detached from all {{WebGLShader}} objects.
- An [=opaque texture=] MUST behave as though it was allocated with [=texStorage2D=] or [=texStorage3D=], as appropriate, even when using a WebGL 1.0 context.
- A call to {{deleteTexture}} with an [=opaque texture=] MUST generate an {{INVALID_OPERATION}} error.

The buffers attached to an [=opaque texture=] MUST be cleared to the values in the table below prior to the processing of each [=XR animation frame=].

<table class="tg">
  <thead>
    <tr>
      <th>Buffer</th>
      <th>Clear Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Color</td>
      <td>(0, 0, 0, 0)</td>
    </tr>
    <tr>
      <td>Depth</td>
      <td>1.0</td>
    </tr>
    <tr>
      <td>Stencil</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

If the [=opaque texture=] was created with <code>2</code> or more {{XRLayerInit/mipLevels}},
the author SHOULD populate all the mip levels. The user agent MUST NOT assume that it should create the mip levels.

NOTE: the [=opaque texture|opaque textures=] are allocated when the layer is contructed using the
[=allocate color textures=] and [=allocate depth textures=] algoritms. The side effect of this pre-allocation is that calling
{{XRWebGLBinding/getSubImage()}} and {{XRWebGLBinding/getViewSubImage()}} with the same parameters will always return the same texture objects.

NOTE: Changes to the dimensions or format of the [=opaque texture|opaque textures=] are not allowed. GL commands
may only alter the texel values and texture parameters. Using any of the following
commands with the WebGLTexture will result in an INVALID_OPERATION error
being generated, even if it does not affect the dimensions or format: TexImage*, CompressedTexImage*, CopyTexImage* and TexStorage*.
The <a href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/es_spec_3.0.pdf#nameddest=section-3.8.4">"Immutable-Format Texture Images"</a>
section in the OpenGL ES 3.0 spec defines these limitations in more detail.

XRProjectionLayerInit {#xrprojectionlayerinittype}
---------------------
The {{XRProjectionLayerInit}} dictionary represents a set of configurable values that describe how an {{XRProjectionLayer}}
is initialized.

<pre class="idl">
dictionary XRProjectionLayerInit {
  XRTextureType textureType = "texture";
  GLenum colorFormat = 0x1908; // RGBA
  GLenum depthFormat = 0x1902; // DEPTH_COMPONENT
  double scaleFactor = 1.0;
};
</pre>

The <dfn dict-member for="XRProjectionLayerInit">textureType</dfn> attribute defines the type of texture that the layer will have.

The <dfn dict-member for="XRProjectionLayerInit">colorFormat</dfn> attribute defines the data type of the color texture data.

This is the <dfn>list of color formats for projection layers</dfn> that the [=XR Compositor=] MUST support:

 - {{RGBA}}
 - {{RGB}}
 - {{SRGB_EXT}} for contexts with the '{{EXT_sRGB}}' [=extension=] enabled
 - {{SRGB_ALPHA_EXT}} for contexts with the '{{EXT_sRGB}}' [=extension=] enabled

 For WebGL2 contexts these additional formats are supported:

 - {{RGBA8}}
 - {{RGB8}}
 - {{SRGB8}}
 - {{SRGB8_ALPHA8}}

The <dfn dict-member for="XRProjectionLayerInit">depthFormat</dfn> attribute defines the data type of the depth texture data.
If {{XRProjectionLayerInit/depthFormat}} is <code>0</code> the layer will not provide a depth/stencil texture.

This is the <dfn>list of depth formats for projection layers</dfn> that the [=XR Compositor=] MUST support:

For WebGL1 contexts with the '{{WEBGL_depth_texture}}' [=extension=] enabled or WebGL2 contexts:

 - {{DEPTH_COMPONENT}}
 - {{DEPTH_STENCIL}}

For WebGL2 contexts these additional formats are supported:

 - {{DEPTH_COMPONENT24}}
 - {{DEPTH24_STENCIL8}}

The <dfn dict-member for="XRProjectionLayerInit">scaleFactor</dfn> attribute defines the value that the |session|'s
[=recommended WebGL framebuffer resolution=] MUST be multiplied by determining the resolution of the layer's attachments.

NOTE: the {{XRProjectionLayerInit}} dictionary does not have support to configure {{XRLayerInit/mipLevels}} like
{{XRLayerInit}}. If a user agent wants to support mipmapping on projection layers, it is free to allocate the texture with mips.
In that case the user agent (and not the author) is responsible for generating all the mip levels.

XRLayerInit {#xrlayerinittype}
---------------------
The {{XRLayerInit}} dictionary represents a set of common configurable values for {{XRQuadLayer}}, {{XRCylinderLayer}},
{{XREquirectLayer}} and {{XRCubeLayer}} .

<pre class="idl">
dictionary XRLayerInit {
  required XRSpace space;
  GLenum colorFormat = 0x1908; // RGBA
  GLenum? depthFormat;
  unsigned long mipLevels = 1;
  required unsigned long viewPixelWidth;
  required unsigned long viewPixelHeight;
  XRLayerLayout layout = "mono";
  boolean isStatic = false;
};
</pre>

The <dfn dict-member for="XRLayerInit">space</dfn> attribute defines the spatial relationship with the user’s physical environment.

The <dfn dict-member for="XRLayerInit">colorFormat</dfn> attribute defines the data type of the color texture data.

This is the <dfn>list of color formats for non-projection layers</dfn> that the [=XR Compositor=] MUST support:
 - {{RGBA}}
 - {{RGB}}
 - {{SRGB_EXT}} for contexts with the '{{EXT_sRGB}}' [=extension=] enabled
 - {{SRGB_ALPHA_EXT}} for contexts with the '{{EXT_sRGB}}' [=extension=] enabled

For WebGL2 contexts these additional formats are supported:
 - {{RGBA8}}
 - {{RGB8}}
 - {{SRGB8}}
 - {{SRGB8_ALPHA8}}

For contexts with the '{{WEBGL_compressed_texture_etc}}' [=extension=] enabled these additional formats are supported:
 - {{COMPRESSED_RGB8_ETC2}}
 - {{COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2}}
 - {{COMPRESSED_RGBA8_ETC2_EAC}}
 - {{COMPRESSED_SRGB8_ETC2}}
 - {{COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2}}
 - {{COMPRESSED_SRGB8_ALPHA8_ETC2_EAC}}

For contexts with the '{{WEBGL_compressed_texture_astc}}' [=extension=] enabled all the formats of that [=extension=] are supported.

The <dfn dict-member for="XRLayerInit">depthFormat</dfn> attribute defines the data type of the depth texture data.
If {{XRLayerInit/depthFormat}} is not supplied, the layer will not provide a depth/stencil texture.

This is the <dfn>list of depth formats for non-projection layers</dfn> that the [=XR Compositor=] MUST support:

For WebGL1 contexts with the '{{WEBGL_depth_texture}}' [=extension=] enabled or WebGL2 contexts:

 - {{DEPTH_COMPONENT}}
 - {{DEPTH_STENCIL}}

For WebGL2 contexts these additional formats are supported:

 - {{DEPTH_COMPONENT24}}
 - {{DEPTH24_STENCIL8}}

The <dfn dict-member for="XRLayerInit">mipLevels</dfn> attribute defines the desired number of mip levels in the color and texture data.
If the user agent can't create the requested number, it can create less. Authors MUST query {{XRCompositionLayer/mipLevels}} to determine
the actual number of mip levels.

The <dfn dict-member for="XRLayerInit">viewPixelWidth</dfn> and <dfn dict-member for="XRLayerInit">viewPixelHeight</dfn> attributes define
the rectangular dimensions of the {{XRCompositionLayer}}.

The <dfn dict-member for="XRLayerInit">layout</dfn> attribute defines the layout of the layer.

XRQuadLayerInit {#xrquadlayerinit}
-------------------

The {{XRQuadLayerInit}} dictionary represents a set of configurable values that describe how an {{XRQuadLayer}} is initialized.

<pre class="idl">
dictionary XRQuadLayerInit : XRLayerInit {
  XRTextureType textureType = "texture";
  XRRigidTransform? transform;
  float width = 1.0;
  float height = 1.0;
};
</pre>

XRCylinderLayerInit {#xrcylinderlayerinit}
-------------------

The {{XRCylinderLayerInit}} dictionary represents a set of configurable values that describe how an {{XRCylinderLayer}} is initialized.

<pre class="idl">
dictionary XRCylinderLayerInit : XRLayerInit {
  XRTextureType textureType = "texture";
  XRRigidTransform? transform;
  float radius = 2.0;
  float centralAngle = 0.78539;
  float aspectRatio = 2.0;
};
</pre>

The default value of {{XRCylinderLayerInit/centralAngle}} is π / 4.

XREquirectLayerInit {#xrequirectlayerinit}
-------------------

The {{XREquirectLayerInit}} dictionary represents a set of configurable values that describe how an {{XREquirectLayer}} is initialized.

<pre class="idl">
dictionary XREquirectLayerInit : XRLayerInit {
  XRTextureType textureType = "texture";
  XRRigidTransform? transform;
  float radius = 0;
  float centralHorizontalAngle = 6.28318;
  float upperVerticalAngle = 1.570795;
  float lowerVerticalAngle = -1.570795;
};
</pre>

The default value of {{XREquirectLayerInit/centralHorizontalAngle}} is 2π.
The default value of {{XREquirectLayerInit/upperVerticalAngle}} is π/2.
The default value of {{XREquirectLayerInit/lowerVerticalAngle}} is -π/2.

XRCubeLayerInit {#xrcubelayerinit}
-------------------

The {{XRCubeLayerInit}} dictionary represents a set of configurable values that describe how an {{XRCubeLayer}} is initialized.

<pre class="idl">
dictionary XRCubeLayerInit : XRLayerInit {
  DOMPointReadOnly? orientation;
};
</pre>

XRWebGLBinding {#XRWebGLBindingtype}
-------------------
The {{XRWebGLBinding}} object is used to create layers that have a GPU backend.

<pre class="idl">
[Exposed=Window] interface XRWebGLBinding {
  constructor(XRSession session, XRWebGLRenderingContext context);

  readonly attribute double nativeProjectionScaleFactor;

  XRProjectionLayer createProjectionLayer(optional XRProjectionLayerInit init);
  XRQuadLayer createQuadLayer(optional XRQuadLayerInit init);
  XRCylinderLayer createCylinderLayer(optional XRCylinderLayerInit init);
  XREquirectLayer createEquirectLayer(optional XREquirectLayerInit init);
  XRCubeLayer createCubeLayer(optional XRCubeLayerInit init);

  XRWebGLSubImage getSubImage(XRCompositionLayer layer, XRFrame frame, optional XREye eye = "none");
  XRWebGLSubImage getViewSubImage(XRProjectionLayer layer, XRView view);
};
</pre>

ISSUE: the init dictionaries shouldn't be optional. This is bikeshed issue 1566.

Each {{XRWebGLBinding}} has a <dfn dfn-for="XRWebGLBinding">context</dfn> object of type {{XRWebGLRenderingContext}} which is an instance
of either a {{WebGLRenderingContext}} or a {{WebGL2RenderingContext}}.

Each {{XRWebGLBinding}} has an associated <dfn dfn-for="XRWebGLBinding">session</dfn>, which is the
{{XRSession}} it was created with.

NOTE: It is possible to create more than one {{XRWebGLBinding}}. Any layer created with an instance of {{XRWebGLBinding}} can
be used with another instance of {{XRWebGLBinding}} as long as both were created with the same [=XRWebGLBinding/session=] and the same
[=XRWebGLBinding/context=]. The lifetime of layers or instances of {{XRWebGLSubImage}} is not tied to the lifetime of the {{XRWebGLBinding}} that created them.

Each {{XRCompositionLayer}} created through {{XRWebGLBinding}} has an internal <dfn>colorTextures</dfn> array which is an |array| of {{WebGLTexture|WebGLTextures}} for color textures and
an internal <dfn>depthStencilTextures</dfn> which is an |array| of [=opaque texture|opaque textures=]</dfn> for depth/stencil textures.

Each {{XRProjectionLayer}} created through {{XRWebGLBinding}} has an internal <dfn for="XRProjectionLayer">colorTextures for secondary views</dfn>
array which is an |array| of [=opaque texture|opaque textures=] for color textures and an internal <dfn for="XRProjectionLayer">depthStencilTextures for secondary views</dfn>
array which is an |array| of [=opaque texture|opaque textures=]</dfn> for depth/stencil textures that are used to render the [=secondary view|secondary views=].

<div class="algorithm" data-algorithm="construct-webgl-layer">

The <dfn constructor for="XRWebGLBinding">XRWebGLBinding(|session|, |context|)</dfn> constructor
MUST perform the following steps when invoked:

  1. Let |binding| be a [=new=] {{XRWebGLBinding}} in the [=relevant realm=] of |session|.
  1. If |session|'s [=ended=] value is <code>true</code>, throw an {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw an {{InvalidStateError}} and abort these steps.
  1. If |session| is not an [=immersive session=], throw an {{InvalidStateError}} and abort these steps.
  1. If |context|'s [=XR compatible=] boolean is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |binding|'s [=XRWebGLBinding/context=] to |context|.
  1. Initialize |binding|'s [=XRWebGLBinding/session=] to |session|.
  1. Return |binding|.

</div>

The {{nativeProjectionScaleFactor}} function returns the value that the |session|'s [=recommended WebGL framebuffer resolution=]
MUST be multiplied by to yield the |session|'s [=native WebGL framebuffer resolution=].

ISSUE: special case UA behavior if the size causes the layout to change (ie if the requested width exceeds a limit with {{XRLayerLayout/"stereo-left-right"}})

<div class="algorithm" data-algorithm="determine the layout attribute">

To <dfn>determine the layout attribute</dfn> using an {{XRTextureType}} |textureType|, an {{XRWebGLRenderingContext}} |context| and an {{XRLayerLayout}} |layout|, the user agent MUST run the following steps:
  1. If |context| is not an {{WebGL2RenderingContext}} and |textureType| is {{"texture-array"}}, throw {{TypeError}} and abort these steps.
  1. If |textureType| is {{"texture-array"}} and not all of the session’s [=view|views=] in the [=list of views=] have the same [=recommended WebGL texture resolution=], throw a {{NotSupportedError}} and abort these steps.
  1. If |layout| is {{XRLayerLayout/"mono"}}, return |layout| and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}}, run the following steps:
    1. If the size of [=list of views=] is <code>1</code>, return {{XRLayerLayout/"mono"}} and abort these steps.
    1. If |textureType| is {{"texture-array"}}, return |layout| and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}} or {{XRLayerLayout/"stereo"}}, run the following steps:
    1. If the user agent prefers {{XRLayerLayout/"stereo-left-right"}} layout, return {{XRLayerLayout/"stereo-left-right"}} and abort these steps.
    1. If the user agent prefers {{XRLayerLayout/"stereo-top-bottom"}} layout, return {{XRLayerLayout/"stereo-top-bottom"}} and abort these steps.
  1. return |layout|.

</div>

<div class="algorithm" data-algorithm="determine the maximum scalefactor">

To <dfn>determine the maximum scalefactor</dfn> using an {{XRSession}} |session|, an {{XRWebGLRenderingContext}} |context| and an {{XRLayerLayout}} |layout|, the user agent MUST run the following steps:
  1. Let |largest width| be the largest width of the [=recommended WebGL texture resolution=] from the |session|'s [=list of views=] excluding the [=secondary view|secondary views=].
  1. Let |largest height| be the largest height of the [=recommended WebGL texture resolution=] from the |session|'s [=list of views=] excluding the [=secondary view|secondary views=].
  1. If |layout| is {{XRLayerLayout/"stereo-left-right"}} layout, multiply |largest width| by <code>2</code>.
  1. If |layout| is {{XRLayerLayout/"stereo-top-bottom"}} layout, multiply |largest height| by <code>2</code>.
  1. Let |largest view dimension| be the largest of |largest width| or |largest height|.
  1. Let |largest texture dimension| be the largest dimension of a {{WebGLTexture}} created by |context|.
  1. return |largest texture dimension| divided by |largest view dimension|.

</div>

<div class="algorithm" data-algorithm="allocate color textures for projection layers">

To <dfn>allocate color textures for projection layers</dfn> using an {{XRProjectionLayer}} |layer|, an {{XRTextureType}} |textureType|, a {{GLenum}} |textureFormat| and a float |scaleFactor|, the user agent MUST run the following steps:
  1. Let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. Let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. Let |session| be |layer|'s [=XRCompositionLayer/session=].
  1. Let |numViews| be the number of the |session|'s [=list of views=] excluding the [=secondary view|secondary views=].
  1. Let |view| be the first entry in the |session|'s [=list of views=] that is not a [=secondary view|secondary views=].
  1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. If |textureFormat| is not in the [=list of color formats for projection layers=], throw a {{NotSupportedError}} and abort these steps.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}} or {{XRLayerLayout/"default"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> If the session’s [=view|views=] in the [=list of views=] don't all have the same [=recommended WebGL texture resolution=] excluding the [=secondary view|secondary views=], throw a {{NotSupportedError}} and abort these steps.
          <dd> Initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with |numViews| layers using |context|, |textureFormat|, |width| and |height|.
          <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> For each |view| in the |session|'s [=list of views=]:
            1. If |view| is a [=secondary view=], continue.
            1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
            1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
            1. let |texture| be a [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context|, |textureFormat|, |width| and |height|.
            1. Append |texture| to |array|.
          <dd> Return |array| and abort these steps.
        </dl>
  1. If the session’s [=view|views=] in the [=list of views=] don't all have the same [=recommended WebGL texture resolution=] excluding the [=secondary view|secondary views=], throw a {{NotSupportedError}} and abort these steps.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 [=new=] instance of [=opaque texture=] in the [=relevant realm=] of |context| created as a |textureType| texture using |context| , |textureFormat|, |numViews| multiplied by |width| and |height|.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 [=new=] instance of [=opaque texture=] in the [=relevant realm=] of |context| created as a |textureType| texture using |context| , |textureFormat|, |width| and |numViews| multiplied by |height|.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="allocate depth textures for projection layers">

To <dfn>allocate depth textures for projection layers</dfn> using an {{XRProjectionLayer}} |layer|, an {{XRTextureType}} |textureType|, a {{GLenum}} |textureFormat| and a float |scaleFactor|, the user agent MUST run the following steps:
  1. let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. let |session| be |layer|'s [=XRCompositionLayer/session=].
  1. If |textureFormat| is <code>0</code>, return |array| and abort these steps.
  1. If |textureFormat| is not in the [=list of depth formats for projection layers=], throw a {{NotSupportedError}} and abort these steps.
  1. let |numViews| be the number of the |session|'s [=list of views=] excluding the [=secondary view|secondary views=].
  1. Let |view| be the first entry in the |session|'s [=list of views=] that is not a [=secondary view=].
  1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}} or {{XRLayerLayout/"default"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with |numViews| layers using |context|, |textureFormat|, |stencil|, |width| and |height|.
          <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> For each |view| in the |session|'s [=list of views=]:
            1. If |view| is a [=secondary view=], continue.
            1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
            1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
            1. let |texture| be a [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context|, |textureFormat|, |stencil|, |width| and |height|.
            1. Append |texture| to |array|.
          <dd> Return |array| and abort these steps.
        </dl>
  1. If the session’s [=view|views=] in the [=list of views=] don't all have the same [=recommended WebGL texture resolution=] excluding the [=secondary view|secondary views=], throw a {{NotSupportedError}} and abort these steps.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a |textureType| texture using |context|, |textureFormat|, |stencil|, |numViews| multiplied by |width| and |height|.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a |textureType| texture using |context|, |textureFormat|, |stencil|, |width| and |numViews| multiplied by |height|.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="allocate color textures for the secondary views">

To <dfn>allocate the color textures for the secondary views</dfn> using an {{XRProjectionLayer}} |layer|, an {{XRTextureType}} |textureType|, a {{GLenum}} |textureFormat| and a float |scaleFactor|, the user agent MUST run the following steps:
  1. Let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. Let |session| be |layer|'s [=XRCompositionLayer/session=].
  1. Let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. If |textureFormat| is not in the [=list of color formats for projection layers=], throw a {{NotSupportedError}} and abort these steps.
  1. For each |view| in the |session|'s [=list of views=]:
    1. If |view| is not a [=secondary view=], continue.
    1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
    1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
    1. Initialize |texture| as follows:
         <dl class="switch">
          <dt> If |textureType| is {{"texture-array"}}:
            <dd> Let |texture| be a [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with |context|, |textureFormat|, |width| and |height|.
          <dt> Otherwise
            <dd> Let |texture| be a [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context|, |textureFormat|, |width| and |height|.
         </dl>
    1. Append |texture| to |array|.
  1. Return |array| and abort these steps.

</div>

<div class="algorithm" data-algorithm="allocate depth textures for the secondary views">

To <dfn>allocate the depth textures for the secondary views</dfn> using an {{XRProjectionLayer}} |layer|, an {{XRTextureType}} |textureType|, a {{GLenum}} |textureFormat| and a float |scaleFactor|, the user agent MUST run the following steps:
  1. Let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. Let |session| be |layer|'s [=XRCompositionLayer/session=].
  1. If |textureFormat| is <code>0</code>, return |array| and abort these steps.
  1. If |textureFormat| is not in the [=list of depth formats for projection layers=], throw a {{NotSupportedError}} and abort these steps.
  1. Let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. For each |view| in the |session|'s [=list of views=]:
    1. If |view| is not a [=secondary view=], continue.
    1. Let |width| be the width of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
    1. Let |height| be the height of |view|'s [=recommended WebGL texture resolution=] multiplied by |scaleFactor|.
    1. Initialize |texture| as follows:
         <dl class="switch">
          <dt> If |textureType| is {{"texture-array"}}:
            <dd> Let |texture| be a [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with |context|, |textureFormat|, |stencil|, |width| and |height|.
          <dt> Otherwise
            <dd> Let |texture| be a [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context|, |textureFormat|, |stencil|, |width| and |height|.
         </dl>
    1. Append |texture| to |array|.
  1. Return |array| and abort these steps.

</div>

ISSUE: the scaleFactor needs to be recalculated for the secondary views.

<div class="algorithm" data-algorithm="allocate color textures">

To <dfn>allocate color textures</dfn> using an {{XRCompositionLayer}} |layer|, an {{XRTextureType}} |textureType| and an {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. If |init|'s {{XRLayerInit/colorFormat}} is not in the [=list of color formats for non-projection layers=], throw a {{NotSupportedError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/mipLevels}} is smaller than <code>1</code>, throw a {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/mipLevels}} is larger than <code>1</code> and {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} are not powers of <code>2</code>, throw a {{InvalidStateError}} and abort these steps
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of this |context| created as a {{TEXTURE_2D_ARRAY}} texture with 1 internal texture using |context| and |init|'s {{XRLayerInit/colorFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dt> Otherwise
          <dd> Initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/colorFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dl>
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"stereo"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with 2 layers using |context| and |init|'s {{XRLayerInit/colorFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
          <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> Initialize |array| with 2 [=new=] instances of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/colorFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
          <dd> Return |array| and abort these steps.
        </dl>
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a |textureType| texture using |context| and |init|'s {{XRLayerInit/colorFormat}}, {{XRLayerInit/mipLevels}}, double of {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a |textureType| texture using |context| and |init|'s {{XRLayerInit/colorFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and double of {{XRLayerInit/viewPixelHeight}} values.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="allocate depth textures">

To <dfn>allocate depth textures</dfn> using an {{XRCompositionLayer}} |layer|, an {{XRTextureType}} |textureType| and an {{XRLayerInit}} |init|, the user agent MUST run the following steps:
  1. let |array| be a [=new=] array in the [=relevant realm=] of |context|.
  1. let |context| be |layer|'s [=XRCompositionLayer/context=].
  1. If |init|'s {{XRLayerInit/depthFormat}} is not set, return |array| and abort these steps.
  1. If |init|'s {{XRLayerInit/depthFormat}} is not in the [=list of depth formats for non-projection layers=], throw a {{NotSupportedError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/mipLevels}} is smaller than <code>1</code>, throw a {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/mipLevels}} is larger than <code>1</code> and {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} are not powers of <code>2</code>, throw a {{InvalidStateError}} and abort these steps.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
          <dd> Initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with 1 internal texture using |context| and |init|'s {{XRLayerInit/depthFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dt> Otherwise
          <dd> Initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context| and |init|'s  {{XRLayerInit/depthFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        </dl>
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"stereo"}}:
        <dl class="switch">
        <dt> If |textureType| is {{"texture-array"}}:
         <dd> Initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D_ARRAY}} texture with 2 layers using |context| and |init|'s {{XRLayerInit/depthFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dd> Return |array| and abort these steps.
        <dt> Otherwise
          <dd> Initialize |array| with 2 [=new=] instances of an [=opaque texture=] in the [=relevant realm=] of |context| created as a {{TEXTURE_2D}} texture with |context| and |init|'s {{XRLayerInit/depthFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
        <dd> Return |array| and abort these steps.
        </dl>
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-left-right}}, initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a |textureType| texture using |context| and |init|'s {{XRLayerInit/depthFormat}}, {{XRLayerInit/mipLevels}}, double of {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
  1. If |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/stereo-top-bottom}}, initialize |array| with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of |context| created as a |textureType| texture using |context| and |init|'s {{XRLayerInit/depthFormat}}, {{XRLayerInit/mipLevels}}, {{XRLayerInit/viewPixelWidth}} and double of {{XRLayerInit/viewPixelHeight}} values.
  1. return |array|.

</div>

<div class="algorithm" data-algorithm="createProjectionLayerAlgo">
The <dfn method for="XRWebGLBinding">createProjectionLayer(optional XRProjectionLayerInit |init|)</dfn> method creates a new {{XRProjectionLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. Let |layer| be a [=new=] {{XRProjectionLayer}} in the [=relevant realm=] of [=this=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to <code>false</code>.
  1. Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} as follows:
      <dl class="switch">
        <dt> If |init|'s {{XRProjectionLayerInit/depthFormat}} is <code>false</code> and the [=XR Compositor=] will make use of depth values
          <dd> Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} to <code>false</code>
        <dt> Otherwise
          <dd> Initialize |layer|'s {{XRProjectionLayer/ignoreDepthValues}} to <code>true</code>
      </dl>
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |init|'s {{XRProjectionLayerInit/textureType}}, |context| and {{XRLayerLayout/"default"}}.
  1. Let |maximum scalefactor| be the result of [=determine the maximum scalefactor|determining the maximum scalefactor=] with |session|, |context| and |layout|.
  1. If {{XRProjectionLayerInit/scaleFactor}} is larger than |maximum scalefactor|, set {{XRProjectionLayerInit/scaleFactor}} to |maximum scalefactor|.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures for projection layers|allocating color textures for projection layers=] with |layer|, |init|'s {{XRProjectionLayerInit/textureType}}, |init|'s {{XRProjectionLayerInit/colorFormat}} and |init|'s {{XRProjectionLayerInit/scaleFactor}}.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures for projection layers|allocating depth textures for projection layers=] with |layer|, |init|'s {{XRProjectionLayerInit/textureType}}, |init|'s {{XRProjectionLayerInit/depthFormat}} and |init|'s {{XRProjectionLayerInit/scaleFactor}}.
  1. Initialize the [=XRProjectionLayer/colortextures for secondary views=] as follows:
      <dl class="switch">
        <dt> If the |session| was created with "[=secondary view/secondary-views=]" enabled
          <dd> Let [=XRProjectionLayer/colortextures for secondary views=] be the result of [=allocate the color textures for the secondary views=] with |layer|, |init|'s {{XRProjectionLayerInit/textureType}}, |init|'s {{XRProjectionLayerInit/colorFormat}} and |init|'s {{XRProjectionLayerInit/scaleFactor}}.
        <dt> Otherwise
          <dd> Let [=XRProjectionLayer/colortextures for secondary views=] be <code>null</code>.
      </dl>
  1. Initialize the [=XRProjectionLayer/depthstenciltextures for secondary views=] as follows:
      <dl class="switch">
        <dt> If the |session| was created with "[=secondary view/secondary-views=]" enabled
          <dd> Let [=XRProjectionLayer/depthstenciltextures for secondary views=] be the result of [=allocate the depth textures for the secondary views=] with |layer|, |init|'s {{XRProjectionLayerInit/textureType}}, |init|'s {{XRProjectionLayerInit/depthFormat}} and |init|'s {{XRProjectionLayerInit/scaleFactor}}.
        <dt> Otherwise
          <dd> Let [=XRProjectionLayer/depthstenciltextures for secondary views=] be <code>null</code>.
      </dl>
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. Return |layer|.

</div>

<div class="algorithm" data-algorithm="createQuadLayerAlgo">
The <dfn method for="XRWebGLBinding">createQuadLayer(XRQuadLayerInit |init|)</dfn> method creates a new {{XRQuadLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw a {{NotSupportedError}} and abort these steps.
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRQuadLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Run [=initialize a quad layer=] with |layer| and |init|.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |init|'s {{XRQuadLayerInit/textureType}}, |context| and |init|'s {{XRLayerInit/layout}}.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layer|, |init|'s {{XRQuadLayerInit/textureType}} and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layer|, |init|'s {{XRQuadLayerInit/textureType}} and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createCylinderLayerAlgo">
The <dfn method for="XRWebGLBinding">createCylinderLayer(XRCylinderLayerInit |init|)</dfn> method creates a new {{XRCylinderLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw a {{NotSupportedError}} and abort these steps.
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRCylinderLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Run [=initialize a cylinder layer=] with |layer| and |init|.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |init|'s {{XRCylinderLayerInit/textureType}}, |context| and |init|'s {{XRLayerInit/layout}}.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layer|, |init|'s {{XRCylinderLayerInit/textureType}} and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layer|, |init|'s {{XRCylinderLayerInit/textureType}} and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createEquirectLayerAlgo">
The <dfn method for="XRWebGLBinding">createEquirectLayer(XREquirectLayerLayerInit |init|)</dfn> method creates a new {{XREquirectLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw a {{NotSupportedError}} and abort these steps.
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |layout| is {{XRLayerLayout/"default"}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XREquirectLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Run [=initialize a equirect layer=] with |layer| and |init|.
  1. let |layout| be the result of [=determine the layout attribute|determining the layout attribute=] with |init|'s {{XRCylinderLayerInit/textureType}}, |context| and |init|'s {{XRLayerInit/layout}}.
  1. Initialize |layer|'s {{XRCompositionLayer/layout}} to |layout|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. let |layer|'s [=colorTextures=] be the result of [=allocate color textures|allocating color textures=] with |layer|, |init|'s {{XRCylinderLayerInit/textureType}} and |init|.
  1. let |layer|'s [=depthStencilTextures=] be the result of [=allocate depth textures|allocating depth textures=] with |layer|, |init|'s {{XRCylinderLayerInit/textureType}} and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createCubeLayerAlgo">
The <dfn method for="XRWebGLBinding">createCubeLayer(XRCubeLayerInit |init|)</dfn> method creates a new {{XRCubeLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw a {{NotSupportedError}} and abort these steps.
  1. Let |context| be [=this=] [=XRWebGLBinding/context=].
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is not a {{WebGL2RenderingContext}} context, throw {{InvalidStateError}} and abort these steps.
  1. If |context| is lost, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRCubeLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session| and |context|.
  1. Let |layer|'s {{XRCubeLayer/space}} be the |init|'s {{XRLayerInit/space}}.
  1. Initialize |layer|'s [=XRCompositionLayer/isStatic=] to |init|'s {{XRLayerInit/isStatic}}
  1. Initialize |layer|'s {{XRCubeLayer/orientation}} as follows:
    <dl class="switch">
      <dt class="switch">If |init|'s {{XRCubeLayerInit/orientation}} is set
      <dd> Let |layer|'s {{XRCubeLayer/orientation}} be the result of running {{DOMPointReadOnly/fromPoint}} with |init|'s {{XRCubeLayerInit/orientation}}.
      <dt> Otherwise
      <dd> Let |layer|'s {{XRCubeLayer/orientation}} be a [=new=] {{DOMPointReadOnly}} in the [=relevant realm=] of [=this=].
    </dl>
  1. let |layout| be |init|'s {{XRLayerInit/layout}}.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>true</code>.
  1. If |layout| is {{XRLayerLayout/"default"}} or {{XRLayerLayout/"stereo-left-right"}} or {{XRLayerLayout/"stereo-top-bottom"}}, throw {{TypeError}} and abort these steps.
  1. Let |layer|'s [=colorTextures=] be a [=new=] array in the [=relevant realm=] of this {{XRCubeLayer}}.
  1. Initialize |layer|'s [=colorTextures=] as follows, based on the value of |layout|:
    <dl class="switch">
      <dt> {{XRLayerLayout/"mono"}}:
        <dd> Initialize [=colorTextures=] with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of this {{XRCubeLayer}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/colorFormat}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
      <dt> Otherwise
        <dd> Initialize [=colorTextures=] with 2 [=new=] instances of an [=opaque texture=] in the [=relevant realm=] of this {{XRCubeLayer}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/colorFormat}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
    </dl>
  1. Let |layer|'s [=depthStencilTextures=] be a [=new=] array in the [=relevant realm=] of this {{XRCubeLayer}}.
  1. If |init|'s {{XRLayerInit/depthFormat}} is set, initialize |layer|'s [=depthStencilTextures=] as follows:
    <dl class="switch">
      <dt> If |context| is not a {{WebGL2RenderingContext}} and the {{WEBGL_depth_texture}} [=extension=] is not enabled in |context|.
        <dd> Throw {{TypeError}} and abort these steps.
      <dt> Else if |layout| is {{XRLayerLayout/"mono"}}:
        <dd> Initialize [=depthStencilTextures=] with 1 [=new=] instance of an [=opaque texture=] in the [=relevant realm=] of this {{XRCubeLayer}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/depthFormat}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
      <dt> Otherwise
        <dd> Initialize [=depthStencilTextures=] with 2 [=new=] instances of an [=opaque texture=] in the [=relevant realm=] of this {{XRCubeLayer}} created as a {{TEXTURE_CUBE_MAP}} texture with |context| and |init|'s {{XRLayerInit/depthFormat}}, {{XRLayerInit/viewPixelWidth}} and {{XRLayerInit/viewPixelHeight}} values.
    </dl>
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

ISSUE: Define how cubemap sizes are determined.

ISSUE: How should space be handled. Can you walk to the edge of a cubemap?

ISSUE: determine the initial state of {{XRCubeLayer/orientation}}.

<div class="algorithm" data-algorithm="validate the state of the XRWebGLSubImage creation function">

To <dfn>validate the state of the XRWebGLSubImage creation function</dfn> of an {{XRWebGLBinding}} |binding| with parameters of {{XRCompositionLayer}} |layer| and {{XRFrame}} |frame|, the user agent MUST run the following steps:
  1. If |frame|'s {{XRFrame/session}} is not equal to |layer|'s [=XRCompositionLayer/session=], return <code>false</code> and abort these steps.
  1. If |frame|'s [=XRFrame/active=] boolean is <code>false</code>, return <code>false</code> and abort these steps.
  1. If |frame|'s [=XRFrame/animationFrame=] boolean is <code>false</code>, return <code>false</code> and abort these steps.
  1. If |binding|'s [=XRWebGLBinding/session=] is not equal to |layer|'s [=XRCompositionLayer/session=], return <code>false</code> and abort these steps.
  1. If |binding|'s [=XRWebGLBinding/context=] is not equal to |layer|'s [=XRCompositionLayer/context=], return <code>false</code> and abort these steps.
  1. If the |layer|'s [=colorTextures=] array is empty or missing, return <code>false</code> and abort these steps.
  1. If the |layer|'s [=XRCompositionLayer/isStatic=] is <code>true</code> and |layer|'s {{XRCompositionLayer/needsRedraw}} is <code>false</code>, return <code>false</code> and abort these steps.
  1. return <code>true</code>.

</div>

<div class="algorithm" data-algorithm="initialize the viewport">

To <dfn>initialize the viewport</dfn> of an {{XRViewport}} |viewport| with a [=opaque texture=] |texture|, a {{XRLayerLayout}}
|layout|, an integer |offset| and a integer |num|, the user agent MUST run the following steps:
  1. Set |viewport|'s {{XRViewport/x}} to <code>0</code>.
  1. Set |viewport|'s {{XRViewport/y}} to <code>0</code>.
  1. Set |viewport|'s {{XRViewport/width}} to the pixel width of |texture|.
  1. Set |viewport|'s {{XRViewport/height}} to the pixelh eight of |texture|.
  1. Update |viewport| as follows:
    <dl class="switch">
      <dt class="switch">If |layout| is {{XRLayerLayout/"stereo-left-right"}}:
        <dd> Set |viewport|'s {{XRViewport/x}} to the pixel width of |texture| multiplied by |offset| and divided by |num|.
        <dd> Set |viewport|'s {{XRViewport/width}} to half the pixel width of |subimage|'s |texture| divided by |num|.
      <dt class="switch">Else if |layout| is {{XRLayerLayout/"stereo-top-bottom"}}:
        <dd> Set |viewport|'s {{XRViewport/y}} to the pixel height of |texture| multiplied by |offset| and divided by |num|.
        <dd> Set |viewport|'s {{XRViewport/height}} to the pixel height of |subimage|'s |texture| divided by |num|.
    </dl>

</div>

<div class="algorithm" data-algorithm="getSubImageAlgo">
The <dfn method for="XRWebGLBinding">getSubImage(XRCompositionLayer |layer|, XRFrame |frame|, optional XREye |eye| = {{XREye/"none"}})</dfn> method creates a new {{XRWebGLSubImage}}.

When this method is invoked on an {{XRWebGLBinding}} |binding|, it MUST run the following steps:

  1. Initialize |subimage| as follows:
    <dl class="switch">
      <dt> If {{XRWebGLBinding/getSubImage()}} was called previously with the same |binding|, |layer| and |eye|, the user agent MAY:
        <dd> Let |subimage| be the same {{XRWebGLSubImage}} object as returned by an earlier call with the same arguments.
      <dt> Otherwise
        <dd> Let |subimage| be a [=new=] {{XRWebGLSubImage}} in the [=relevant realm=] of [=this=].
        <dd> Let |subimage|'s {{XRSubImage/viewport}} be a [=new=] {{XRViewport}} in the [=relevant realm=] of [=this=].
    </dl>
  1. If |layer|'s type is {{XRProjectionLayer}}, throw a {{TypeError}} and abort these steps.
  1. If |layer|'s {{XRCompositionLayer/layout}} attribute is {{XRLayerLayout/"default"}}, throw a {{TypeError}} and abort these steps.
  1. Let |index| be <code>0</code>.
  1. If |layer|'s {{XRCompositionLayer/layout}} attribute is {{XRLayerLayout/"stereo"}}:
    1. If |eye| is {{XREye/"none"}}, throw a {{TypeError}} and abort these steps.
    1. If |eye| is {{XREye/"right"}}, set |index| to <code>1</code>.
  1. If [=validate the state of the XRWebGLSubImage creation function=] with |layer| and |frame| is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If the |layer| was created with a textureType of {{"texture-array"}}
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the first element of the |layer|'s [=colorTextures=] array.
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with |index|.
      <dt> Otherwise
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the element at offset |index| of the |layer|'s [=colorTextures=] array.
      </dl>
    </dl>
  1. Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} as follows:
    <dl class="switch">
      <dt class="switch">If the |layer|'s [=depthStencilTextures=] is an empty array.
        <dd> Continue to the next entry.
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the first element of |layer|'s [=depthStencilTextures=] array.
      <dt> Otherwise
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element at offset |index| of the |layer|'s [=depthStencilTextures=] array.
      </dl>
  1. Set |subimage|'s {{XRWebGLSubImage/textureWidth}} to the pixel width of |subimage|'s {{XRWebGLSubImage/colorTexture}}.
  1. Set |subimage|'s {{XRWebGLSubImage/textureHeight}} to the pixel height of |subimage|'s {{XRWebGLSubImage/colorTexture}}.
  1. Let |index| be <code>0</code>.
  1. If |eye| is {{XREye/"right"}}, set |index| to <code>1</code>.
  1. Let |num| be <code>1</code>.
  1. If |eye| is not {{XREye/"none"}} and |layer|'s {{XRCompositionLayer/layout}} attribute is {{XRLayerLayout/"stereo-left-right"}} or {{XRLayerLayout/"stereo-top-bottom"}}, set |num| to <code>2</code>.
  1. Run [=initialize the viewport=] on |subimage|'s {{XRSubImage/viewport}} with |subimage|'s {{XRWebGLSubImage/colorTexture}}, |layer|'s {{XRCompositionLayer/layout}}, |index| and |num|.
  1. [=Queue a task=] to set {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. return |subimage|.

</div>

<div class="algorithm" data-algorithm="getViewSubImageAlgo">
The <dfn method for="XRWebGLBinding">getViewSubImage(XRProjectionLayer |layer|, XRView |view|)</dfn> method creates a new {{XRWebGLSubImage}}.

When this method is invoked on an {{XRWebGLBinding}} |binding|, it MUST run the following steps:

  1. Initialize |subimage| as follows:
    <dl class="switch">
      <dt> If {{XRWebGLBinding/getViewSubImage()}} was called previously with the same |binding|, |layer| and |view|, the user agent MAY:
        <dd> Let |subimage| be the same {{XRWebGLSubImage}} object as returned by an earlier call with the same arguments.
      <dt> Otherwise
        <dd> Let |subimage| be a [=new=] {{XRWebGLSubImage}} in the [=relevant realm=] of [=this=].
        <dd> Let |subimage|'s {{XRSubImage/viewport}} be a [=new=] {{XRViewport}} in the [=relevant realm=] of [=this=].
    </dl>
  1. Let |frame| be |view|'s {{frame}}.
  1. Let |session| be [=this=] [=XRWebGLBinding/session=].
  1. If [=validate the state of the XRWebGLSubImage creation function=] with |layer| and |frame| is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. If |view|'s [=view/active=] flag is <code>false</code>, throw an {{InvalidStateError}} and abort these steps.
  1. Initialize |index| as follows:
    <dl class="switch">
      <dt> If |view| is a [=secondary view=] from |session|'s [=list of views=]
        <dd> Let |index| be the offset of |view|'s [=view=] in |session|'s [=list of views=] excluding the [=primary view|primary views=].
      <dt> Otherwise
        <dd> Let |index| be the offset of |view|'s [=view=] in |session|'s [=list of views=] excluding the [=secondary view|secondary views=].
    </dl>
  1. Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} as follows:
    <dl class="switch">
      <dt> If |view| is a [=secondary view=] from |session|'s [=list of views=]
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the element at offset |index| of the |layer|'s [=XRProjectionLayer/colorTextures for secondary views=].
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with <code>0</code>.
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the first element of the |layer|'s [=colorTextures=] array.
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with |index|.
      <dt> Otherwise
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the element at offset |index| of the |layer|'s [=colorTextures=] array.
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/imageIndex}} with <code>0</code>.
    </dl>
  1. Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} as follows:
    <dl class="switch">
      <dt> If the |layer|'s [=depthStencilTextures=] is an empty array.
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with <code>null</code>.
      <dt> Else if |view| is a [=secondary view=] from |session|'s [=list of views=]
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/colorTexture}} with the element at offset |index| of the |layer|'s [=XRProjectionLayer/depthStencilTextures for secondary views=].
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the first element of |layer|'s [=depthStencilTextures=] array.
      <dt> Otherwise
        <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element at offset |index| of the |layer|'s [=depthStencilTextures=] array.
    </dl>
  1. Set |subimage|'s {{XRWebGLSubImage/textureWidth}} to the pixel width of |subimage|'s {{XRWebGLSubImage/colorTexture}}.
  1. Set |subimage|'s {{XRWebGLSubImage/textureHeight}} to the pixel height of |subimage|'s {{XRWebGLSubImage/colorTexture}}.
  1. Run [=initialize the viewport=] on |subimage|'s {{XRSubImage/viewport}} with |subimage|'s {{XRWebGLSubImage/colorTexture}}, |layer|'s {{XRCompositionLayer/layout}}, |index| and the number of the |session|'s [=list of views=].
  1. Set {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. return |subimage|

</div>

When an {{XRLayer}} is a member of the {{XRRenderState/layers}} array, it MUST be presented to the [=immersive XR device=] immediately after
an [=XR animation frame=] completes, but only if at least one of the following has occurred since the previous [=XR animation frame=]:

  - The {{XRLayer}} was added to {{XRRenderState/layers}} since the previous [=XR animation frame=].
  - {{XRLayer}} is an {{XRWebGLLayer}} and {{clear}}, {{drawArrays}}, {{drawElements}}, or any other rendering operation which similarly affects the framebuffer's color values has been called while the [=opaque framebuffer=] is the currently bound framebuffer of the {{WebGLRenderingContext}} associated with the {{XRWebGLLayer}}.
  - {{XRLayer}} is an {{XRCompositionLayer}} and {{XRWebGLBinding/getSubImage()}} or {{XRWebGLBinding/getViewSubImage()}} was called and any rendering operation has been called that affects the color value of the {{XRWebGLSubImage/colorTexture}} texture.

Before the [=opaque framebuffer=] or {{XRWebGLSubImage/colorTexture}} texture are presented to the [=immersive XR device=] the user agent MUST ensure that all rendering operations have been flushed.

Video layer creation {#videolayer}
====================

XRMediaLayerInit {#xrmedialayerinittype}
----------------
The {{XRMediaLayerInit}} dictionary represents a set of configurable values that describe how an {{XRCompositionLayer}} containing a video
is initialized.

<pre class="idl">
dictionary XRMediaLayerInit {
  required XRSpace space;
  XRLayerLayout layout = "mono";
  boolean invertStereo = false;
};
</pre>

The <dfn dict-member for="XRMediaLayerInit">space</dfn> attribute defines the spatial relationship with the user’s physical environment.

The <dfn dict-member for="XRMediaLayerInit">layout</dfn> attribute defines the layout of the video in the {{XRCompositionLayer}}.

The <dfn dict-member for="XRMediaLayerInit">invertStereo</dfn> attribute defines if the natural location of each view in the video
should be inverted.

XRMediaQuadLayerInit {#xrmediaquadlayerinittype}
------------------------
The {{XRMediaQuadLayerInit}} dictionary represents a set of configurable values that describe how an {{XRQuadLayer}} containing a video
is initialized.

<pre class="idl">
dictionary XRMediaQuadLayerInit : XRMediaLayerInit {
  XRRigidTransform? transform;
  float? width;
  float? height;
};
</pre>

XRMediaCylinderLayerInit {#xrmediacylinderlayerinittype}
------------------------
The {{XRMediaCylinderLayerInit}} dictionary represents a set of configurable values that describe how an {{XRCylinderLayer}} containing a video
is initialized.

<pre class="idl">
dictionary XRMediaCylinderLayerInit : XRMediaLayerInit {
  XRRigidTransform? transform;
  float radius = 2.0;
  float centralAngle = 0.78539;
  float? aspectRatio;
};
</pre>

XRMediaEquirectLayerInit {#xrmediaequirectlayerinittype}
------------------------
The {{XRMediaEquirectLayerInit}} dictionary represents a set of configurable values that describe how an {{XREquirectLayer}} containing a video
is initialized.

<pre class="idl">
dictionary XRMediaEquirectLayerInit : XRMediaLayerInit {
  XRRigidTransform? transform;
  float radius = 0.0;
  float centralHorizontalAngle = 6.28318;
  float upperVerticalAngle = 1.570795;
  float lowerVerticalAngle = -1.570795;
};
</pre>

XRMediaBinding {#xrmediabindingtype}
--------------
The {{XRMediaBinding}} object is used to create layers that display the content of an {{HTMLVideoElement}}.

<pre class="idl">
[Exposed=Window] interface XRMediaBinding {
  constructor(XRSession session);

  XRQuadLayer createQuadLayer(HTMLVideoElement video, optional XRMediaQuadLayerInit init);
  XRCylinderLayer createCylinderLayer(HTMLVideoElement video, optional XRMediaCylinderLayerInit init);
  XREquirectLayer createEquirectLayer(HTMLVideoElement video, optional XRMediaEquirectLayerInit init);
};
</pre>

ISSUE: the init dictionaries shouldn't be optional. This is bikeshed issue 1566.

Each {{XRMediaBinding}} has an associated <dfn dfn-for="XRMediaBinding">session</dfn>, which is the
{{XRSession}} it was created with.

NOTE: It is possible to create more than one {{XRMediaBinding}}. The lifetime of a layer is not tied
to the lifetime of the {{XRMediaBinding}} that created it.

Each layer created through {{XRMediaBinding}} has an internal {{HTMLVideoElement}} [=XRCompositionLayer/media=].
If the layer is part of the session's {{XRSession/renderState}}, it will display the current frame of the video. The
layer is update at the native framerate of the [=/XR device=] or the video, whichever is less.

NOTE: only the video frames will be displayed in the layer. Video controls should be implemented by the author and must
be drawn in another layer.

ISSUE: more clarification is needed on how the video is blitted to the layers.

<div class="algorithm" data-algorithm="render-media-layer">
When an {{XRCompositionLayer}} |layer| with a {{HTMLVideoElement}} |media| needs to be rendered, the user agent
MUST run the following steps:
  1. Let |usability| be the result of [=check the usability of the image argument|checking the usability of=] |media|.
  1. If |usability| is <code>bad</code>, then fill the |layer| with opaque black and abort these steps.
  1. Fill the |layer| with the content of the |media| element.

<!--
-> maybe this is needed later
  1. Render the |layer| as follows:
    <dl class="switch">
      <dt class="switch">If the |layer|'s {{XRCompositionLayer/layout}} is {{XRLayerLayout/"mono"}}
      <dd> Fill the |layer| with the
      <dt> Else if the |layer| was created with a textureType of {{"texture-array"}}
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element at offset |index| of the |layer|'s [=depthStencilTextures=] array.
      <dt> Otherwise
      <dd> Initialize |subimage|'s {{XRWebGLSubImage/depthStencilTexture}} with the element of the |layer|'s [=depthStencilTextures=] array that corresponds to the |view|.
    </dl>
-->
</div>

ISSUE: add a better algorithm to describe the drawing.

<div class="algorithm" data-algorithm="construct-media-binding">

The <dfn constructor for="XRMediaBinding">XRMediaBinding(XRSession |session|)</dfn> constructor
MUST perform the following steps when invoked:

  1. If |session|'s [=ended=] value is <code>true</code>, throw an {{InvalidStateError}} and abort these steps.
  1. If |session| is not an [=immersive session=], throw an {{InvalidStateError}} and abort these steps.
  1. Let |binding| be a [=new=] {{XRMediaBinding}}in the [=relevant realm=] of |session|.
  1. Initialize |binding|'s [=XRMediaBinding/session=] to |session|.
  1. Return |binding|.

</div>

<div class="algorithm" data-algorithm="calculateaspectratio">
To <dfn>calculate the aspect ratio</dfn> of an {{HTMLVideoElement}} |video| and an {{XRLayerLayout}} |layout|, run the following steps:
  1. Let |width| be the |video|'s {{HTMLVideoElement/videoWidth}}.
  1. Let |height| be the |video|'s {{HTMLVideoElement/videoHeight}}.
  1. If |layout| is {{XRLayerLayout/"stereo-left-right"}}, divide |width| by <code>2</code>.
  1. If |layout| is {{XRLayerLayout/"stereo-top-bottom"}}, divide |height| by <code>2</code>.
  1. Return |width| divided by |height|.

</div>

<div class="algorithm" data-algorithm="createMediaQuadLayerAlgo">
The <dfn method for="XRMediaBinding">createQuadLayer(HTMLVideoElement |video|, XRMediaQuadLayerInit |init|)</dfn> method creates a new {{XRQuadLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRMediaBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw a {{NotSupportedError}} and abort these steps.
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRMediaLayerInit/layout}} is {{XRLayerLayout/"default"}}, throw a {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRQuadLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session|.
  1. Initialize |layer|'s [=XRCompositionLayer/media=] to |video|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. Let |aspectRatio| be the result of [=calculate the aspect ratio=] with |video| and |init|'s {{XRMediaLayerInit/layout}}.
  1. If |init|'s {{XRMediaQuadLayerInit/width}} and {{XRMediaQuadLayerInit/height}} are <code>undefined</code>, set {{XRMediaQuadLayerInit/width}} to <code>1</code>.
  1. If |init|'s {{XRMediaQuadLayerInit/height}} is <code>undefined</code>, set {{XRMediaQuadLayerInit/height}} to {{XRMediaQuadLayerInit/width}} divided by |aspectRatio|.
  1. If |init|'s {{XRMediaQuadLayerInit/width}} is <code>undefined</code>, set {{XRMediaQuadLayerInit/width}} to {{XRMediaQuadLayerInit/height}} multiplied by |aspectRatio|.
  1. Run [=initialize a quad layer=] with |layer| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createMediaCylinderLayerAlgo">
The <dfn method for="XRMediaBinding">createCylinderLayer(HTMLVideoElement |video|, XRMediaCylinderLayerInit |init|)</dfn> method creates a new {{XRCylinderLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRMediaBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw a {{NotSupportedError}} and abort these steps.
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRMediaLayerInit/layout}} is {{XRLayerLayout/"default"}}, throw a {{TypeError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XRCylinderLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session|.
  1. Initialize |layer|'s [=XRCompositionLayer/media=] to |video|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. Let |aspectRatio| be the result of [=calculate the aspect ratio=] with |video| and |init|'s {{XRMediaLayerInit/layout}}.
  1. If |init|'s {{XRMediaCylinderLayerInit/aspectRatio}} is <code>undefined</code>, set {{XRMediaCylinderLayerInit/aspectRatio}} to |aspectRatio|.
  1. Run [=initialize a cylinder layer=] with |layer| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

<div class="algorithm" data-algorithm="createMediaEquirectLayerAlgo">
The <dfn method for="XRMediaBinding">createEquirectLayer(HTMLVideoElement |video|, XRMediaEquirectLayerInit |init|)</dfn> method creates a new {{XREquirectLayer}} |layer|.

When this method is invoked, the user agent MUST run the following steps:

  1. Let |session| be [=this=] [=XRMediaBinding/session=].
  1. If |session| was not created with "[=feature descriptor/layers=]" enabled, throw a {{NotSupportedError}} and abort these steps.
  1. If |session|'s [=ended=] value is <code>true</code>, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRMediaLayerInit/layout}} is {{XRLayerLayout/"default"}}, throw a {{TypeError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} is not an instance of type {{XRReferenceSpace}}, throw {{InvalidStateError}} and abort these steps.
  1. If |init|'s {{XRLayerInit/space}} has a [=XRReferenceSpace/type=] of {{XRReferenceSpaceType/"viewer"}}, throw {{InvalidStateError}} and abort these steps.
  1. Let |layer| be a [=new=] {{XREquirectLayer}} in the [=relevant realm=] of [=this=].
  1. Run [=intialize a composition layer=] on |layer| with |session|.
  1. Initialize |layer|'s [=XRCompositionLayer/media=] to |video|.
  1. Initialize |layer|'s {{XRCompositionLayer/needsRedraw}} to <code>false</code>.
  1. Run [=initialize a equirect layer=] with |layer| and |init|.
  1. Allocate and initialize resources compatible with |session|'s [=/XR device=], including GPU accessible memory buffers, as required to support the compositing of |layer|.
  1. If |layer|’s resources were unable to be created for any reason, throw an {{OperationError}} and abort these steps.
  1. return |layer|.

</div>

ISSUE: define how the {{XREquirectLayer}}'s parameters affect the video display.

Events {#events}
======

XRLayerEvent {#xrlayerevent-interface}
--------------

{{XRLayerEvent}} is fired to indicate changes to the state of an {{XRLayer}}.

<pre class="idl">
[SecureContext, Exposed=Window] interface XRLayerEvent : Event {
  constructor(DOMString type, XRLayerEventInit eventInitDict);
  [SameObject] readonly attribute XRLayer layer;
};

dictionary XRLayerEventInit : EventInit {
  required XRLayer layer;
};
</pre>

The <dfn attribute for="XRLayerEvent">layer</dfn> attribute indicates the {{XRLayer}} that generated the event.

Event Types {#event-types}
-----------

The user agent MUST provide the following new events. Registration for and firing of the events must follow the usual behavior of DOM4 Events.

The user agent MAY fire a <dfn event for="XRLayer">redraw</dfn> event on the {{XRLayer}} object when [=the underlying resources of a layer are lost=] or
when the [=XR Compositor=] can no longer reproject the layer.

The author SHOULD redraw the content of the layer at the next [=XR animation frame=]. The event must be of type {{XRLayerEvent}}.

WebXR Device API Integration {#webxrintegration}
============================

XRRenderState changes {#xrrenderstatechanges}
---------------------
This module extends the {{XRRenderStateInit}} and {{XRRenderState}} interfaces with a new optional array {{XRRenderStateInit/layers}} containing
instances of {{XRLayer}}.

<pre class="idl">
[SecureContext, Exposed=Window] partial interface XRRenderState {
  readonly attribute FrozenArray&lt;XRLayer&gt; layers;
};
</pre>

The <dfn attribute for="XRRenderState">layers</dfn> attribute returns an array containing
the instances of {{XRLayer}} that are displayed by the [=XR Compositor=].

The {{XRRenderStateInit/layers}} array defines the order of the composition of the layers. The [=XR Compositor=] MUST draw each layer
in order of its position in the array using [=source-over=] blending. The [=XR Compositor=] MUST NOT apply any depth sorting of the layers.

NOTE: this means that each layer can potentially overwrite the previous layers whether or not the previous layers are virtually closer to the viewer.

<div class="algorithm" data-algorithm="initialize-renderstate-for-layers">
This module replaces the steps given by [=initialize the render state=]. Instead when an {{XRRenderState}} object |state|
is created for an {{XRSession}} |session|, the user agent MUST <dfn dfn-for="layers">initialize the render state</dfn> by running the following steps:
  1. Initialize |state| by running the original steps to [=initialize the render state=].
  1. Initialize |state|'s {{XRRenderState/layers}} with a [=new=] empty array in the [=relevant realm=] of |session|.

</div>

updateRenderState changes {#updaterenderstatechanges}
-------------------------

<div class="algorithm" data-algorithm="update-layers-state-for-layers">

This module replaces the steps given by "[=update the pending layers state=]" from the WebXR specification. Instead when the user agent will
<dfn dfn-for="layers">update the pending layers state</dfn> with {{XRSession}} |session| and {{XRRenderStateInit}} |newState|, it must run the following steps:
  1. If both |newState|'s {{XRRenderStateInit/baseLayer}} and |newState|'s {{XRRenderStateInit/layers}} are set, throw a {{NotSupportedError}} and abort these steps.
  1. Let |activeState| be |session|'s [=active render state=].
  1. If |newState|'s {{XRRenderStateInit/baseLayer}} is set:
    1. If |session|'s [=pending render state=] is <code>null</code>, set it to a copy of |activeState|.
    1. Set |session|'s [=pending render state=]'s {{XRRenderState/layers}} to <code>null</code>.
  1. If |newState|'s {{XRRenderStateInit/layers}} is set:
    1. If |session| was not created with "[=feature descriptor/layers=]" enabled and |newState|'s {{XRRenderStateInit/layers}} contains more than <code>1</code> instance, throw a {{NotSupportedError}} and abort these steps.
    1. If |session|'s [=pending render state=] is <code>null</code>, set it to a copy of |activeState|.
    1. If |newState|'s {{XRRenderStateInit/layers}} contains duplicate instances, throw a {{TypeError}} and abort these steps.
    1. For each |layer| in |newState|'s {{XRRenderStateInit/layers}}:
        1. If |layer| is an {{XRCompositionLayer}} and |layer|'s [=XRCompositionLayer/session=] is different from |session|, throw a {{TypeError}} and abort these steps.
        1. If |layer| is an {{XRWebGLLayer}} and |layer|'s [=XRWebGLLayer/session=] is different from |session|, throw a {{TypeError}} and abort these steps.
    1. Set |session|'s [=pending render state=]'s {{XRRenderState/baseLayer}} to <code>null</code>.
    1. Set |session|'s [=pending render state=]'s {{XRRenderState/layers}} to |newState|'s {{XRRenderStateInit/layers}}.

</div>

XRCompositor changes {#xrcompositorchanges}
---------------------
The [=XR Compositor=] MUST be extended so all {{XRLayer}} instances from the {{XRRenderState/layers}} array are composited
at the same time. All other requirements for [=XR Compositor|WebXR=] MUST continue to apply.

If the [=XR Compositor=] is rendering to a [=view=] with an {{XREye}} of {{XREye/"none"}} and drawing an {{XRCompositionLayer}} which is NOT an
{{XRProjectionLayer}} and does NOT have a {{XRCompositionLayer/layout}} of {{XRLayerLayout/"mono"}}, the [=XR Compositor=] MUST render that layer
as if the [=view=] had an {{XREye}} of {{XREye/"left"}}.

NOTE: This means that the side for the right eye of the layer is ignored. This enables authors to use the same assets for stereoscopic and
monoscopic devices.

XRView changes {#xrviewchanges}
--------------
Each [=view=] MUST define a <dfn ignore=''>recommended WebGL texture resolution</dfn> which represents a best estimate of the WebGL texture
resolution large enough to contain the view.

Animation frames changes {#animationframeschanges}
------------------------

<div class="algorithm" data-algorithm="update-check-layers-state">
This module replaces the steps given by "[=check the layers state=]" from the WebXR specification. Instead to <dfn>check the layers state</dfn>
with {{XRSession/renderState}} |state|, the user agent MUST run the following steps:

  1. If |state|'s {{XRRenderState/baseLayer}} is not <code>null</code>, return <code>true</code>.
  1. If |state|'s {{XRRenderStateInit/layers}} is not empty, return <code>true</code>.
  1. return <code>false</code>.

</div>

Security and Privacy Considerations {#security}
===============================================

Timing of the composition {#xrcompositiontiming}
-------------------------

Composition timing MUST be independent of the content that is rendered.
Moreover, content in a layer MUST not be observable in other layers.

If possible, composition of layers should happen outside the browser to reduce risk of timing attacks or other security vulnerabilities.
